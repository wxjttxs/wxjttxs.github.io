<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happy happy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxjttxs.github.io/"/>
  <updated>2016-05-09T15:16:37.526Z</updated>
  <id>http://wxjttxs.github.io/</id>
  
  <author>
    <name>王晓静</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>圆圈剩下的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E5%9C%86%E5%9C%88%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/09/圆圈剩下的数字/</id>
    <published>2016-05-09T15:16:13.000Z</published>
    <updated>2016-05-09T15:16:37.526Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//从0~n-1这n个数字构成环形，从0开始每次删除第m个数字，求最后一个剩下的数字 //要么借助环形链表数据结构&lt;br&gt;//要么通过数学建模找到规律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;list&amp;gt;
using namespace std;
//**********************方法一环形结构****************************
//std::list本身并不是一个环形结构，因此每当迭代器扫描到末尾时候，我们要把迭代器移到链表头部，
//Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢.
int LastRemaining(unsigned int n,unsigned int m){
    if(n&amp;lt;1 || m&amp;lt;1)
        return -1;
    unsigned int i=0;
    list&amp;lt;int&amp;gt; numbers;
    for(i=0;i&amp;lt;n;i++)
        numbers.push_back(i);//0~n-1
    list&amp;lt;int&amp;gt;::iterator current=numbers.begin();
    while(numbers.size()&amp;gt;1){
        for(int i=1;i&amp;lt;m;i++){//找到第m个要删除的位置
            current++;//current指向要删除的位置
            if(current==numbers.end())
                current=numbers.begin();

        }
        list&amp;lt;int&amp;gt;::iterator next=++current;
        if(next==numbers.end())
            next=numbers.begin();
        --current;
        numbers.erase(current);
        current=next;
    }
    return *(current);
}
//**********************方法二数学建模****************************
//令f(n,m)表示从0开始删除第m个数字后的剩下的数字；第一个删除的数字是（m-1)%n，为了简单表示，我们令k=（m-1)%n。剩下的数字0,1,2，，，，k-1,k+1,k+2..n-1;
//下一次从k+1开始计数。相当于形成这样的序列：k+1,k+2...0,1...k-1。剩下的序列也是关于n,m的函数。但是这个序列的规律和最初的规律不一样。因此记为f&amp;apos;(n-1,m).
//最初序列剩下的数字一定是删除一个数字之后的序列最后剩下的数字，即f(n,m)=f&amp;apos;(n-1,m).
//定义一种映射 ，使得k+1,k+2...0,1...k-1 -》0,1.。。n-2，p(x)=(x-k-1)%n.逆映射p&amp;apos;(x)=(x+k+1)%n
//f(n,m)=f&amp;apos;(n-1,m)=p&amp;apos;(f(n-1,m))=[f(n-1,m)+k+1]%n=[f(n-1,m)+m]%n;
//综上，递归公式：f(n,m)=0   n=1
//                      =[f(n-1,m)+m]%n  n&amp;gt;1

int LastRemaining(unsigned int n,unsigned int m){
    if(n&amp;lt;1 ||m&amp;lt;1)
        return -1;
    int last=0;
    for(int i=2;i&amp;lt;=n;i++)
        last=(last+m)%i;
    return last;
}
int main()
{
    int data[]={3,4,5,6,7,8};
    for(int i=0;i&amp;lt;6;i++)

        cout&amp;lt;&amp;lt;LastRemaining(data[i],3)&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//从0~n-1这n个数字构成环形，从0开始每次删除第m个数字，求最后一个剩下的数字 //要么借助环形链表数据结构&lt;br&gt;//要么通过数学建模找到规律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostre
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扑克牌是不是顺子</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E6%89%91%E5%85%8B%E7%89%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E9%A1%BA%E5%AD%90/"/>
    <id>http://wxjttxs.github.io/2016/05/09/扑克牌是不是顺子/</id>
    <published>2016-05-09T10:33:45.000Z</published>
    <updated>2016-05-09T10:34:19.965Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//从扑克牌中抽出五张，判断是不是顺子，A用1表示；JQK用11,12,13表示；大小王看成任意数字&lt;br&gt;//首先排序数组，然后统计0的个数和数组中间隔数，如果0的个数&amp;gt;=间隔，返回true。&lt;br&gt;//还有需要注意，如果数组中有两个数字相同，那么不可能是顺子了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

int compare(const void *arg1,const void *arg2){
    return *(int*)arg1-*(int*)arg2;
}
bool IsContinuous(int *data,int length){
    if(data==NULL ||length&amp;lt;1)
        return false;

    qsort(data,length,sizeof(int),compare);//排序

    int numberOfZero=0;//0的个数，间隔的数目
    int numberOfGap=0;

    //统计0的个数
    for(int i=0;i&amp;lt;length;i++){
        if(data[i]==0)
            numberOfZero++;
    }
    //统计间隔数目
    int small=numberOfZero;//必须从这个开始，因为0不能算在这个里面，代表的是任意
    int big=small+1;
    while(big&amp;lt;length){
        //两个数相等，对子不可能是顺子
        if(data[small]==data[big])
            return false;
        numberOfGap+=data[big]-data[small]-1;//比如 1  3   4  5
        small=big;//两个指针，依次往后挪
        big++;
    }
    return (numberOfGap&amp;lt;=numberOfZero)?true:false;

}
int main()
{
    int data[]={2,4,5,6,0};
    cout&amp;lt;&amp;lt;IsContinuous(data,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//从扑克牌中抽出五张，判断是不是顺子，A用1表示；JQK用11,12,13表示；大小王看成任意数字&lt;br&gt;//首先排序数组，然后统计0的个数和数组中间隔数，如果0的个数&amp;gt;=间隔，返回true。&lt;br&gt;//还有需要注意，如果数组中有两个数字相
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>n个骰子和为S的次数以及相应的概率</title>
    <link href="http://wxjttxs.github.io/2016/05/09/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E5%92%8C%E4%B8%BAS%E7%9A%84%E6%AC%A1%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%BA%94%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <id>http://wxjttxs.github.io/2016/05/09/n个骰子和为S的次数以及相应的概率/</id>
    <published>2016-05-09T09:10:41.000Z</published>
    <updated>2016-05-09T09:11:12.215Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//把n个骰子扔地上，所有骰子朝上一面的点数之和为 S。输入n,打印出S中所有可能出现的值的概率。&lt;br&gt;//动态规划.找到最优子结构。采用备忘录的方法避免重复计算。&lt;br&gt;//最优子结构：f(n,s)表示n个骰子点数和为S的种类，N表示骰子个数，S表示N个骰子的点数和&lt;br&gt;//F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)+F(n-1,s-6)&lt;br&gt;n&amp;gt;0,n&amp;lt;=S&amp;lt;=6&lt;em&gt;n //      =0  n&amp;gt;S  or  S&amp;gt;6&lt;/em&gt;k&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int FACE_NUM=6;//骰子的面数
//函数功能：N个骰子的向上一面的和
//函数参数：骰子数目

void PrintSumProbabilityOfDices(int n){
    if(n&amp;lt;=0)
        return;
    int *pSum=new int[n*FACE_NUM+1];//和的种类
    double total=pow(6.0,n);//和的所有可能性
    int sizee=n*FACE_NUM;
    int i,j,k;
    //初始化
    pSum[0]=0;//没有骰子
    for(i=1;i&amp;lt;=FACE_NUM;i++)
        pSum[i]=1;//只有一个骰子,和的可能性为1~6，只可能出现一次
    for(;i&amp;lt;=sizee;i++)
        pSum[i]=0;//数组初始化0
    for(i=2;i&amp;lt;=n;i++){//骰子数目从2~n
        for(j=i*FACE_NUM;j&amp;gt;=i;j--){//i个骰子和的范围是i~i*FACE_NUM，j代表的是可能的和的种类
            pSum[j]=0;//每次要清零
            for(k=1;k&amp;lt;=6 &amp;amp;&amp;amp; j&amp;gt;=k;k++){//这个就是F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)+F(n-1,s-6)
                pSum[j]+=pSum[j-k];
            }
        }
        //不可能的情况
        for(j=i-1;j&amp;gt;=0;j--)
            pSum[j]=0;
    }
   //打印结果
   for(i=0;i&amp;lt;=sizee;i++){
        cout&amp;lt;&amp;lt;&amp;quot;sum= &amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot;, p= &amp;quot;&amp;lt;&amp;lt;pSum[i]/total&amp;lt;&amp;lt;endl;
   }
}
int main()
{
    PrintSumProbabilityOfDices(3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//把n个骰子扔地上，所有骰子朝上一面的点数之和为 S。输入n,打印出S中所有可能出现的值的概率。&lt;br&gt;//动态规划.找到最优子结构。采用备忘录的方法避免重复计算。&lt;br&gt;//最优子结构：f(n,s)表示n个骰子点数和为S的种类，N表示骰子个数，
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>翻转单词顺序 VS 左旋转字符串</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F-VS-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wxjttxs.github.io/2016/05/09/翻转单词顺序-VS-左旋转字符串/</id>
    <published>2016-05-09T03:01:09.000Z</published>
    <updated>2016-05-09T08:10:16.222Z</updated>
    
    <content type="html">&lt;p&gt;//一个字符串。要求翻转单词顺序，但是单词内部字符顺序不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string.h&amp;gt;
using namespace std;
//翻转一个单词
void Reverse(char* pBegin,char* pEnd){
    if(pBegin==NULL || pEnd==NULL)
        return;
    while(pBegin&amp;lt;pEnd){
        char temp=*pBegin;
        *pBegin=*pEnd;
        *pEnd=temp;
        pBegin++;
        pEnd--;
    }
}
char* ReverseSentence(char *pData)
{
    if(pData == NULL)
        return NULL;

    char *pBegin = pData;

    char *pEnd = pData+strlen(pData)-1;

    // 翻转整个句子
    Reverse(pBegin, pEnd);

    // 翻转句子中的每个单词
    pBegin = pEnd = pData;
    while(*pEnd!=&amp;apos;\0&amp;apos;){
        if(*pEnd!=&amp;apos; &amp;apos;)
            pEnd++;
        else{
            Reverse(pBegin,pEnd-1);//空格前一个
            pBegin=++pEnd;//pBegin指向空格后一个
        }
    }
    Reverse(pBegin,pEnd-1);//最后一个单词，pEnd指向&amp;apos;\0&amp;apos;
    return pData;
}

//********************左旋转n位字符**************************
//前n位看做空格前字母，比如“hello world”
char* LeftRotateString(char* pStr,int n){
    if(pStr!=NULL){
        int length=static_cast&amp;lt;int&amp;gt;(strlen(pStr));
        if(length&amp;gt;0 &amp;amp;&amp;amp; n&amp;gt;0 &amp;amp;&amp;amp;n&amp;lt;length){//输入是有效的
            char* pFirstBegin=pStr;
            char* pFirstEnd=pStr+n-1;
            char* pSecondBegin=pStr+n;
            char* pSecondEnd=pStr+length-1;
            Reverse(pFirstBegin,pFirstEnd);//旋转第一段
            Reverse(pSecondBegin,pSecondEnd);//旋转第二段
            Reverse(pFirstBegin,pSecondEnd);//旋转整个单词
        }
    }
    return pStr;
}
int main()
{
      char sentence[]=&amp;quot;stu dent!&amp;quot;;
      char *reverced=ReverseSentence(sentence);
      cout&amp;lt;&amp;lt;reverced&amp;lt;&amp;lt;endl;

      char sentence1[]=&amp;quot;abcdefg&amp;quot;;
      char *reverced1=LeftRotateString(sentence1,7);
     // char *reverced1=LeftRotateString(“abcdef”,2);不承认这样的赋值方式
      cout&amp;lt;&amp;lt;reverced1&amp;lt;&amp;lt;endl;
      return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//一个字符串。要求翻转单词顺序，但是单词内部字符顺序不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string.h&amp;gt;
using namespace std;
//翻转一个单词
void Revers
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>和为S，输出数组的子序列</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E5%92%8C%E4%B8%BAS%EF%BC%8C%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/05/09/和为S，输出数组的子序列/</id>
    <published>2016-05-09T02:57:04.000Z</published>
    <updated>2016-05-09T02:58:07.869Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//数组已经排好序，假设升序。
//当给定和为S,返回数组中两个数使得他们和为s


#include &amp;lt;iostream&amp;gt;

using namespace std;
//找到排序数组和为S的两个数
//void FindNumbersWithSum(int *data,int length,int s){
//    bool flag=false;
//    if(data==NULL ||length&amp;lt;1)
//        return;
//    int ahead=0;
//    int behind=length-1;
//    while(ahead&amp;lt;behind){
//        if(data[ahead]+data[behind]==s){
//            flag=true;
//            break;//找到就跳出循环，不然就死了
//        }
//        else if(data[ahead]+data[behind]&amp;gt;s)
//            behind--;
//        else
//            ahead++;
//    }
//    if(flag){
//        cout&amp;lt;&amp;lt;data[ahead]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;data[behind];
//    }
//    else
//        cout&amp;lt;&amp;lt;&amp;quot;not found&amp;quot;&amp;lt;&amp;lt;endl;
//}
//************拓展*********************************8
//找到连续正数序列（1,2,3.。。。。S）中和为S的序列，打印出来,至少为3
void PrintContinueSequence(int small, int big){
    for(int i=small;i&amp;lt;=big;i++)
        cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;
}
void FindContinueSequence(int sum){
    if(sum&amp;lt;3)
        return ;
    int small=1;
    int big=2;
    int mid=(sum+1)/2;//因为是递增，所以最小的数不可能超过中间值
    int curSum=small+big;
    while(small&amp;lt;mid){
        if(curSum==sum){
            PrintContinueSequence(small,big);
        }
        while(curSum&amp;gt;sum &amp;amp;&amp;amp; small&amp;lt;mid){
            curSum-=small;//先减去已经在里面的小的数值
            small++;

            if(curSum==sum)
                PrintContinueSequence(small,big);
        }
        big++;
        curSum+=big;//后加上不在里面的大的数值
    }
}
int main()
{
//    int data[]={1,2,3,7,11,15};
//    FindNumbersWithSum(data,6,1);
      FindContinueSequence(13);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//数组已经排好序，假设升序。
//当给定和为S,返回数组中两个数使得他们和为s


#include &amp;lt;iostream&amp;gt;

using namespace std;
//找到排序数组和为S的两个数
//void FindNumbersWith
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组中只出现一次的两个数字</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/09/数组中只出现一次的两个数字/</id>
    <published>2016-05-09T02:16:17.000Z</published>
    <updated>2016-05-09T02:17:14.185Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//这样的数组：只有两个数字只出现一次，其他数字出现两次。输出只出现一次的数字&lt;br&gt;//如果是只出现一次的数字有一个，那么异或整个数组元素，得到的结果恰好就是那个单独的元素&lt;br&gt;//所以把原始数组分成两个子数组。每个子数组只包含一个只出现一次的数字。&lt;br&gt;//先异或整个数组元素，得到不是0的结果，化成二进制，找到第一个1的位置index，然后把原数组按照这个index是不是1来分开。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

//最右边1的位置
unsigned int FindFirst1Bit(int num);
//从右边数起的indexBit位是不是1
bool IsBit1(int num,unsigned int indexBit);
//主要实现
void FindNumberAppearOnce(int *data,int length){
    if(data==NULL || length&amp;lt;2)//,int &amp;amp;num1,int &amp;amp;num2
        return ;
    int resExclusiveOr=0;
    for(int i=0;i&amp;lt;length;i++){
        resExclusiveOr^=data[i];
    }
    unsigned int indexOf1=FindFirst1Bit(resExclusiveOr);//根据异或结果找到右边起第一个1
    int num[2]={0};
   // num1=num2=0;//两个只出现一次的数字
    for(int j=0;j&amp;lt;length;j++){
        if(IsBit1(data[j],indexOf1))
            num[0]^=data[j];
        else
            num[1]^=data[j];
    }
    for(int i=0;i&amp;lt;2;i++)
        cout&amp;lt;&amp;lt; num[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
}
//找到最右边第一个1的位置
unsigned int FindFirst1Bit(int num){
    int indexBit=0;
    while(((num&amp;amp;1)==0) &amp;amp;&amp;amp; (indexBit&amp;lt;8 * sizeof(int))){
        num=num&amp;gt;&amp;gt;1;
        ++indexBit;
    }
    return  indexBit;
}
//从右边起indexBit位是不是1
bool IsBit1(int num,unsigned int indexBit){
    num=num&amp;gt;&amp;gt;indexBit;
    return (num&amp;amp;1);
}
int main()
{
    int data[]={2,4,3,6,3,2,5,5};
   // int a,b;
    FindNumberAppearOnce(data,8);
  //  cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;b;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//这样的数组：只有两个数字只出现一次，其他数字出现两次。输出只出现一次的数字&lt;br&gt;//如果是只出现一次的数字有一个，那么异或整个数组元素，得到的结果恰好就是那个单独的元素&lt;br&gt;//所以把原始数组分成两个子数组。每个子数组只包含一个只出现一次的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>是不是平衡树</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/08/是不是平衡树/</id>
    <published>2016-05-08T14:40:57.000Z</published>
    <updated>2016-05-08T14:41:33.443Z</updated>
    
    <content type="html">&lt;p&gt;//平衡二叉树的概念：左右子树的深度相差不超过1&lt;br&gt;//判断一棵二叉树是不是平衡二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//构建二叉树
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
//*****************方法一****************************
////二叉树的深度
//    int TreeDepth(BinaryTreeNode* pRoot){
//        if(!pRoot)
//            return 0;
//    //    if(!pRoot-&amp;gt;m_pLeft &amp;amp;&amp;amp; !pRoot-&amp;gt;m_pRight)//不需要
//    //        return 1;
//
//        //else{
//            int nLeft=TreeDepth(pRoot-&amp;gt;m_pLeft);
//            int nRight=TreeDepth(pRoot-&amp;gt;m_pRight);
//            return (nLeft&amp;gt;nRight)?(nLeft+1):(nRight+1);
//      //  }
//
//    }
//bool IsBalanced(BinaryTreeNode* pRoot){
//    if(pRoot==NULL)
//        return true;
//    int left=TreeDepth(pRoot-&amp;gt;m_pLeft);
//    int right=TreeDepth(pRoot-&amp;gt;m_pRight);
//    int diff= left-right;
//    if(diff&amp;gt;1 ||diff&amp;lt;-1)
//        return false;
//    return IsBalanced(pRoot-&amp;gt;m_pLeft)&amp;amp;&amp;amp;IsBalanced(pRoot-&amp;gt;m_pRight);
//}
//***********************方法二***********************88
//每个节点遍历一遍，就能判断二叉树是不是平衡的；采用后序遍历,遍历一个节点的时候，它的左右子树已经遍历过了。
//在遍历节点的时候记录 它的深度，就能一边遍历，一边判断每个节点是不是平衡的
bool IsBalancedCore(BinaryTreeNode* pRoot, int* pDepth){
    if(pRoot==NULL){
        *pDepth=0;
        return true;
    }
    int left,right;
    if(IsBalancedCore(pRoot-&amp;gt;m_pLeft,&amp;amp;left)&amp;amp;&amp;amp; IsBalancedCore(pRoot-&amp;gt;m_pRight,&amp;amp;right)){
        int diff=left-right;
        if(diff&amp;lt;=1 &amp;amp;&amp;amp; diff&amp;gt;=-1){
            *pDepth=1+(left&amp;gt;right?left:right);
            return true;
        }
    }
    return false;
}
bool IsBalanced(BinaryTreeNode* pRoot){
    int depth=0;
    return IsBalancedCore(pRoot,&amp;amp;depth);
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    cout&amp;lt;&amp;lt;IsBalanced(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//平衡二叉树的概念：左右子树的深度相差不超过1&lt;br&gt;//判断一棵二叉树是不是平衡二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的深度</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/08/二叉树的深度/</id>
    <published>2016-05-08T13:40:22.000Z</published>
    <updated>2016-05-08T13:41:04.539Z</updated>
    
    <content type="html">&lt;p&gt;//查找二叉树的深度，也就是从根节点到叶子节点所有路径中，最长路径的节点数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//构建二叉树
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
//二叉树的深度：如果树只有一个节点，那么树的深度就是1；如果没有右子树，
//那么就等于左子树的深度+1；没有左子树的情况类似；如果左右子树都存在，那么就等于两个子树路径较大的那个+1
int TreeDepth(BinaryTreeNode* pRoot){
    if(!pRoot)
        return 0;
//    if(!pRoot-&amp;gt;m_pLeft &amp;amp;&amp;amp; !pRoot-&amp;gt;m_pRight)//不需要
//        return 1;

    //else{
        int nLeft=TreeDepth(pRoot-&amp;gt;m_pLeft);
        int nRight=TreeDepth(pRoot-&amp;gt;m_pRight);
        return (nLeft&amp;gt;nRight)?(nLeft+1):(nRight+1);
  //  }

}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    cout&amp;lt;&amp;lt;TreeDepth(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//查找二叉树的深度，也就是从根节点到叶子节点所有路径中，最长路径的节点数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nV
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>指定数字在排序数组中出现的次数</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/08/指定数字在排序数组中出现的次数/</id>
    <published>2016-05-08T13:05:56.000Z</published>
    <updated>2016-05-08T13:06:20.332Z</updated>
    
    <content type="html">&lt;p&gt;//得到已经排序的数组中指定数字k出现的次数&lt;br&gt;//已经排好序，所以想到用二分查找算法；&lt;br&gt;//重复次数=最后一次出现的位置-第一次出现的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int GetFirstK(int *data,int length,int k, int start,int endd){
    if(start&amp;gt;endd)
        return -1;
    int mid=(start+endd)/2;//一分为二
    int midData=data[mid];
    if(midData==k){//中间恰好等于k，那么第一个k的位置要么就是这个中间；要么位于前半段数组
        if((data[mid-1]!=k &amp;amp;&amp;amp; mid&amp;gt;0) || mid==0)
            return mid;
        else
            endd=mid-1;
    }
    else if(midData&amp;gt;k)
        endd=mid-1;
    else
        start=mid+1;
    return GetFirstK(data,length,k,start,endd);
}
int GetLastK(int *data,int length,int k,int start, int endd){
    if(data==NULL||start&amp;gt;endd)
        return -1;
    int mid=(start+endd)/2;//一分为二
    int midData=data[mid];
    if(midData==k){//中间恰好等于k，那么最后一个k的位置要么就是这个中间；要么位于后半段数组
        if((data[mid+1]!=k &amp;amp;&amp;amp; mid+1&amp;lt;length) || mid+1==length){
            return mid;
        }
        else
            start=mid+1;
    }
    else if(midData&amp;lt;k){
        start =mid+1;
    }
    else
        endd=mid-1;
    return GetLastK(data,length,k,start,endd);

}
int GetKNumbers(int *data,int length,int k){
    if(!data || length&amp;lt;=0)
        return -1;
    int number=0;
    int first=GetFirstK(data,length,k,0,length-1);
    int endd=GetLastK(data,length,k,0,length-1);
    if(first&amp;gt;-1 &amp;amp;&amp;amp; endd&amp;gt;-1)
        number= endd-first+1;
    return number;
}
int main()
{
    int data[]={1,2,3,3,3,3,4,5};
    cout&amp;lt;&amp;lt;GetKNumbers(data,8,1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//得到已经排序的数组中指定数字k出现的次数&lt;br&gt;//已经排好序，所以想到用二分查找算法；&lt;br&gt;//重复次数=最后一次出现的位置-第一次出现的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>两个链表的第一个公共节点</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/08/两个链表的第一个公共节点/</id>
    <published>2016-05-08T07:06:14.000Z</published>
    <updated>2016-05-08T07:06:54.040Z</updated>
    
    <content type="html">&lt;p&gt;//得到两个链表第一个公共节点并返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}

unsigned int GetListLength(ListNode* pHead);

int FindFirstCommonNode( ListNode *pHead1, ListNode *pHead2)
{
    // 得到两个链表的长度
    unsigned int nLength1 = GetListLength(pHead1);
    unsigned int nLength2 = GetListLength(pHead2);
    int nLengthDif = nLength1 - nLength2;

    ListNode* pListHeadLong = pHead1;
    ListNode* pListHeadShort = pHead2;
    if(nLength2 &amp;gt; nLength1)
    {
        pListHeadLong = pHead2;
        pListHeadShort = pHead1;
        nLengthDif = nLength2 - nLength1;
    }

    // 先在长链表上走几步，再同时在两个链表上遍历
    for(int i = 0; i &amp;lt; nLengthDif; ++ i)
        pListHeadLong = pListHeadLong-&amp;gt;m_pNext;

    while((pListHeadLong != NULL) &amp;amp;&amp;amp;
        (pListHeadShort != NULL) &amp;amp;&amp;amp;
        (pListHeadLong-&amp;gt;m_nValue != pListHeadShort-&amp;gt;m_nValue))
    {
        pListHeadLong = pListHeadLong-&amp;gt;m_pNext;
        pListHeadShort = pListHeadShort-&amp;gt;m_pNext;
    }
    if(!pListHeadLong &amp;amp;&amp;amp; !pListHeadShort)//没有公共节点

        return 0;
    if(pListHeadLong-&amp;gt;m_nValue == pListHeadShort-&amp;gt;m_nValue){
        ListNode* pFisrtCommonNode = pListHeadLong;// 得到第一个公共结点
        return pFisrtCommonNode-&amp;gt;m_nValue;
    }


}

unsigned int GetListLength(ListNode* pHead)
{
    unsigned int nLength = 0;
    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        ++ nLength;
        pNode = pNode-&amp;gt;m_pNext;
    }

    return nLength;
}

int main()
{
    List l1=NULL;
    Insert(l1,7);
    Insert(l1,6);
    Insert(l1,3);
    Insert(l1,2);
    Insert(l1,1);
    Print(l1);


    List l2=NULL;
    Insert(l2,7);
    Insert(l2,7);
    Insert(l2,5);
    Insert(l2,4);
    Print(l2);
    int tmp=FindFirstCommonNode(l1,l2);
    cout&amp;lt;&amp;lt;tmp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//得到两个链表第一个公共节点并返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef struct ListNode{
    int
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>逆序对</title>
    <link href="http://wxjttxs.github.io/2016/05/07/post%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/07/post逆序对/</id>
    <published>2016-05-07T09:00:04.000Z</published>
    <updated>2016-05-08T11:56:14.493Z</updated>
    
    <content type="html">&lt;p&gt;//一个数组中的元素构成的逆序对数目&lt;br&gt;//分治法，递归，类似于堆排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int InversePairsCore(int* data, int* cpy,int start, int endd){
    if(start==endd){
        cpy[start]=data[start];
        return 0;
    }
    int half_len=(endd-start)/2;
    int left=InversePairsCore(cpy,data,start,start+half_len);//子数组内部构成的逆序对,有两步操作：1是统计逆序对数目；2是排序（方便计算子数组间的逆序数数目）
    int right=InversePairsCore(cpy,data,start+half_len+1,endd);//注意前两个参数的顺序。第一个参数代表的是排好序的数组。

    int i=start+half_len;//子数组之间的逆序对,子数组是有序的
    int j=endd;
    int cpyIndex=endd;
    int countt=0;
    while(i&amp;gt;=start &amp;amp;&amp;amp; j&amp;gt;=start+half_len+1){
         if(data[i]&amp;gt;data[j]){
            cpy[cpyIndex--]=data[i--];//从右往左，从大往小放进辅助数组中
            countt+=j-start-half_len;//j代表的右边子数组中大的那个数字,所以它之前的数字均能与左边子数组构成逆序对
         }
         else{
            cpy[cpyIndex--]=data[j--];
         }
    }
    for(;i&amp;gt;=start;i--){//j到头了，终止退出循环
        cpy[cpyIndex--]=data[i];
    }
    for(;j&amp;gt;=start+half_len+1;j--)
        cpy[cpyIndex--]=data[j];
    return left+right+countt;
}
int InversePairs(int *data,int length){
    if(data==NULL||length&amp;lt;=0)
        return 0;
    int *cpy=new int [length];//辅助数组
    for(int i=0;i&amp;lt;length;i++){
        cpy[i]=data[i];
    }
    int countt=InversePairsCore(data,cpy,0,length-1);
    delete[] cpy;
    return countt;
}
int main()
{
    int a[]={7,5,6,4};
    cout &amp;lt;&amp;lt; InversePairs(a,4)&amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//一个数组中的元素构成的逆序对数目&lt;br&gt;//分治法，递归，类似于堆排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int InversePairsCore(int* data, int*
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="http://wxjttxs.github.io/2016/05/07/post%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/07/post第一个只出现一次的字符/</id>
    <published>2016-05-07T07:45:45.000Z</published>
    <updated>2016-05-07T09:00:45.903Z</updated>
    
    <content type="html">&lt;p&gt;//考察哈希表；字符串&lt;br&gt;//第一个只出现一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
char FirstNotReaptingChar(char* pString){
    if(!pString)
        return &amp;apos;\0&amp;apos;;
    const int tableSize=256;
    unsigned int hashTable[tableSize];
    for(int i=0;i&amp;lt;tableSize;i++)
        hashTable[i]=0;
    char* pHashKey=pString;//第一遍统计各个字符出现的次数，字符作为下标
    while(*pHashKey!=&amp;apos;\0&amp;apos;)
        hashTable[*(pHashKey++)]++;
    pHashKey=pString;//第二遍，从头开始找第一次只出现一遍的字符。
    while(*pHashKey!=&amp;apos;\0&amp;apos;){
        if(hashTable[*pHashKey]==1)
            return *pHashKey;
        pHashKey++;
    }
    return &amp;apos;\0&amp;apos;;

}
int main()
{
    cout &amp;lt;&amp;lt;FirstNotReaptingChar(&amp;quot;aaaccdeff&amp;quot;)&amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//考察哈希表；字符串&lt;br&gt;//第一个只出现一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
char FirstNotReaptingChar(char* pString){
    if
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组排成最小的数</title>
    <link href="http://wxjttxs.github.io/2016/05/06/%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/06/数组排成最小的数/</id>
    <published>2016-05-06T08:17:20.000Z</published>
    <updated>2016-05-06T08:26:51.458Z</updated>
    
    <content type="html">&lt;p&gt;//把数组中数字拼接起来，并打印最小的和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

// int型整数用十进制表示最多只有10位
const int g_MaxNumberLength=10;
char* g_StrCombine1=new char[g_MaxNumberLength*2+1];
char* g_StrCombine2=new char[g_MaxNumberLength*2+1];
// 如果[strNumber1][strNumber2] &amp;gt; [strNumber2][strNumber1], 返回值大于0
// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0
// 如果[strNumber1][strNumber2] &amp;lt; [strNumber2][strNumber1], 返回值小于0
int compare(const void* strNumber1,const void* strNumber2){//比较mn   VS nm
    strcpy(g_StrCombine1,*(const char**)strNumber1);
    strcat(g_StrCombine1,*(const char**)strNumber2);

    strcpy(g_StrCombine2,*(const char**)strNumber2);
    strcat(g_StrCombine2,*(const char**)strNumber1);
    return strcmp(g_StrCombine1,g_StrCombine2);
}
void PrintMinNumber(int *numbers,int length){
    if(numbers==NULL||length&amp;lt;0)
        return ;
    char** strNumbers=(char**)(new int[length]);
    for(int i=0;i&amp;lt;length;i++){
        strNumbers[i]=new char[g_MaxNumberLength+1];
        sprintf(strNumbers[i],&amp;quot;%d&amp;quot;,numbers[i]);
        //数值转换为字符串，比如numbers存储的是{3,32,321}，那么//strNumber存储的是{&amp;quot;3&amp;quot;,&amp;quot;32&amp;quot;,&amp;quot;321&amp;quot;}
    }
    qsort(strNumbers,length,sizeof(char*),compare);//对字符串数组进行排序，由小到大
    for(int i=0;i&amp;lt;length;i++)
        printf(&amp;quot;%s&amp;quot;,strNumbers[i]);
    printf(&amp;quot;\n&amp;quot;);
    for(int i=0;i&amp;lt;length;i++)
        delete[] strNumbers[i];
    delete[] strNumbers;
}
int main()
{
    int a[]={3,32,321};
    PrintMinNumber(a,3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//把数组中数字拼接起来，并打印最小的和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到第n个ugly number</title>
    <link href="http://wxjttxs.github.io/2016/05/06/%E6%89%BE%E5%88%B0%E7%AC%ACn%E4%B8%AAugly-number/"/>
    <id>http://wxjttxs.github.io/2016/05/06/找到第n个ugly-number/</id>
    <published>2016-05-06T08:15:23.000Z</published>
    <updated>2016-05-07T03:53:28.348Z</updated>
    
    <content type="html">&lt;p&gt;//因子只包含2,3,5的数叫做丑数,&lt;br&gt;//找到第n个丑数，1是第一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//***********************第一种方法***********************
//bool IsUglyNumber(int n){
//    while(n%2==0)
//        n/=2;
//    while(n%3==0)
//        n/=3;
//    while(n%5==0)
//        n/=5;
//    return (n==1)?true:false;
//}
//int GetUglyNumber(int index){
//    if(index&amp;lt;0)
//        return 0;
//    int number=0;
//    int uglyFound=0;
//    while(uglyFound&amp;lt;index){
//        ++number;
//        if(IsUglyNumber(number))
//            ++uglyFound;
//    }
//    return number;
//
//}
//**********************第二种方法***********************
//保存已经排好序的丑数
int Min(int n1,int n2,int n3){
    int mint=(n1&amp;lt;n2)?n1:n2;
    mint=(mint&amp;lt;n3)?mint:n3;
    return mint;
}
int GetUglyNumber(int index){
    if(index&amp;lt;0)
        return 0;
    int *pUglyNumbers=new int[index];
    pUglyNumbers[0]=1;//保存已经排好序的丑数
    int nextUglyIndex=1;//第i个丑数的位置
    int *pMultiplu2=pUglyNumbers;
    int *pMultiplu3=pUglyNumbers;
    int *pMultiplu5=pUglyNumbers;
    while(nextUglyIndex&amp;lt;index){
        int mintt=Min(*pMultiplu2*2,*pMultiplu3*3,*pMultiplu5*5);//取比当前最大丑数大的最小值
        pUglyNumbers[nextUglyIndex]=mintt;
        while(*pMultiplu2*2&amp;lt;=pUglyNumbers[nextUglyIndex])
            ++pMultiplu2;//这个位置之前的数乘2都比当前丑数的最大值要小;退出时候均比当前最大丑数大的最小值
        while(*pMultiplu3*3&amp;lt;=pUglyNumbers[nextUglyIndex])
            ++pMultiplu3;
        while(*pMultiplu5*5&amp;lt;=pUglyNumbers[nextUglyIndex])
            ++pMultiplu5;
        ++nextUglyIndex;

    }
    int ugly=pUglyNumbers[nextUglyIndex-1];
    delete[] pUglyNumbers;
    return ugly;

}
int main()
{
    cout &amp;lt;&amp;lt;GetUglyNumber(4) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//因子只包含2,3,5的数叫做丑数,&lt;br&gt;//找到第n个丑数，1是第一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//***********************第一种方法*****
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从1到N整数中1出现的次数</title>
    <link href="http://wxjttxs.github.io/2016/05/03/%E4%BB%8E1%E5%88%B0N%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/03/从1到N整数中1出现的次数/</id>
    <published>2016-05-03T11:31:40.000Z</published>
    <updated>2016-05-03T11:32:41.043Z</updated>
    
    <content type="html">&lt;p&gt;//给定数字N，计算从1~N中各个数字位上包含1的个位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//方法1，暴力穷举,一个数需要o(logn),一共需要n*O(logn)
int NumberOf1(unsigned int n){
    int number=0;
    while(n){//从个位往高位计算给定的数字n包含的数字1的个数
        if(n%10==1)
            number++;

        n=n/10;
    }
    return  number;
}
int NumberOf1Between1AndN(unsigned int n){
    int number=0;
    for(int i=1;i&amp;lt;=n;i++)
        number+=NumberOf1(i);
    return number;
}
//方法二，递归
//数字转换为 字符串更方便//递归一次去掉一位，所以时间复杂度编程O(logn)
int PowerBase10(unsigned int n){
    int result=1;
    for(unsigned int i=0;i&amp;lt;n;i++)
        result*=10;
    return result;
}
int NumberOf1(const char* strN){
    if(!strN||*strN&amp;lt;&amp;apos;0&amp;apos;||*strN&amp;gt;&amp;apos;9&amp;apos;||*strN==&amp;apos;\0&amp;apos;)
        return 0;
    int first=*strN-&amp;apos;0&amp;apos;;
    unsigned int length=static_cast&amp;lt;unsigned int&amp;gt;(strlen(strN));
    if(length==1&amp;amp;&amp;amp;first==0)
        return 0;
    if(length==1&amp;amp;&amp;amp; first&amp;gt;0)
        return 1;
    //假设strN=&amp;quot;21345&amp;quot;
    //numberFirstDigit是数字10000~19999的第一个位中的数目
    int numFirstDigit=0;
    if(first&amp;gt;1)
        numFirstDigit=PowerBase10(length-1);
    else if(first==1)
        numFirstDigit=atoi(strN+1)+1;
    //numberOtherDigits是1346~21346除第一位之外的数位中的数目
    int numOtherDigits=first*(length-1)*PowerBase10(length-2);
    //numRecursive是1~1345中的数目
    int numRecursive=NumberOf1(strN+1);
    return numFirstDigit+numOtherDigits+numRecursive;
}

int NumberOf1Between1AndN(int n){
    if(n&amp;lt;=0)
        return 0;
    char strN[50];
    sprintf(strN,&amp;quot;%d&amp;quot;,n);
    return NumberOf1(strN);
}

int main()
{
    cout&amp;lt;&amp;lt;NumberOf1Between1AndN(21345);
    //cout&amp;lt;&amp;lt;PowerBase10(2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//给定数字N，计算从1~N中各个数字位上包含1的个位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;cstring
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>子数组最大和</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://wxjttxs.github.io/2016/05/02/子数组最大和/</id>
    <published>2016-05-02T14:54:25.000Z</published>
    <updated>2016-05-02T14:56:39.653Z</updated>
    
    <content type="html">&lt;p&gt;//数组的最大子数组的和并返回&lt;br&gt;//动态规划分f(i)=pData[i] i=0 or f(i-1)&amp;lt;=0;&lt;br&gt;//f(i)=f(i-1)+pData[i]  i!=0 and f(i-)&amp;gt;0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
bool g_InvalidInput=false;//标记结果0到底是无效输入还是 最大和是0
int FindGreatestSumOfSubArray(int* pData,int nLength){
    if(pData==NULL||nLength&amp;lt;=0){
        g_InvalidInput=true;
        return 0;
    }
    g_InvalidInput=false;
    int nCurSum=0;
    int nGreatestSum=0x80000000;
    for(int i=0;i&amp;lt;nLength;i++){
        if(nCurSum&amp;lt;=0)
            nCurSum=pData[i];
        else
            nCurSum+=pData[i];
        if(nCurSum&amp;gt;nGreatestSum)
            nGreatestSum=nCurSum;
    }


return nGreatestSum;
}

int main()
{
    int a[]={1,-2,3,10,-4,7,2,-5};
    cout&amp;lt;&amp;lt;FindGreatestSumOfSubArray(a,8);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//数组的最大子数组的和并返回&lt;br&gt;//动态规划分f(i)=pData[i] i=0 or f(i-1)&amp;lt;=0;&lt;br&gt;//f(i)=f(i-1)+pData[i]  i!=0 and f(i-)&amp;gt;0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最小的K个数</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E2%80%9C%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%E2%80%9C/"/>
    <id>http://wxjttxs.github.io/2016/05/02/“最小的K个数“/</id>
    <published>2016-05-02T14:24:15.000Z</published>
    <updated>2016-05-02T14:25:53.110Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;vector&amp;gt;

using namespace std;
//0(n)时间找到最小的K个数，而且这K个数是排好序的，但是会修改原始数组
//借鉴快排的划分

//int Partition(int *a, int start ,int ent){
//    if(a==NULL||start&amp;lt;0||ent&amp;lt;0)
//        throw new exception();
//    int temp=a[ent];//最后一个值作为基准
//    int i=start-1;
//    for(int j=start;j&amp;lt;ent;j++){
//        if(a[j]&amp;lt;=temp){
//            i++;
//            swap(a[i],a[j]);
//        }
//    }
//    swap(a[i+1],a[ent]);
//    return i+1;
//}
//void GetLeastNumber(int *input,int n,int k){
//   // int output[k]={0};
//    if(input==NULL||n&amp;lt;=0||k&amp;lt;=0||k&amp;gt;n)
//        return;
//    int start=0;
//    int endt=n-1;
//    int index=Partition(input,start,endt);
//    while(index!=k-1){
//        if(index&amp;lt;k-1){
//            start=index+1;
//           index=Partition(input,start,endt);
//        }
//        else{
//            endt=index-1;
//            index=Partition(input,start,endt);
//        }
//    }
//    for(int i=0;i&amp;lt;=index;i++){
//
//        cout&amp;lt;&amp;lt;input[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
//    }
//    cout&amp;lt;&amp;lt;endl;
//
//}
//int main()
//{
//    int a[]={4,5,1,6,2,7,3,8};
//
//    GetLeastNumber(a,8,6);
//    return 0;
//}

//****************方法二********************************
//上面的时间很快，但是会改变原始数据
//所以用一个k大的容器 来装k个最小值，容器没有满那就直接插入。如果满了，那就做三件事：1.找到容器中最大值；2.删除最大值；3.插入新的数据
//找到最大值，最快的是最大堆，基于红黑树结构实现的set and multiset
typedef multiset&amp;lt;int,greater&amp;lt;int&amp;gt; &amp;gt; intSet;//greater作用实现降序排列
typedef multiset&amp;lt;int ,greater&amp;lt;int&amp;gt; &amp;gt;::iterator setItertor;
void GetLeastNumbers(const vector&amp;lt;int&amp;gt;&amp;amp; data, intSet&amp;amp; leastNumber,int k){
    leastNumber.clear();
    if(k&amp;lt;1||data.size()&amp;lt;k)
        return;
    vector&amp;lt;int&amp;gt;::const_iterator iter=data.begin();
    for(;iter!=data.end();++iter){

        if(leastNumber.size()&amp;lt;k)
            leastNumber.insert(*iter);
        else{
            setItertor iterGreatest=leastNumber.begin();
            if(*iter&amp;lt;*(leastNumber.begin())){
                leastNumber.erase(iterGreatest);
                leastNumber.insert(*iter);
            }
        }
    }
}
int main(){
    int a[8]={4,5,1,6,2,7,3,8};

    vector&amp;lt;int&amp;gt; data(a,a+8);
    intSet leastNumber;
    GetLeastNumbers(data,leastNumber,8);
    cout&amp;lt;&amp;lt;&amp;quot;the actual output numbers are:&amp;quot;&amp;lt;&amp;lt;endl;
    for(setItertor iter=leastNumber.begin();iter!=leastNumber.end();iter++)
        cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;vector&amp;gt;

using namespace std;
//0(n)时间找到最小
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E2%80%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97hexo-new-post-%E2%80%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/02/“数组中出现次数超过一半的数字hexo-new-post-“数组中出现次数超过一半的数字/</id>
    <published>2016-05-02T12:31:42.000Z</published>
    <updated>2016-05-02T12:32:25.888Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//是不是有效输入
bool IsValidMatrix(int * matrix,int length){
    if(matrix==NULL||length&amp;lt;=0)
        return false;
    return  true;
}
//如果出现次数最多的也不能达到数组长度的一半怎么办呢
bool IsMoreThanHalf(int* matrix,int length,int number){//number 是数组中出现次数最大的那个数
    int countt=0;
    for(int i=0;i&amp;lt;length;i++){
        if(matrix[i]==number)
            countt++;
    }
    if(countt*2&amp;lt;length)
        return false;
    return true;
}
int MoreThanHalfNum(int *matrix,int length){
    if(IsValidMatrix(matrix,length)){
        int MaxNumber=matrix[0];
        int times=1;
        for(int i=1;i&amp;lt;length;i++){//此后的数字相同的加1，不同的减1，直到times变成0，从下一个数字开始重头开始这个过程。
            if(times==0){
                MaxNumber=matrix[i];//重新开始  1,2,2
                times=1;
            }
           else if(MaxNumber==matrix[i])
                times++;
            else{

                times--;
            }
        }
        if(IsMoreThanHalf(matrix,length,MaxNumber)){

            return MaxNumber;
        }


        else
            cout&amp;lt;&amp;lt;&amp;quot;无效&amp;quot;;
    }

}
int main()
{
    int a[]={1};
    cout&amp;lt;&amp;lt;MoreThanHalfNum(a,1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//是不是有效输入
bool IsValidMatrix(int * matrix,int length){
    if(matrix==NULL||lengt
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串全排列(去重)以及全组合（2^n-1）</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/05/02/字符串全排列/</id>
    <published>2016-05-02T07:26:54.000Z</published>
    <updated>2016-05-02T11:43:51.677Z</updated>
    
    <content type="html">&lt;p&gt;//实现字符串每个字符 的全排列,并求取全排列的个数&lt;br&gt;//分为三部分：1.首先，求取所有可能出现在第一个位置的字符；&lt;br&gt;//2.其次，把第一个字符和其后面的字符一一交换；&lt;br&gt;//3.接着，固定第一个字符，求后面所有字符的排列。重复步骤2&lt;/p&gt;
&lt;p&gt;   //全排列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
//  调试开关
#define __tmain main

#ifdef __tmain

#define debug cout

#else

#define debug 0 &amp;amp;&amp;amp; cout

#endif // __tmain
class Solution{
protected:
    vector&amp;lt;string&amp;gt; m_res;//字符数组，存储排好序的字符串
public:
    void Permutation(string str){
        int countt=0;
        m_res.clear();
        if(str.empty())
            return ;

        Perm(str,0);

        sort(m_res.begin(),m_res.end());
        //删除容器中重复 元素
        vector&amp;lt;string&amp;gt;::iterator new_end;
        new_end=unique(m_res.begin(),m_res.end());//把重复元素放在容器末尾
        //assert(m_res.size()==N);
        m_res.erase(new_end,m_res.end());//真正删除重复元素
        //输出容器中元素
        vector&amp;lt;string&amp;gt;::iterator iter=m_res.begin();
        for(;iter!=m_res.end();iter++)
        {
            countt++;
            cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;endl;
        }
        cout&amp;lt;&amp;lt;endl;
        cout&amp;lt;&amp;lt;countt&amp;lt;&amp;lt;endl;
       // return m_res;

    }

    void Perm(string str,int Begin){//str要排序的字符串，Begin代表排序部分的第一个字符的位置
        if(str[Begin]==&amp;apos;\0&amp;apos;){//全部已经排好序
           // debug&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl;
            m_res.push_back(str);
        }
        for(int i=Begin;str[i]!=&amp;apos;\0&amp;apos;;i++){
            if(i==Begin||str[i]!=str[Begin]){//排除重复
                swap(str[i],str[Begin]);//排序部分第一个位置的字符全部找到
                Perm(str,Begin+1);//递归排序之后的字符
                swap(str[i],str[Begin]);

            }
        }
    }
};
int __tmain( )
{
    Solution solu;
    solu.Permutation(&amp;quot;abb&amp;quot;);

    return 0;
}


//********************************************************************
//组合。从n个字符中挑选m个字符放到组合当中。有两个方案：第一个字符放到组合当中，剩下的m-1个字符从n-1个字符中挑选，
//另一种方案：第一个字符不放到组合当中，那么从剩下的n-1中挑选m-1个字符放到组合当中
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
#include&amp;lt;assert.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;

void Combination(char *string ,int number,vector&amp;lt;char&amp;gt; &amp;amp;result);

void Combination(char *string)
{
    assert(string != NULL);
    vector&amp;lt;char&amp;gt; result;
    int i , length = strlen(string);
    for(i = 1 ; i &amp;lt;= length ; ++i)
        Combination(string , i ,result);
}

void Combination(char *string ,int number , vector&amp;lt;char&amp;gt; &amp;amp;result)
{
    assert(string != NULL);
    if(number == 0)
    {
        static int num = 1;
        printf(&amp;quot;第%d个组合\t&amp;quot;,num++);

        vector&amp;lt;char&amp;gt;::iterator iter = result.begin();
        for( ; iter != result.end() ; ++iter)
            printf(&amp;quot;%c&amp;quot;,*iter);
        printf(&amp;quot;\n&amp;quot;);
        return ;
    }
    if(*string == &amp;apos;\0&amp;apos;)
        return ;
    result.push_back(*string);
    Combination(string + 1 , number - 1 , result);
    result.pop_back();
    Combination(string + 1 , number , result);
}

int main(void)
{
    char str[] = &amp;quot;abc&amp;quot;;
    Combination(str);
    return 0;
}


//******************************************************************
//组合，位运算，没有解决重复问题,组合中出现这个字符，那么字符所在位置为1，否则为0.a:100,b:010...
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
void Combination(string str){
    int countt=0;
    if(str.empty())
        return;
    int len=str.size();
    for(int i=1;i&amp;lt;(1&amp;lt;&amp;lt;len);i++){//从0~2^n-1，中可能出现的情况
        for(int j=0;j&amp;lt;len;j++){
            if(i&amp;amp;(1&amp;lt;&amp;lt;j)){//这个位置上有数
                cout&amp;lt;&amp;lt;str[j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

            }
        }
        countt++;
        cout&amp;lt;&amp;lt;endl;

    }
    cout&amp;lt;&amp;lt;countt;
}
int main(){
    Combination(&amp;quot;abc&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   //&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;**&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;br&gt;   //八皇后问题。不同行，不同列，不同斜角线。&lt;/p&gt;
&lt;p&gt;#include&lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;
&lt;p&gt;#include&lt;stdio.h&gt;&lt;br&gt;using namespace std;&lt;br&gt;int count_number=0;&lt;br&gt;bool isDiagnal(int ColumnIndex[],int length){&lt;br&gt;    for(int i=0;i&amp;lt;length;i++){&lt;br&gt;        for(int j=i+1;j&amp;lt;length;j++){&lt;br&gt;            if(i-j==ColumnIndex[i]-ColumnIndex[j] || j-i==ColumnIndex[i]-ColumnIndex[j])//对角关系&lt;br&gt;                return false;&lt;br&gt;        }&lt;/stdio.h&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
return true;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;void Print(int ColumnIndex[],int length){&lt;br&gt;    cout&amp;lt;&amp;lt;count_number&amp;lt;&amp;lt;”:”;&lt;br&gt;    for(int  i=0;i&amp;lt;length;i++){&lt;br&gt;        cout&amp;lt;&amp;lt;ColumnIndex[i]&amp;lt;&amp;lt;” “;//输出列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
cout&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void Permutation(int ColumnIndex[],int length,int index){&lt;br&gt;    if(index==length){//index代表排列好的列&lt;br&gt;        if(isDiagnal(ColumnIndex,length)){//状态合法，没有斜对角关系&lt;br&gt;            count_number++;//一次符合要求的状态&lt;br&gt;            Print(ColumnIndex,length);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    else{&lt;br&gt;        for(int i=index;i&amp;lt;length;i++){&lt;br&gt;            swap(ColumnIndex[index],ColumnIndex[i]);//第一个位置可能的情况&lt;br&gt;            Permutation(ColumnIndex,length,index+1);//递归后面的部分分成第一个元素以及剩下的元素&lt;br&gt;            swap(ColumnIndex[index],ColumnIndex[i]);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;void EightQueen(){&lt;br&gt;    const int length=8;&lt;br&gt;    int ColumnIndex[length];&lt;br&gt;    for(int i=0;i&amp;lt;length;i++){&lt;br&gt;        ColumnIndex[i]=i;//下标表示行，值代表列&lt;br&gt;    }&lt;br&gt;    Permutation(ColumnIndex,length,0);&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;int main(void)&lt;br&gt;{&lt;br&gt;    EightQueen();&lt;br&gt;    return 0;&lt;br&gt;}&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//实现字符串每个字符 的全排列,并求取全排列的个数&lt;br&gt;//分为三部分：1.首先，求取所有可能出现在第一个位置的字符；&lt;br&gt;//2.其次，把第一个字符和其后面的字符一一交换；&lt;br&gt;//3.接着，固定第一个字符，求后面所有字符的排列。重复步骤2&lt;/p&gt;
&lt;p&gt;   /
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BST转换双向链表</title>
    <link href="http://wxjttxs.github.io/2016/05/02/BST%E8%BD%AC%E6%8D%A2%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://wxjttxs.github.io/2016/05/02/BST转换双向链表/</id>
    <published>2016-05-02T02:48:02.000Z</published>
    <updated>2016-05-02T07:28:46.433Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//实现二叉搜索树到双向链表的转换
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot){
    if(!pTreeRoot)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; que;
    que.push(pTreeRoot);
    while(que.size()){
        BinaryTreeNode* pNode=que.front();//指向队列的第一个元素，要被弹出的元素
        que.pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft)//打印节点的左右子节点
            que.push(pNode-&amp;gt;m_pLeft);
        if(pNode-&amp;gt;m_pRight)
            que.push(pNode-&amp;gt;m_pRight);
    }
}
void Print(BinaryTreeNode*  &amp;amp;pHead){
    if(pHead==NULL)
        return ;
    BinaryTreeNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pRight;
    }
    cout&amp;lt;&amp;lt;endl;
}
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void CovertNode(BinaryTreeNode* pNode,BinaryTreeNode** pLastNodeInList){
    if(pNode==NULL)
        return;
    BinaryTreeNode* pCurrent=pNode;
    if(pCurrent-&amp;gt;m_pLeft!=NULL)//转换左子树为排序的双向链表
        CovertNode(pCurrent-&amp;gt;m_pLeft,pLastNodeInList);
    pCurrent-&amp;gt;m_pLeft=*pLastNodeInList;//pCurrent指向根节点
    if(*pLastNodeInList!=NULL)
        (*pLastNodeInList)-&amp;gt;m_pRight=pCurrent;//连接上根节点
    *pLastNodeInList=pCurrent;//当前双向链表的最后一个几点就是根节点
    if(pCurrent-&amp;gt;m_pRight!=NULL)
        CovertNode(pCurrent-&amp;gt;m_pRight,pLastNodeInList);

}
BinaryTreeNode* Covert(BinaryTreeNode* pRootOfTree){
    BinaryTreeNode* pLastNodeInList=NULL;//双向链表为 空
    CovertNode(pRootOfTree,&amp;amp;pLastNodeInList);
    //pLastNodeInList指向双向链表的最后
    //我们需要返回最后结点
    BinaryTreeNode* pHeadOfList=pLastNodeInList;
    while(pHeadOfList!=NULL &amp;amp;&amp;amp; pHeadOfList-&amp;gt;m_pLeft!=NULL)//最后找到双向链表的头结点
        pHeadOfList=pHeadOfList-&amp;gt;m_pLeft;
    return pHeadOfList;
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,6,4,8,14,12,16};
    int inorder[]={4,6,8,10,12,14,16};
    Btree= Contrust(preorder,inorder,7);
    PrintFromTopToBottom(Btree);
    cout&amp;lt;&amp;lt;endl;

    BinaryTreeNode* L=Covert(Btree);

    Print(L);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//实现二叉搜索树到双向链表的转换
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
 
    
    </summary>
    
    
  </entry>
  
</feed>
