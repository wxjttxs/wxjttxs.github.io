<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happy happy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxjttxs.github.io/"/>
  <updated>2016-05-23T09:12:00.582Z</updated>
  <id>http://wxjttxs.github.io/</id>
  
  <author>
    <name>王晓静</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>横列坐标数位之和不大于K的可移动方格数目</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E6%A8%AA%E5%88%97%E5%9D%90%E6%A0%87%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C%E4%B8%8D%E5%A4%A7%E4%BA%8EK%E7%9A%84%E5%8F%AF%E7%A7%BB%E5%8A%A8%E6%96%B9%E6%A0%BC%E6%95%B0%E7%9B%AE/"/>
    <id>http://wxjttxs.github.io/2016/05/23/横列坐标数位之和不大于K的可移动方格数目/</id>
    <published>2016-05-23T09:10:42.000Z</published>
    <updated>2016-05-23T09:12:00.582Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//有一个m*N的方格，从（0，0）开始移动，每一次可以向上下左右移动一格，不能进入行列坐标的数位之和大于K的格子,机器人可以达到的最大格子数目?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//判断能否进入坐标（row,col），主要在于获得各个数位
int getDigitNum(int number){
    int sum=0;
    while(number&amp;gt;0){
        sum+=number%10;
        number/=10;
    }
    return sum;
}
bool check(int threshold,int rows, int cols,int row, int col,bool * visited){
    if(row&amp;gt;=0 &amp;amp;&amp;amp; row&amp;lt;rows &amp;amp;&amp;amp; col&amp;gt;=0 &amp;amp;&amp;amp; col&amp;lt;cols &amp;amp;&amp;amp; getDigitNum(row)+getDigitNum(col)&amp;lt;=threshold &amp;amp;&amp;amp;!visited[row*cols+col])
        return true;
    return false;
}
int movingCountCore(int threshold,int rows,int cols,int row,int col,bool* visited);
int movingCount(int threshold,int rows,int cols){
    bool* visited=new bool[rows*cols];
    for(int i=0;i&amp;lt;rows*cols;i++)
        visited[i]=false;

    int countt=movingCountCore(threshold,rows,cols,0,0,visited);
    delete[] visited;
    return countt;
}

int movingCountCore(int threshold,int rows,int cols,int row,int col,bool* visited){
    int countt=0;
    if(check(threshold,rows,cols,row,col,visited)){
        visited[row*cols+col]=true;

        countt=1+movingCountCore(threshold,rows,cols,row-1,col,visited)+
                movingCountCore(threshold,rows,cols,row,col-1,visited)+
                movingCountCore(threshold,rows,cols,row+1,col,visited)+
                movingCountCore(threshold,rows,cols,row,col+1,visited);

    }
    return countt;
}
// ================ test code============================
void test(char* testName, int threshold, int rows, int cols, int expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    if(movingCount(threshold, rows, cols) == expected)
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

void test1()
{
    test(&amp;quot;Test1&amp;quot;, 5, 10, 10, 21);
}

void test2()
{
    test(&amp;quot;Test2&amp;quot;, 15, 20, 20, 359);
}

void test3()
{
    test(&amp;quot;Test3&amp;quot;, 10, 1, 100, 29);
}

void test4()
{
    test(&amp;quot;Test4&amp;quot;, 10, 1, 10, 10);
}

void test5()
{
    test(&amp;quot;Test5&amp;quot;, 15, 100, 1, 79);
}

void test6()
{
    test(&amp;quot;Test6&amp;quot;, 15, 10, 1, 10);
}

void test7()
{
    test(&amp;quot;Test7&amp;quot;, 15, 1, 1, 1);
}

void test8()
{
    test(&amp;quot;Test8&amp;quot;, -10, 10, 10, 0);
}

int main(int agrc, char* argv[])
{
    test1();
    test2();
    test3();
    test4();
    test5();
    test6();
    test7();
    test8();
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//有一个m*N的方格，从（0，0）开始移动，每一次可以向上下左右移动一格，不能进入行列坐标的数位之和大于K的格子,机器人可以达到的最大格子数目?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>矩阵中的路径与字符串的匹配问题</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://wxjttxs.github.io/2016/05/23/矩阵中的路径与字符串的匹配问题/</id>
    <published>2016-05-23T08:52:35.000Z</published>
    <updated>2016-05-23T08:53:01.990Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//判断矩阵中是否存在一条包含某字符串所有字符的路径,路径不能重复进入矩阵的格子 //回溯法+栈&lt;br&gt;//在第N个字符的周围格子没有找到第N+1个字符，这个时候要回退到第N-1个字符，重新设定第N个字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
bool hasPathCore(char* matrix, int rows, int cols,int row,int col,char* str, int&amp;amp; pathLength, bool* visited);
bool hasPath(char* matrix, int rows, int cols, char* str){
    if(matrix==NULL || rows&amp;lt;1 || cols&amp;lt;1 ||str==NULL)
        return false;
    bool *visited=new bool[rows*cols];//标记这个格子是否走过
    memset(visited,0,rows*cols);

    int pathLength=0;
    for(int row=0;row&amp;lt;rows;++row){
        for(int col=0;col&amp;lt;cols;++col){
            if(hasPathCore(matrix,rows,cols,row,col,str,pathLength,visited))
                return true;
        }
    }
    delete[] visited;
    return false;
}
bool hasPathCore(char* matrix, int rows, int cols,int row,int col,char* str, int&amp;amp; pathLength, bool* visited){
    if(str[pathLength]==&amp;apos;\0&amp;apos;)//初始
        return true;
    bool hasPath=false;

    if(row&amp;gt;=0 &amp;amp;&amp;amp; row&amp;lt;rows &amp;amp;&amp;amp; col&amp;gt;=0 &amp;amp;&amp;amp; col&amp;lt;cols &amp;amp;&amp;amp; matrix[row*cols+col]==str[pathLength] &amp;amp;&amp;amp; !visited[row*cols+col]){//字符相等，没来过
        ++pathLength;
        visited[row*cols+col]=true;

        hasPath=hasPathCore(matrix,rows,cols,row,col-1,str,pathLength,visited)||//左
                hasPathCore(matrix,rows,cols,row-1,col,str,pathLength,visited)||//上
                hasPathCore(matrix,rows,cols,row,col+1,str,pathLength,visited)||//右
                hasPathCore(matrix,rows,cols,row+1,col,str,pathLength,visited);//下
        if(!hasPath){//这条路径不行

            --pathLength;
            visited[row*cols+col]=false;//回退到n-1
        }
    }
    return hasPath;
}

//**********************************test code*********************************
void Test(char* testName, char* matrix, int rows, int cols, char* str, bool expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    if(hasPath(matrix, rows, cols, str) == expected)
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

//ABCE
//SFCS
//ADEE

//ABCCED
void Test1()
{
    char matrix[] = &amp;quot;ABCESFCSADEE&amp;quot;;
    char* str = &amp;quot;ABCCED&amp;quot;;

    Test(&amp;quot;Test1&amp;quot;, (char*)matrix, 3, 4, str, true);
}

//ABCE
//SFCS
//ADEE

//SEE
void Test2()
{
    char matrix[] = &amp;quot;ABCESFCSADEE&amp;quot;;
    char* str = &amp;quot;SEE&amp;quot;;

    Test(&amp;quot;Test2&amp;quot;, (char*)matrix, 3, 4, str, true);
}

//ABCE
//SFCS
//ADEE

//ABCB
void Test3()
{
    char matrix[] = &amp;quot;ABCESFCSADEE&amp;quot;;
    char* str = &amp;quot;ABCB&amp;quot;;

    Test(&amp;quot;Test3&amp;quot;, (char*)matrix, 3, 4, str, false);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SLHECCEIDEJFGGFIE
void Test4()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SLHECCEIDEJFGGFIE&amp;quot;;

    Test(&amp;quot;Test4&amp;quot;, (char*)matrix, 5, 8, str, true);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SGGFIECVAASABCEHJIGQEM
void Test5()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SGGFIECVAASABCEHJIGQEM&amp;quot;;

    Test(&amp;quot;Test5&amp;quot;, (char*)matrix, 5, 8, str, true);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SGGFIECVAASABCEEJIGOEM
void Test6()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SGGFIECVAASABCEEJIGOEM&amp;quot;;

    Test(&amp;quot;Test6&amp;quot;, (char*)matrix, 5, 8, str, false);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SGGFIECVAASABCEHJIGQEMS
void Test7()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SGGFIECVAASABCEHJIGQEMS&amp;quot;;

    Test(&amp;quot;Test7&amp;quot;, (char*)matrix, 5, 8, str, false);
}

//AAAA
//AAAA
//AAAA

//AAAAAAAAAAAA
void Test8()
{
    char matrix[] = &amp;quot;AAAAAAAAAAAA&amp;quot;;
    char* str = &amp;quot;AAAAAAAAAAAA&amp;quot;;

    Test(&amp;quot;Test8&amp;quot;, (char*)matrix, 3, 4, str, true);
}

//AAAA
//AAAA
//AAAA

//AAAAAAAAAAAAA
void Test9()
{
    char matrix[] = &amp;quot;AAAAAAAAAAAA&amp;quot;;
    char* str = &amp;quot;AAAAAAAAAAAAA&amp;quot;;

    Test(&amp;quot;Test9&amp;quot;, (char*)matrix, 3, 4, str, false);
}

//A

//A
void Test10()
{
    char matrix[] = &amp;quot;A&amp;quot;;
    char* str = &amp;quot;A&amp;quot;;

    Test(&amp;quot;Test10&amp;quot;, (char*)matrix, 1, 1, str, true);
}

//A

//B
void Test11()
{
    char matrix[] = &amp;quot;A&amp;quot;;
    char* str = &amp;quot;B&amp;quot;;

    Test(&amp;quot;Test11&amp;quot;, (char*)matrix, 1, 1, str, false);
}

int main(int argc, char* argv[])
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    Test8();
    Test9();
    Test10();
    Test11();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//判断矩阵中是否存在一条包含某字符串所有字符的路径,路径不能重复进入矩阵的格子 //回溯法+栈&lt;br&gt;//在第N个字符的周围格子没有找到第N+1个字符，这个时候要回退到第N-1个字符，重新设定第N个字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://wxjttxs.github.io/2016/05/23/滑动窗口的最大值/</id>
    <published>2016-05-23T08:03:51.000Z</published>
    <updated>2016-05-23T08:04:19.405Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//给定一数组，找到指定滑动窗口中的最大值 //使用两端开口的队列deque&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;deque&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;

vector&amp;lt;int&amp;gt; maxInWindows(const vector&amp;lt;int&amp;gt;&amp;amp; numbers, unsigned int sizee){
    vector&amp;lt;int&amp;gt; maxInWindows;
    if(numbers.size()&amp;gt;=sizee &amp;amp;&amp;amp; sizee&amp;gt;=1){
        deque&amp;lt;int&amp;gt; index;//队列中的下标
        for(unsigned int i=0;i&amp;lt;sizee;i++){//滑动窗口没有填满
            while(!index.empty() &amp;amp;&amp;amp; numbers[i]&amp;gt;=numbers[index.back()])//已有的数据小于待存入的数据，那么它不可能是最大值，所以从队列尾部删除
                index.pop_back();
            index.push_back(i);
        }
        for(unsigned int i=sizee;i&amp;lt;numbers.size();++i){//
            maxInWindows.push_back(numbers[index.front()]);

            while(!index.empty() &amp;amp;&amp;amp; numbers[i]&amp;gt;=numbers[index.back()])//已有的数据小于待存入的数据，那么它不可能是最大值，所以从队列尾部删除
                index.pop_back();

            if(!index.empty() &amp;amp;&amp;amp; index.front()&amp;lt;=(int)(i-sizee))//滑出这个窗口，无论值多大，都从队列的头部删除
                index.pop_front();

            index.push_back(i);//插入新数据的下标，有可能成为最大值
        }
        maxInWindows.push_back(numbers[index.front()]);//index的首部front始终存放滑动窗口的最大值的下标
    }
    return maxInWindows;//滑动窗口的最大值

}

// ==================== Test Code ====================
void Test(char* testName, const vector&amp;lt;int&amp;gt;&amp;amp; num, unsigned int size, const vector&amp;lt;int&amp;gt;&amp;amp; expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    vector&amp;lt;int&amp;gt; result = maxInWindows(num, size);

    vector&amp;lt;int&amp;gt;::const_iterator iterResult = result.begin();
    vector&amp;lt;int&amp;gt;::const_iterator iterExpected = expected.begin();
    while(iterResult &amp;lt; result.end() &amp;amp;&amp;amp; iterExpected &amp;lt; expected.end())
    {
        if(*iterResult != *iterExpected)
            break;

        ++iterResult;
        ++iterExpected;
    }

    if(iterResult == result.end() &amp;amp;&amp;amp; iterExpected == expected.end())
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

void Test1()
{
    int num[] = {2, 3, 4, 2, 6, 2, 5, 1};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {4, 4, 6, 6, 6, 5};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 3;

    Test(&amp;quot;Test1&amp;quot;, vecNumbers, size, vecExpected);
}

void Test2()
{
    int num[] = {1, 3, -1, -3, 5, 3, 6, 7};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {3, 3, 5, 5, 6, 7};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 3;

    Test(&amp;quot;Test2&amp;quot;, vecNumbers, size, vecExpected);
}

// increasingly sorted
void Test3()
{
    int num[] = {1, 3, 5, 7, 9, 11, 13, 15};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {7, 9, 11, 13, 15};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 4;

    Test(&amp;quot;Test3&amp;quot;, vecNumbers, size, vecExpected);
}

// decreasingly sorted
void Test4()
{
    int num[] = {16, 14, 12, 10, 8, 6, 4};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {16, 14, 12};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 5;

    Test(&amp;quot;Test4&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is 1
void Test5()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 1;

    Test(&amp;quot;Test5&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is same as the array length
void Test6()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {14};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 4;

    Test(&amp;quot;Test6&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is 0
void Test7()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    vector&amp;lt;int&amp;gt; vecExpected;

    unsigned int size = 0;

    Test(&amp;quot;Test7&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is greater than the array length
void Test8()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    vector&amp;lt;int&amp;gt; vecExpected;

    unsigned int size = 5;

    Test(&amp;quot;Test8&amp;quot;, vecNumbers, size, vecExpected);
}

int main(int argc, char* argv[])
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    Test8();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//给定一数组，找到指定滑动窗口中的最大值 //使用两端开口的队列deque&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#inclu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉排序树的第K大节点</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/23/二叉排序树的第K大节点/</id>
    <published>2016-05-23T03:43:47.000Z</published>
    <updated>2016-05-23T03:44:35.379Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到二叉搜索树的第K大节点 //中序遍历 二叉搜索树，那它就是排序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
using namespace std;
BinaryTreeNode* KthNodeCore(BinaryTreeNode* pRoot,unsigned int &amp;amp;k){//根左右
    BinaryTreeNode* target=NULL;
    if(pRoot-&amp;gt;m_pLeft!=NULL)//在左子树
        target=KthNodeCore(pRoot-&amp;gt;m_pLeft,k);
    if(target==NULL){//不在左子树
        if(k==1)
            target=pRoot;
        k--;
    }
    if(target==NULL &amp;amp;&amp;amp; pRoot-&amp;gt;m_pRight!=NULL)
        target=KthNodeCore(pRoot-&amp;gt;m_pRight,k);
    return target;
}
BinaryTreeNode* KthNode(BinaryTreeNode* pRoot,unsigned int &amp;amp;k){
    if(pRoot==NULL || k==0)
        return NULL;
    return KthNodeCore(pRoot,k);
}
//**********************test code**************************
void Test(char* testName, BinaryTreeNode* pRoot, unsigned int k, bool isNull, int expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    BinaryTreeNode* pTarget = KthNode(pRoot, k);
    if((isNull &amp;amp;&amp;amp; pTarget == NULL) || (!isNull &amp;amp;&amp;amp; pTarget-&amp;gt;m_nValue == expected))
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

//            8
//        6      10
//       5 7    9  11
void TestA()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    Test(&amp;quot;TestA0&amp;quot;, pNode8, 0, true, -1);
    Test(&amp;quot;TestA1&amp;quot;, pNode8, 1, false, 5);
    Test(&amp;quot;TestA2&amp;quot;, pNode8, 2, false, 6);
    Test(&amp;quot;TestA3&amp;quot;, pNode8, 3, false, 7);
    Test(&amp;quot;TestA4&amp;quot;, pNode8, 4, false, 8);
    Test(&amp;quot;TestA5&amp;quot;, pNode8, 5, false, 9);
    Test(&amp;quot;TestA6&amp;quot;, pNode8, 6, false, 10);
    Test(&amp;quot;TestA7&amp;quot;, pNode8, 7, false, 11);
    Test(&amp;quot;TestA8&amp;quot;, pNode8, 8, true, -1);

    DestroyTree(pNode8);

    printf(&amp;quot;\n\n&amp;quot;);
}

//               5
//              /
//             4
//            /
//           3
//          /
//         2
//        /
//       1
void TestB()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);
    ConnectTreeNodes(pNode2, pNode1, NULL);

    Test(&amp;quot;TestB0&amp;quot;, pNode5, 0, true, -1);
    Test(&amp;quot;TestB1&amp;quot;, pNode5, 1, false, 1);
    Test(&amp;quot;TestB2&amp;quot;, pNode5, 2, false, 2);
    Test(&amp;quot;TestB3&amp;quot;, pNode5, 3, false, 3);
    Test(&amp;quot;TestB4&amp;quot;, pNode5, 4, false, 4);
    Test(&amp;quot;TestB5&amp;quot;, pNode5, 5, false, 5);
    Test(&amp;quot;TestB6&amp;quot;, pNode5, 6, true, -1);

    DestroyTree(pNode5);

    printf(&amp;quot;\n\n&amp;quot;);
}

// 1
//  \
//   2
//    \
//     3
//      \
//       4
//        \
//         5
void TestC()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, NULL, pNode2);
    ConnectTreeNodes(pNode2, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode5);

    Test(&amp;quot;TestC0&amp;quot;, pNode1, 0, true, -1);
    Test(&amp;quot;TestC1&amp;quot;, pNode1, 1, false, 1);
    Test(&amp;quot;TestC2&amp;quot;, pNode1, 2, false, 2);
    Test(&amp;quot;TestC3&amp;quot;, pNode1, 3, false, 3);
    Test(&amp;quot;TestC4&amp;quot;, pNode1, 4, false, 4);
    Test(&amp;quot;TestC5&amp;quot;, pNode1, 5, false, 5);
    Test(&amp;quot;TestC6&amp;quot;, pNode1, 6, true, -1);

    DestroyTree(pNode1);

    printf(&amp;quot;\n\n&amp;quot;);
}

// There is only one node in a tree
void TestD()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);

    Test(&amp;quot;TestD0&amp;quot;, pNode1, 0, true, -1);
    Test(&amp;quot;TestD1&amp;quot;, pNode1, 1, false, 1);
    Test(&amp;quot;TestD2&amp;quot;, pNode1, 2, true, -1);

    DestroyTree(pNode1);

    printf(&amp;quot;\n\n&amp;quot;);
}

// empty tree
void TestE()
{
    Test(&amp;quot;TestE0&amp;quot;, NULL, 0, true, -1);
    Test(&amp;quot;TestE1&amp;quot;, NULL, 1, true, -1);

    printf(&amp;quot;\n\n&amp;quot;);
}

int main()
{
   TestA();
    TestB();
    TestC();
    TestD();
    TestE();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到二叉搜索树的第K大节点 //中序遍历 二叉搜索树，那它就是排序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化和反序列化二叉树</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/23/序列化和反序列化二叉树/</id>
    <published>2016-05-23T03:28:44.000Z</published>
    <updated>2016-05-23T03:29:44.175Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//序列化以及反序列化二叉树
//从根节点开始序列化，就可以从根节点开始反序列化,前序遍历输出节点

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;fstream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

void Serialize(BinaryTreeNode* pRoot,ostream&amp;amp; stream){
    if(pRoot==NULL){
        stream&amp;lt;&amp;lt;&amp;quot;$,&amp;quot;;//没有节点或者叶子节点的左右子节点用这个符号代替

        return;
    }
    stream&amp;lt;&amp;lt;pRoot-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot;,&amp;quot;;
    Serialize(pRoot-&amp;gt;m_pLeft,stream);
    Serialize(pRoot-&amp;gt;m_pRight,stream);
}
bool ReadStream(istream&amp;amp; stream, int* number)
{
    if(stream.eof())//判断文件是否为空或者是否读到文件结尾,eof()函数返回true时是读到文件结束符0xFF，而文件结束符是最后一个字符的下一个字符
        return false;

    char buffer[32];
    buffer[0] = &amp;apos;\0&amp;apos;;

    char ch;
    stream &amp;gt;&amp;gt; ch;
    int i = 0;
    while(!stream.eof() &amp;amp;&amp;amp; ch != &amp;apos;,&amp;apos;)
    {
        buffer[i++] = ch;
        stream &amp;gt;&amp;gt; ch;
    }

    bool isNumeric = false;
    if(i &amp;gt; 0 &amp;amp;&amp;amp; buffer[0] != &amp;apos;$&amp;apos;)
    {
        *number = atoi(buffer);
        isNumeric = true;
    }

    return isNumeric;
}

void Deserialize(BinaryTreeNode** pRoot,istream&amp;amp; stream){
    int number;
    if(ReadStream(stream,&amp;amp;number)){
        *pRoot=new BinaryTreeNode();
        (*pRoot)-&amp;gt;m_nValue=number;
        (*pRoot)-&amp;gt;m_pLeft=NULL;
        (*pRoot)-&amp;gt;m_pRight=NULL;

        Deserialize(&amp;amp;((*pRoot)-&amp;gt;m_pLeft),stream);
        Deserialize(&amp;amp;((*pRoot)-&amp;gt;m_pRight),stream);
    }
}
// ==================== Test Code ====================
bool isSameTree(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    if(pRoot1 == NULL &amp;amp;&amp;amp; pRoot2 == NULL)
        return true;

    if(pRoot1 == NULL || pRoot2 == NULL)
        return false;

    if(pRoot1-&amp;gt;m_nValue != pRoot2-&amp;gt;m_nValue)
        return false;

    return isSameTree(pRoot1-&amp;gt;m_pLeft, pRoot2-&amp;gt;m_pLeft) &amp;amp;&amp;amp;
        isSameTree(pRoot1-&amp;gt;m_pRight, pRoot2-&amp;gt;m_pRight);
}

void Test(char* testName, BinaryTreeNode* pRoot)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: \n&amp;quot;, testName);

    PrintTree(pRoot);

    char* fileName = &amp;quot;test.txt&amp;quot;;
    ofstream fileOut;
    fileOut.open(fileName);

    Serialize(pRoot, fileOut);
    fileOut.close();

    // print the serialized file
    ifstream fileIn1;
    char ch;
    fileIn1.open(fileName);
    while(!fileIn1.eof())
    {
        fileIn1 &amp;gt;&amp;gt; ch;
        cout &amp;lt;&amp;lt; ch;
    }
    fileIn1.close();
    cout &amp;lt;&amp;lt; endl;

    ifstream fileIn2;
    fileIn2.open(fileName);
    BinaryTreeNode* pNewRoot = NULL;
    Deserialize(&amp;amp;pNewRoot, fileIn2);
    fileIn2.close();

    PrintTree(pNewRoot);

    if(isSameTree(pRoot, pNewRoot))
        printf(&amp;quot;The deserialized tree is same as the oritinal tree.\n\n&amp;quot;);
    else
        printf(&amp;quot;The deserialized tree is NOT same as the oritinal tree.\n\n&amp;quot;);

    DestroyTree(pNewRoot);
}

//            8
//        6      10
//       5 7    9  11
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    Test(&amp;quot;Test1&amp;quot;, pNode8);

    DestroyTree(pNode8);
}

//            5
//          4
//        3
//      2
void Test2()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);

    Test(&amp;quot;Test2&amp;quot;, pNode5);

    DestroyTree(pNode5);
}

//        5
//         4
//          3
//           2
void Test3()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode2);

    Test(&amp;quot;Test3&amp;quot;, pNode5);

    DestroyTree(pNode5);
}

void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    Test(&amp;quot;Test4&amp;quot;, pNode5);

    DestroyTree(pNode5);
}

void Test5()
{
    Test(&amp;quot;Test5&amp;quot;, NULL);
}

//        5
//         5
//          5
//         5
//        5
//       5 5
//      5   5
void Test6()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, NULL, pNode2);
    ConnectTreeNodes(pNode2, NULL, pNode3);
    ConnectTreeNodes(pNode3, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode5, NULL);
    ConnectTreeNodes(pNode5, pNode61, pNode62);
    ConnectTreeNodes(pNode61, pNode71, NULL);
    ConnectTreeNodes(pNode62, NULL, pNode72);

    Test(&amp;quot;Test6&amp;quot;, pNode1);

    DestroyTree(pNode1);
}
int main()
{
    Test1();
//    Test2();
//    Test3();
//    Test4();
//    Test5();
//    Test6();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//序列化以及反序列化二叉树
//从根节点开始序列化，就可以从根节点开始反序列化,前序遍历输出节点

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
#includ
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S型打印二叉树</title>
    <link href="http://wxjttxs.github.io/2016/05/23/S%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/23/S型打印二叉树/</id>
    <published>2016-05-23T02:30:04.000Z</published>
    <updated>2016-05-23T02:30:34.393Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//按照S型打印二叉树,分成奇偶行，奇数从左到右；偶数从右到左
//奇数层保存下一层的节点先保存左子节点，再保存右子节点；偶数层保存下一层节点相反。使用两个栈

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stack&amp;gt;

using namespace std;
void Print(BinaryTreeNode* pRoot){
    if(pRoot==NULL)
        return;

    stack&amp;lt;BinaryTreeNode*&amp;gt; levels[2];//存储 奇偶层的节点
    int current=0;
    int next=1;

    levels[current].push(pRoot);//存储奇数层
    while(!levels[0].empty() || !levels[1].empty()){//如果两个都为空，打印完了
        BinaryTreeNode* pNode=levels[current].top();
        levels[current].pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

        if(current==0){//奇数层，存储下一层节点先左再右
            if(pNode-&amp;gt;m_pLeft!=NULL)
                levels[next].push(pNode-&amp;gt;m_pLeft);
            if(pNode-&amp;gt;m_pRight!=NULL)
                levels[next].push(pNode-&amp;gt;m_pRight);
        }
        else{//ou数层，存储下一层节点先右再左
            if(pNode-&amp;gt;m_pRight!=NULL)
                levels[next].push(pNode-&amp;gt;m_pRight);
            if(pNode-&amp;gt;m_pLeft!=NULL)
                levels[next].push(pNode-&amp;gt;m_pLeft);
        }
        if(levels[current].empty()){//一层的节点都打印玩了，交换两个栈，并继续打印下一层。
            cout&amp;lt;&amp;lt;endl;
            current=1-current;
            next=1-next;
        }

    }

}


//            8
//        6      10
//       5 7    9  11
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    printf(&amp;quot;====Test1 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;8 \n&amp;quot;);
    printf(&amp;quot;10 6 \n&amp;quot;);
    printf(&amp;quot;5 7 9 11 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode8);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode8);
}

//            5
//          4
//        3
//      2
void Test2()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);

    printf(&amp;quot;====Test2 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

//        5
//         4
//          3
//           2
void Test3()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode2);

    printf(&amp;quot;====Test3 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    printf(&amp;quot;====Test4 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test5()
{
    printf(&amp;quot;====Test5 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(NULL);
    printf(&amp;quot;\n&amp;quot;);
}

//        100
//        /
//       50
//         \
//         150
void Test6()
{
    BinaryTreeNode* pNode100 = CreateBinaryTreeNode(100);
    BinaryTreeNode* pNode50 = CreateBinaryTreeNode(50);
    BinaryTreeNode* pNode150 = CreateBinaryTreeNode(150);

    ConnectTreeNodes(pNode100, pNode50, NULL);
    ConnectTreeNodes(pNode50, NULL, pNode150);

    printf(&amp;quot;====Test6 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;100 \n&amp;quot;);
    printf(&amp;quot;50 \n&amp;quot;);
    printf(&amp;quot;150 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode100);
    printf(&amp;quot;\n&amp;quot;);
}

//                8
//        4              12
//     2     6       10      14
//   1  3  5  7     9 11   13  15
void Test7()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(12);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode14 = CreateBinaryTreeNode(14);
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);
    BinaryTreeNode* pNode13 = CreateBinaryTreeNode(13);
    BinaryTreeNode* pNode15 = CreateBinaryTreeNode(15);

    ConnectTreeNodes(pNode8, pNode4, pNode12);
    ConnectTreeNodes(pNode4, pNode2, pNode6);
    ConnectTreeNodes(pNode12, pNode10, pNode14);
    ConnectTreeNodes(pNode2, pNode1, pNode3);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);
    ConnectTreeNodes(pNode14, pNode13, pNode15);

    printf(&amp;quot;====Test7 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;8 \n&amp;quot;);
    printf(&amp;quot;12 4 \n&amp;quot;);
    printf(&amp;quot;2 6 10 14 \n&amp;quot;);
    printf(&amp;quot;15 13 11 9 7 5 3 1 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode8);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode8);
}

int main()
{

    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//按照S型打印二叉树,分成奇偶行，奇数从左到右；偶数从右到左
//奇数层保存下一层的节点先保存左子节点，再保存右子节点；偶数层保存下一层节点相反。使用两个栈

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../commo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按行打印二叉树</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E6%8C%89%E8%A1%8C%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/23/按行打印二叉树/</id>
    <published>2016-05-23T01:50:12.000Z</published>
    <updated>2016-05-23T01:50:50.717Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//按行打印二叉树 //一个变量表示当前层还没有打印的节点数，另一个变量表示下一层节点的数目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include &amp;quot;../common/ConstructBST.h&amp;quot;
using namespace std;
//按行打印二叉树
void Print(BinaryTreeNode* pRoot){
    if(pRoot==NULL)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; nodes;
    nodes.push(pRoot);
    int nextLevel=0;//下一层的节点数目
    int toBePrinted=1;//当前层剩下的节点数

    while(!nodes.empty()){
        BinaryTreeNode* pNode=nodes.front();

        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft!=NULL){
            nodes.push(pNode-&amp;gt;m_pLeft);
            ++nextLevel;

        }
        if(pNode-&amp;gt;m_pRight!=NULL){
            nodes.push(pNode-&amp;gt;m_pRight);
            ++nextLevel;
        }
        nodes.pop();//弹出节点
        --toBePrinted;//第一个层打印完了
        if(toBePrinted==0){
            cout&amp;lt;&amp;lt;endl;
            toBePrinted=nextLevel;
            nextLevel=0;
        }


    }
}
// ==================== Test Code ====================
//            8
//        6      10
//       5 7    9  11
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    printf(&amp;quot;====Test1 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;8 \n&amp;quot;);
    printf(&amp;quot;6 10 \n&amp;quot;);
    printf(&amp;quot;5 7 9 11 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode8);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode8);
}

//            5
//          4
//        3
//      2
void Test2()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);

    printf(&amp;quot;====Test2 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

//        5
//         4
//          3
//           2
void Test3()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode2);

    printf(&amp;quot;====Test3 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    printf(&amp;quot;====Test4 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test5()
{
    printf(&amp;quot;====Test5 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(NULL);
    printf(&amp;quot;\n&amp;quot;);
}

//        100
//        /
//       50
//         \
//         150
void Test6()
{
    BinaryTreeNode* pNode100 = CreateBinaryTreeNode(100);
    BinaryTreeNode* pNode50 = CreateBinaryTreeNode(50);
    BinaryTreeNode* pNode150 = CreateBinaryTreeNode(150);

    ConnectTreeNodes(pNode100, pNode50, NULL);
    ConnectTreeNodes(pNode50, NULL, pNode150);

    printf(&amp;quot;====Test6 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;100 \n&amp;quot;);
    printf(&amp;quot;50 \n&amp;quot;);
    printf(&amp;quot;150 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode100);
    printf(&amp;quot;\n&amp;quot;);
}

int main()
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//按行打印二叉树 //一个变量表示当前层还没有打印的节点数，另一个变量表示下一层节点的数目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树是否对称</title>
    <link href="http://wxjttxs.github.io/2016/05/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/22/二叉树是否对称/</id>
    <published>2016-05-22T14:32:13.000Z</published>
    <updated>2016-05-22T14:32:47.734Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//判断一棵二叉树是不是对称的 //充要条件：如果二叉树是对称的，那么它的前序遍历序列和这颗二叉树的对称二叉树的前序遍历序列是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//**********************二叉树是否对称************************
bool isSymmetrical(BinaryTreeNode* pRoot1,BinaryTreeNode* pRoot2){
    if(pRoot1==NULL &amp;amp;&amp;amp; pRoot2==NULL)
        return true;
    if(pRoot1==NULL || pRoot2==NULL)
        return false;
    if(pRoot1-&amp;gt;m_nValue!=pRoot2-&amp;gt;m_nValue)
        return false;

    return isSymmetrical(pRoot1-&amp;gt;m_pLeft,pRoot2-&amp;gt;m_pRight)&amp;amp;&amp;amp;isSymmetrical(pRoot1-&amp;gt;m_pRight,pRoot2-&amp;gt;m_pLeft);
}
bool isSymmetrical(BinaryTreeNode* pRoot){
   return  isSymmetrical(pRoot,pRoot);
}
//************************构造二叉树*************************
BinaryTreeNode* CreateBinaryTreeNode(int value)
{
    BinaryTreeNode* pNode = new BinaryTreeNode();
    pNode-&amp;gt;m_nValue = value;
    pNode-&amp;gt;m_pLeft = NULL;
    pNode-&amp;gt;m_pRight = NULL;

    return pNode;
}

void ConnectTreeNodes(BinaryTreeNode* pParent, BinaryTreeNode* pLeft, BinaryTreeNode* pRight)
{
    if(pParent != NULL)
    {
        pParent-&amp;gt;m_pLeft = pLeft;
        pParent-&amp;gt;m_pRight = pRight;
    }
}

void PrintTreeNode(BinaryTreeNode* pNode)
{
    if(pNode != NULL)
    {
        printf(&amp;quot;value of this node is: %d\n&amp;quot;, pNode-&amp;gt;m_nValue);

        if(pNode-&amp;gt;m_pLeft != NULL)
            printf(&amp;quot;value of its left child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pLeft-&amp;gt;m_nValue);
        else
            printf(&amp;quot;left child is null.\n&amp;quot;);

        if(pNode-&amp;gt;m_pRight != NULL)
            printf(&amp;quot;value of its right child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pRight-&amp;gt;m_nValue);
        else
            printf(&amp;quot;right child is null.\n&amp;quot;);
    }
    else
    {
        printf(&amp;quot;this node is null.\n&amp;quot;);
    }

    printf(&amp;quot;\n&amp;quot;);
}

void PrintTree(BinaryTreeNode* pRoot)
{
    PrintTreeNode(pRoot);

    if(pRoot != NULL)
    {
        if(pRoot-&amp;gt;m_pLeft != NULL)
            PrintTree(pRoot-&amp;gt;m_pLeft);

        if(pRoot-&amp;gt;m_pRight != NULL)
            PrintTree(pRoot-&amp;gt;m_pRight);
    }
}
void DestroyTree(BinaryTreeNode* pRoot)
{
    if(pRoot != NULL)
    {
        BinaryTreeNode* pLeft = pRoot-&amp;gt;m_pLeft;
        BinaryTreeNode* pRight = pRoot-&amp;gt;m_pRight;

        delete pRoot;
        pRoot = NULL;

        DestroyTree(pLeft);
        DestroyTree(pRight);
    }
}
//学习大牛的测试写法
// ==================== Test Code ====================
void Test(char* testName, BinaryTreeNode* pRoot, bool expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    if(isSymmetrical(pRoot) == expected)
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

//            8
//        6      6
//       5 7    7 5
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode8, pNode61, pNode62);
    ConnectTreeNodes(pNode61, pNode51, pNode71);
    ConnectTreeNodes(pNode62, pNode72, pNode52);

    Test(&amp;quot;Test1&amp;quot;, pNode8, true);

    DestroyTree(pNode8);
}

//            8
//        6      9
//       5 7    7 5
void Test2()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode8, pNode61, pNode9);
    ConnectTreeNodes(pNode61, pNode51, pNode71);
    ConnectTreeNodes(pNode9, pNode72, pNode52);

    Test(&amp;quot;Test2&amp;quot;, pNode8, false);

    DestroyTree(pNode8);
}

//            8
//        6      6
//       5 7    7
void Test3()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);

    ConnectTreeNodes(pNode8, pNode61, pNode62);
    ConnectTreeNodes(pNode61, pNode51, pNode71);
    ConnectTreeNodes(pNode62, pNode72, NULL);

    Test(&amp;quot;Test3&amp;quot;, pNode8, false);

    DestroyTree(pNode8);
}

//               5
//              / \
//             3   3
//            /     \
//           4       4
//          /         \
//         2           2
//        /             \
//       1               1
void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode31, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, pNode21, NULL);
    ConnectTreeNodes(pNode42, NULL, pNode22);
    ConnectTreeNodes(pNode21, pNode11, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode12);

    Test(&amp;quot;Test4&amp;quot;, pNode5, true);

    DestroyTree(pNode5);
}


//               5
//              / \
//             3   3
//            /     \
//           4       4
//          /         \
//         6           2
//        /             \
//       1               1
void Test5()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode31, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, pNode6, NULL);
    ConnectTreeNodes(pNode42, NULL, pNode22);
    ConnectTreeNodes(pNode6, pNode11, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode12);

    Test(&amp;quot;Test5&amp;quot;, pNode5, false);

    DestroyTree(pNode5);
}

//               5
//              / \
//             3   3
//            /     \
//           4       4
//          /         \
//         2           2
//                      \
//                       1
void Test6()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode31, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, pNode21, NULL);
    ConnectTreeNodes(pNode42, NULL, pNode22);
    ConnectTreeNodes(pNode21, NULL, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode12);

    Test(&amp;quot;Test6&amp;quot;, pNode5, false);

    DestroyTree(pNode5);
}

// Only one node
void Test7()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);
    Test(&amp;quot;Test7&amp;quot;, pNode1, true);

    DestroyTree(pNode1);
}

// No nodes
void Test8()
{
    Test(&amp;quot;Test8&amp;quot;, NULL, true);
}

// All nodes have the same value
//               5
//              / \
//             5   5
//            /     \
//           5       5
//          /         \
//         5           5
void Test9()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, pNode21, pNode22);
    ConnectTreeNodes(pNode21, pNode31, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, NULL, NULL);
    ConnectTreeNodes(pNode42, NULL, NULL);

    Test(&amp;quot;Test9&amp;quot;, pNode1, true);

    DestroyTree(pNode1);
}

// All nodes have the same value
//               5
//              / \
//             5   5
//            /     \
//           5       5
//          /       /
//         5       5
void Test10()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, pNode21, pNode22);
    ConnectTreeNodes(pNode21, pNode31, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, pNode42, NULL);
    ConnectTreeNodes(pNode41, NULL, NULL);
    ConnectTreeNodes(pNode42, NULL, NULL);

    Test(&amp;quot;Test10&amp;quot;, pNode1, false);

    DestroyTree(pNode1);
}
int main()
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    Test8();
    Test9();
    Test10();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//判断一棵二叉树是不是对称的 //充要条件：如果二叉树是对称的，那么它的前序遍历序列和这颗二叉树的对称二叉树的前序遍历序列是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的下一个节点</title>
    <link href="http://wxjttxs.github.io/2016/05/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/22/二叉树的下一个节点/</id>
    <published>2016-05-22T06:29:50.000Z</published>
    <updated>2016-05-22T13:57:03.991Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找出二叉树中序遍历的下一个节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
struct BinaryTreeNode
{
    int                    m_nValue;
    BinaryTreeNode*        m_pLeft;
    BinaryTreeNode*        m_pRight;
    BinaryTreeNode*        m_pParent;
};

BinaryTreeNode* CreateBinaryTreeNode(int value)
{
    BinaryTreeNode* pNode = new BinaryTreeNode();
    pNode-&amp;gt;m_nValue = value;
    pNode-&amp;gt;m_pLeft = NULL;
    pNode-&amp;gt;m_pRight = NULL;
    pNode-&amp;gt;m_pParent = NULL;

    return pNode;
}

void ConnectTreeNodes(BinaryTreeNode* pParent, BinaryTreeNode* pLeft, BinaryTreeNode* pRight)
{
    if(pParent != NULL)
    {
        pParent-&amp;gt;m_pLeft = pLeft;
        pParent-&amp;gt;m_pRight = pRight;

        if(pLeft != NULL)
            pLeft-&amp;gt;m_pParent = pParent;
        if(pRight != NULL)
            pRight-&amp;gt;m_pParent = pParent;
    }
}

void PrintTreeNode(BinaryTreeNode* pNode)
{
    if(pNode != NULL)
    {
        printf(&amp;quot;value of this node is: %d\n&amp;quot;, pNode-&amp;gt;m_nValue);

        if(pNode-&amp;gt;m_pLeft != NULL)
            printf(&amp;quot;value of its left child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pLeft-&amp;gt;m_nValue);
        else
            printf(&amp;quot;left child is null.\n&amp;quot;);

        if(pNode-&amp;gt;m_pRight != NULL)
            printf(&amp;quot;value of its right child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pRight-&amp;gt;m_nValue);
        else
            printf(&amp;quot;right child is null.\n&amp;quot;);
    }
    else
    {
        printf(&amp;quot;this node is null.\n&amp;quot;);
    }

    printf(&amp;quot;\n&amp;quot;);
}

void PrintTree(BinaryTreeNode* pRoot)
{
    PrintTreeNode(pRoot);

    if(pRoot != NULL)
    {
        if(pRoot-&amp;gt;m_pLeft != NULL)
            PrintTree(pRoot-&amp;gt;m_pLeft);

        if(pRoot-&amp;gt;m_pRight != NULL)
            PrintTree(pRoot-&amp;gt;m_pRight);
    }
}
BinaryTreeNode* GetNext(BinaryTreeNode* pNode){
    if(pNode==NULL)
        return NULL;
    BinaryTreeNode* pNext=NULL;
    if(pNode-&amp;gt;m_pRight!=NULL){//一个节点的右子树存在，那么它的下一个节点就是右子树的最左子节点
        BinaryTreeNode* pRight=pNode-&amp;gt;m_pRight;
        while(pRight-&amp;gt;m_pLeft!=NULL)
            pRight=pRight-&amp;gt;m_pLeft;

        pNext=pRight;

    }
    else if(pNode-&amp;gt;m_pParent!=NULL){//等价于下面的功能
        BinaryTreeNode* pCurrent=pNode;
        BinaryTreeNode* pParent=pNode-&amp;gt;m_pParent;
        while(pParent!=NULL &amp;amp;&amp;amp; pCurrent==pParent-&amp;gt;m_pRight){
            pCurrent=pParent;
            pParent=pParent-&amp;gt;m_pParent;
        }
        pNext=pParent;
    }
//    BinaryTreeNode* pParent=pNode-&amp;gt;m_pParent;
//    if(pNode-&amp;gt;m_pRight==NULL &amp;amp;&amp;amp; pParent-&amp;gt;m_pLeft==pNode){//这个节点没有右子树，并且是其父节点的左节点，那么它的下一个节点是其父节点，
//        pNext=pParent;
//    }
//    else if(pNode-&amp;gt;m_pRight==NULL &amp;amp;&amp;amp; pParent-&amp;gt;m_pRight==pNode){//这个节点没有右子树，且是父节点的右子节点，比较复杂
//找到第一个该节点的祖先节点是目标节点的左子节点，这个目标节点就是它的下一个节点
//         BinaryTreeNode* pCurrent=pNode;
//        BinaryTreeNode* pParent=pNode-&amp;gt;m_pParent;
//        while( pCurrent==pParent-&amp;gt;m_pRight){
//            pCurrent=pParent;
//            pParent=pParent-&amp;gt;m_pParent;
//        }
//        pNext=pParent;
//    }
    return pNext;
}

int main()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    BinaryTreeNode* p=GetNext(pNode10);


    cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找出二叉树中序遍历的下一个节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
struct
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>删除链表中重复的节点</title>
    <link href="http://wxjttxs.github.io/2016/05/21/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/21/删除链表中重复的节点/</id>
    <published>2016-05-21T14:39:33.000Z</published>
    <updated>2016-05-21T14:40:06.728Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//删除排序链表中重复的节点 //注意如果头结点是重复的，那么删除节点之后防止链表散掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;iostream&amp;gt;
    #include&amp;lt;stdio.h&amp;gt;
    #include&amp;lt;stdlib.h&amp;gt;
    using namespace std;
    //构建链表，显示链表
    struct ListNode
    {
        int       m_nValue;
        ListNode* m_pNext;
    };

    ListNode* CreateListNode(int value);
    void ConnectListNodes(ListNode* pCurrent, ListNode* pNext);
    void PrintListNode(ListNode* pNode);
    void PrintList(ListNode* pHead);
    void DestroyList(ListNode* pHead);
    void AddToTail(ListNode** pHead, int value);

    ListNode* CreateListNode(int value)
    {
        ListNode* pNode = new ListNode();
        pNode-&amp;gt;m_nValue = value;
        pNode-&amp;gt;m_pNext = NULL;

        return pNode;
    }

    void ConnectListNodes(ListNode* pCurrent, ListNode* pNext)
    {
        if(pCurrent == NULL)
        {
            printf(&amp;quot;Error to connect two nodes.\n&amp;quot;);
            exit(1);
        }

        pCurrent-&amp;gt;m_pNext = pNext;
    }

    void PrintListNode(ListNode* pNode)
    {
        if(pNode == NULL)
        {
            printf(&amp;quot;The node is NULL\n&amp;quot;);
        }
        else
        {
            printf(&amp;quot;The key in node is %d.\n&amp;quot;, pNode-&amp;gt;m_nValue);
        }
    }

    void PrintList(ListNode* pHead)
    {
        printf(&amp;quot;PrintList starts.\n&amp;quot;);

        ListNode* pNode = pHead;
        while(pNode != NULL)
        {
            printf(&amp;quot;%d\t&amp;quot;, pNode-&amp;gt;m_nValue);
            pNode = pNode-&amp;gt;m_pNext;
        }

        printf(&amp;quot;\nPrintList ends.\n&amp;quot;);
    }

    void DestroyList(ListNode* pHead)
    {
        ListNode* pNode = pHead;
        while(pNode != NULL)
        {
            pHead = pHead-&amp;gt;m_pNext;
            delete pNode;
            pNode = pHead;
        }
    }

    void AddToTail(ListNode** pHead, int value)
    {
        ListNode* pNew = new ListNode();
        pNew-&amp;gt;m_nValue = value;
        pNew-&amp;gt;m_pNext = NULL;

        if(*pHead == NULL)
        {
            *pHead = pNew;
        }
        else
        {
            ListNode* pNode = *pHead;
            while(pNode-&amp;gt;m_pNext != NULL)
                pNode = pNode-&amp;gt;m_pNext;

            pNode-&amp;gt;m_pNext = pNew;
        }
    }
//删除重复节点
void deleteDuplication(ListNode** pHead){//头结点也有可能被删除**
    if(pHead==NULL || *pHead==NULL)
        return;
    ListNode* pPreNode=NULL;
    ListNode* pNode=*pHead;
    while(pNode!=NULL){
        ListNode* pNext=pNode-&amp;gt;m_pNext;
        bool needDeleted=false;

        if(pNext!=NULL &amp;amp;&amp;amp; pNext-&amp;gt;m_nValue==pNode-&amp;gt;m_nValue)//重复
            needDeleted=true;

        if(!needDeleted){
            pPreNode=pNode;
            pNode=pNode-&amp;gt;m_pNext;//继续往后找有没有重复的
        }
        else{
            int value=pNode-&amp;gt;m_nValue;
            ListNode* pToBeDel=pNode;

            while(pToBeDel!=NULL &amp;amp;&amp;amp; pToBeDel-&amp;gt;m_nValue==value){
                pNext=pToBeDel-&amp;gt;m_pNext;

                delete pToBeDel;
                pToBeDel=NULL;

                pToBeDel=pNext;
            }
            if(pPreNode==NULL)//头结点重复了
                *pHead=pNext;
            else
                pPreNode-&amp;gt;m_pNext=pNext;
            pNode=pNext;//继续下一个判断
        }
    }

}
int main()
{
//构建链表

    ListNode* pNode1 = CreateListNode(1);
    ListNode* pNode2 = CreateListNode(2);
    ListNode* pNode3 = CreateListNode(3);
    ListNode* pNode4 = CreateListNode(3);
    ListNode* pNode5 = CreateListNode(5);
    ListNode* pNode6 = CreateListNode(6);

    ConnectListNodes(pNode1, pNode2);
    ConnectListNodes(pNode2, pNode3);
    ConnectListNodes(pNode3, pNode4);
    ConnectListNodes(pNode4, pNode5);
    ConnectListNodes(pNode5, pNode6);

    ListNode* pHead=pNode1;
    deleteDuplication(&amp;amp;pHead);
    PrintList(pHead);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//删除排序链表中重复的节点 //注意如果头结点是重复的，那么删除节点之后防止链表散掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;iostream&amp;gt;
    #include&amp;lt;stdio.h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到带有环的链表的入口</title>
    <link href="http://wxjttxs.github.io/2016/05/21/%E6%89%BE%E5%88%B0%E5%B8%A6%E6%9C%89%E7%8E%AF%E7%9A%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3/"/>
    <id>http://wxjttxs.github.io/2016/05/21/找到带有环的链表的入口/</id>
    <published>2016-05-21T13:39:36.000Z</published>
    <updated>2016-05-21T14:16:37.794Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到链表中环的入口节点 //如果环有n个节点，那么指针p1先向前走n步，然后p1,p2一起往前走，直到相遇,相遇的节点就是入口节点&lt;br&gt;//接下来求环的节点个数：用快慢指针，如果相遇，必存在环，然后记下这个位置，再向前一边移动一边计数，当再次回到这个节点，就求出这个huan的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
using namespace std;
//构建链表，显示链表
struct ListNode
{
    int       m_nValue;
    ListNode* m_pNext;
};

ListNode* CreateListNode(int value);
void ConnectListNodes(ListNode* pCurrent, ListNode* pNext);
void PrintListNode(ListNode* pNode);
void PrintList(ListNode* pHead);
void DestroyList(ListNode* pHead);
void AddToTail(ListNode** pHead, int value);

ListNode* CreateListNode(int value)
{
    ListNode* pNode = new ListNode();
    pNode-&amp;gt;m_nValue = value;
    pNode-&amp;gt;m_pNext = NULL;

    return pNode;
}

void ConnectListNodes(ListNode* pCurrent, ListNode* pNext)
{
    if(pCurrent == NULL)
    {
        printf(&amp;quot;Error to connect two nodes.\n&amp;quot;);
        exit(1);
    }

    pCurrent-&amp;gt;m_pNext = pNext;
}

void PrintListNode(ListNode* pNode)
{
    if(pNode == NULL)
    {
        printf(&amp;quot;The node is NULL\n&amp;quot;);
    }
    else
    {
        printf(&amp;quot;The key in node is %d.\n&amp;quot;, pNode-&amp;gt;m_nValue);
    }
}

void PrintList(ListNode* pHead)
{
    printf(&amp;quot;PrintList starts.\n&amp;quot;);

    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        printf(&amp;quot;%d\t&amp;quot;, pNode-&amp;gt;m_nValue);
        pNode = pNode-&amp;gt;m_pNext;
    }

    printf(&amp;quot;\nPrintList ends.\n&amp;quot;);
}

void DestroyList(ListNode* pHead)
{
    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        pHead = pHead-&amp;gt;m_pNext;
        delete pNode;
        pNode = pHead;
    }
}

void AddToTail(ListNode** pHead, int value)
{
    ListNode* pNew = new ListNode();
    pNew-&amp;gt;m_nValue = value;
    pNew-&amp;gt;m_pNext = NULL;

    if(*pHead == NULL)
    {
        *pHead = pNew;
    }
    else
    {
        ListNode* pNode = *pHead;
        while(pNode-&amp;gt;m_pNext != NULL)
            pNode = pNode-&amp;gt;m_pNext;

        pNode-&amp;gt;m_pNext = pNew;
    }
}
//找到快慢指针相遇的节点
ListNode* MeetingNode(ListNode* pHead){
    if(pHead==NULL)
        return NULL;
    ListNode* pSlow=pHead-&amp;gt;m_pNext;
    if(pSlow==NULL)//就那一个节点，没有环
        return NULL;

    ListNode* pFast=pSlow-&amp;gt;m_pNext;//
    while(pFast!=NULL &amp;amp;&amp;amp; pSlow!=NULL)
    {
        if(pFast==pSlow)
            return pFast;

        pSlow=pSlow-&amp;gt;m_pNext;//一次一步
        pFast=pFast-&amp;gt;m_pNext;
        if(pFast!=NULL)
            pFast=pFast-&amp;gt;m_pNext;//一次两步
    }
    return  NULL;//不存在环
}

int number(ListNode* pHead){
     ListNode* meetingNode=MeetingNode(pHead);
    if(meetingNode==NULL)
        return NULL;

    //得到环的节点数目
    int nodeOfLoop=1;
    ListNode* pNode1=meetingNode;//环中的一个节点
    while(pNode1-&amp;gt;m_pNext!=meetingNode){
        pNode1=pNode1-&amp;gt;m_pNext;
        ++nodeOfLoop;
    }
    return nodeOfLoop;

}
ListNode* EntryNodeOfLoop(ListNode* pHead){
    int nodeOfLoop=number(pHead);

    //找环的入口
    ListNode* pNode1=pHead;
    for(int i=0;i&amp;lt;nodeOfLoop;i++){
        pNode1=pNode1-&amp;gt;m_pNext;//先走环的长度
    }

    //一起移动两个指针
    ListNode* pNode2=pHead;
    while(pNode1!=pNode2){
        pNode1=pNode1-&amp;gt;m_pNext;
        pNode2=pNode2-&amp;gt;m_pNext;
    }
    return pNode1;
}
int main()
{
    //构建有环的链表
    ListNode* pNode1 = CreateListNode(1);
    ListNode* pNode2 = CreateListNode(2);
    ListNode* pNode3 = CreateListNode(3);
    ListNode* pNode4 = CreateListNode(4);
    ListNode* pNode5 = CreateListNode(5);
    ListNode* pNode6 = CreateListNode(6);

    ConnectListNodes(pNode1, pNode2);
    ConnectListNodes(pNode2, pNode3);
    ConnectListNodes(pNode3, pNode4);
    ConnectListNodes(pNode4, pNode5);
    ConnectListNodes(pNode5, pNode6);
    ConnectListNodes(pNode6, pNode3);

    ListNode* first=EntryNodeOfLoop(pNode1);
    cout&amp;lt;&amp;lt;first-&amp;gt;m_nValue;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到链表中环的入口节点 //如果环有n个节点，那么指针p1先向前走n步，然后p1,p2一起往前走，直到相遇,相遇的节点就是入口节点&lt;br&gt;//接下来求环的节点个数：用快慢指针，如果相遇，必存在环，然后记下这个位置，再向前一边移动一边计数，当再次
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="http://wxjttxs.github.io/2016/05/16/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/16/第一个只出现一次的字符/</id>
    <published>2016-05-16T13:09:33.000Z</published>
    <updated>2016-05-16T13:13:12.596Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到字符流中第一个只出现一次的字符&lt;br&gt;//构建哈希表，用字符的ASCII码做下标，数值就是该字符在字符流中的位置，如果出现多次，那么这个数值就改成一个负值-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;limits&amp;gt;
using namespace std;

class CharStatistics{
public:
    CharStatistics():index(0)//下标初始值0
    {
        for(int i=0;i&amp;lt;256;i++)
            occurence[i]=-1;//初始化哈希表
    }
    void Insert(char ch){
        if(occurence[ch]==-1)
            occurence[ch]=index;
        else if(occurence[ch]&amp;gt;=0)
            occurence[ch]=-2;//不止出现一次
        index++;
    }
    char FirstAppearingOnce(){
        char ch=&amp;apos;\0&amp;apos;;
        int minIndex=numeric_limits&amp;lt;int&amp;gt;::max();//int可以表示的最大值

        for(int i=0;i&amp;lt;256;i++){
            if(occurence[i]&amp;gt;=0 &amp;amp;&amp;amp; occurence[i]&amp;lt;minIndex){//第一个只出现一次
                 minIndex=occurence[i];
                 ch=(char)i;

            }

        }
        return ch;
    }
private:
    //occurence[i]:A character with ASCII value i;
    //occurence[i]=-1: the character has not been found;
    //occurence[i]=-2: the character has been found with multiple times
    //occurence[i]&amp;gt;=0: the character has been found once
    int occurence[256];//ASCII码有 256 个,一个字节8位
    int index;
};
int main()
{
    CharStatistics test;
    test.Insert(&amp;apos;g&amp;apos;);
    cout&amp;lt;&amp;lt;test.FirstAppearingOnce();
    cout&amp;lt;&amp;lt;endl;
    test.Insert(&amp;apos;o&amp;apos;);
    test.Insert(&amp;apos;o&amp;apos;);
    test.Insert(&amp;apos;g&amp;apos;);
    test.Insert(&amp;apos;l&amp;apos;);
    test.Insert(&amp;apos;e&amp;apos;);
     cout&amp;lt;&amp;lt;test.FirstAppearingOnce();
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到字符流中第一个只出现一次的字符&lt;br&gt;//构建哈希表，用字符的ASCII码做下标，数值就是该字符在字符流中的位置，如果出现多次，那么这个数值就改成一个负值-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串与给定模式是否匹配</title>
    <link href="http://wxjttxs.github.io/2016/05/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BB%99%E5%AE%9A%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D/"/>
    <id>http://wxjttxs.github.io/2016/05/15/字符串与给定模式是否匹配/</id>
    <published>2016-05-15T06:59:13.000Z</published>
    <updated>2016-05-15T07:00:33.980Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//判斷字符串與模式是否匹配 //.表示匹配任意字符； *表示它前面的字符出現的次數（包含0次）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

bool matchCore(char* str,char* pattern);
bool match(char* str,char* pattern){
    if(str==NULL|| pattern==NULL)
        return false;
    return matchCore(str,pattern);
}
bool matchCore(char* str, char* pattern){
    if(*str==&amp;apos;\0&amp;apos; &amp;amp;&amp;amp; *pattern==&amp;apos;\0&amp;apos;)
        return true;
    if(*str!=&amp;apos;\0&amp;apos; &amp;amp;&amp;amp; *pattern==&amp;apos;\0&amp;apos;)
        return false;
    if(*(pattern+1)==&amp;apos;*&amp;apos;){
        if(*pattern==*str ||(*pattern ==&amp;apos;.&amp;apos; &amp;amp;&amp;amp; *str!=&amp;apos;\0&amp;apos;))
            return matchCore(str+1,pattern+2) //比較下一個狀態   *前數字出現1次
            || matchCore(str+1,pattern) //停留在當前狀態   &amp;gt;=2
            || matchCore(str,pattern+2);//忽略*  0
        else//忽略*
            return matchCore(str,pattern+2);
    }
    if(*str==*pattern || (*pattern ==&amp;apos;.&amp;apos; &amp;amp;&amp;amp; *str !=&amp;apos;\0&amp;apos;))//.表示任意一個字符，肯定匹配
        return matchCore(str+1,pattern+1);

    return false;
}
int main()
{
    cout &amp;lt;&amp;lt;match(&amp;quot;aaa&amp;quot;,&amp;quot;ab*a&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//判斷字符串與模式是否匹配 //.表示匹配任意字符； *表示它前面的字符出現的次數（包含0次）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到数组中所有重复的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/15/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/15/找到数组中所有重复的数字/</id>
    <published>2016-05-15T03:21:26.000Z</published>
    <updated>2016-05-15T03:22:00.704Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;找到數組中任意一個重複的數字，或者所有重複元素 那如果是所有重複的呢？動態數組 數組長度n,數組中的元素在0~n-1之間
&lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;iterator&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//**********************方法一排序*******************************
//時間複雜度是O(nlgn)
int part(int a[],int low,int high){//划分成左右子数组，找到中间位置
 int temp=a[high];//最后一个元素作为中间元素
 int i=low-1;//i是慢速下标
 for(int j=low;j&amp;lt;high;j++){//挨个检查元素，比中间值小的在放在它的左边，大的放在右边
    if(a[j]&amp;lt;=temp){
        i++;
        swap(a[i],a[j]);
    }
 }
 swap(a[i+1],a[high]);
 return i+1;//找到第一个比中间值大的元素，返回它的位置,这就是中间元素所在位置
}
void QuickSort(int a[],int low, int high){
    if(low&amp;lt;high){
        int mid=part(a,low,high);
        QuickSort(a,low,mid-1);
        QuickSort(a,mid+1,high);
    }
}
void duplicate1(int *a,int length){
    bool flag=true;

    if(a==NULL || length&amp;lt;=0){
        flag=false;
        return ;
    }
    QuickSort(a,0,length-1);

    int i=0;
    int j=1;
    vector&amp;lt;int&amp;gt; findData;

    while(j&amp;lt;length){//畫個示意圖很容易理解 0 1 1 2 2 3 4 5

        while(a[i]!=a[j] &amp;amp;&amp;amp; j&amp;lt;length){//注意這個j&amp;lt;length問題，最後一步如果沒有這個判斷，那麼i,j就會指向同一個值，就會出現重複壓入數組的情況
            i=j;
            j++;
        }
        if(a[i]==a[j]){
            findData.push_back(a[i]);
        }
        while(a[i]==a[j])
              j++;

    }
//這個實現找到任一個重複，vector數組找到所有重複數組
//    int findData=0;
//
//    for(int i=0;i&amp;lt;length-1;i++){
//        if(a[i]==a[i+1]){
//            findData=a[i];
//            break;
//        }
//    }

    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;
}
//*********************方法二哈希表******************************
//時間複雜度是O(n),需要額外的空間O(n)
void duplicate2(int *a, int length){

    int hashtable[length]={0};
    for(int i=0;i&amp;lt;length;i++){
            hashtable[a[i]]++;
    }
    vector&amp;lt;int&amp;gt; findData;
    for(int i=0;i&amp;lt;length;i++){
        if(hashtable[a[i]]&amp;gt;1)//需要去重
        {
            findData.push_back(a[i]);
        }

    }
    //重複過程
    vector&amp;lt;int&amp;gt;::iterator iter=findData.begin();
    iter=unique(findData.begin(),findData.end());//只能刪除相鄰的重複元素
    findData.erase(iter,findData.end());

    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;


}
//**********************方法三交換*******************************
/*
O(n)時間找到數組中重複的數字，並且不需要額外分配空間，空間複雜度為O(1)
*/
//如果下標i與在所在的數值不一致，那就交換以數值為下標的數值，前提是這兩個數值不一致，如果不同的下標同一個數字，那就說明找到重複的。
void duplicate3(int *a,int length){
    bool flag=false;
    if(a==NULL ||length&amp;lt;=0){
        return ;
    }
    for(int i=0;i&amp;lt;length;i++){
        if(a[i]&amp;lt;0 || a[i]&amp;gt;length-1)
            return ;
    }

    vector&amp;lt;int&amp;gt; findData;
    for(int i=0;i&amp;lt;length;i++){
        while(a[i]!=i){
            if(a[i]==a[a[i]]){
                    vector&amp;lt;int&amp;gt;::iterator it=find(findData.begin(),findData.end(),a[i]);
                    if(it!=findData.end())//數組中沒有這個元素再放進去，有的話進行下一輪判斷
                        break;
                    findData.push_back(a[i]);
                    flag=true;
                    break;
            }
            //否則就交換以這個數值為下標的數字
            else{
                int temp=a[i];
                a[i]=a[temp];
                a[temp]=temp;
            }
        }
    }


    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;
}
int main()
{
    int a[]={0,0,1,2,2,3,4,4,5,6};
   // duplicate1(a,8);
   //duplicate2(a,10);

    duplicate3(a,10);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;找到數組中任意一個重複的數字，或者所有重複元素 那如果是所有重複的呢？動態數組 數組長度n,數組中的元素在0~n-1之間
&lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在二叉树中找到两个节点的最低公共祖先</title>
    <link href="http://wxjttxs.github.io/2016/05/14/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://wxjttxs.github.io/2016/05/14/在二叉树中找到两个节点的最低公共祖先/</id>
    <published>2016-05-14T12:27:09.000Z</published>
    <updated>2016-05-14T12:38:57.532Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;   /*在二叉樹中找到給定兩個節點的最低公共祖先 lowest common ancestor LCA&lt;br&gt;我們做一個規定：如果a是b的祖先，那麼他倆的LCA是a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;list&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;

struct Node
{
    struct Node *left, *right;
    int key;
};

Node* newNode(int key)
{
    Node *temp = new Node;
    temp-&amp;gt;key = key;
    temp-&amp;gt;left = temp-&amp;gt;right = NULL;
    return temp;
}
//************************方法一遞歸************************

/* 只用一次遍历解决LCA
學號二叉樹，用好遞歸
從root開始遍歷，如果n1,n2有一個與root匹配，那麼root就是LCA。如果都不匹配，遞歸左右子樹，如果
有一個在左子樹，一個在右子樹，那麼root是LCA。如果兩個數都在左子樹，則說明LCA在左子樹，否則在右子樹
*/

// 返回n1和n2的 LCA的指针
// 假设n1和n2都出现在树中
struct Node *findLCA1(struct Node* root, int n1, int n2)
{
    if (root == NULL) return NULL;

    // 只要n1 或 n2 的任一个匹配即可
    //  (注意：如果 一个节点是另一个祖先，则返回的是祖先节点。因为递归是要返回到祖先的 )
    if (root-&amp;gt;key == n1 || root-&amp;gt;key == n2)
        return root;
    // 分别在左右子树查找
    Node *left_lca  = findLCA1(root-&amp;gt;left, n1, n2);
    Node *right_lca = findLCA1(root-&amp;gt;right, n1, n2);
    // 如果都返回非空指针 Non-NULL, 则说明两个节点分别出现了在两个子树中，则当前节点肯定为LCA
    if (left_lca &amp;amp;&amp;amp; right_lca)  return root;
    // 如果一个为空，在说明LCA在另一个子树
    return (left_lca != NULL)? left_lca: right_lca;
}

//************************方法二找到路徑，求路徑的最後一個公共節點****************
//找到給定節點的路徑
bool GetNodePath(Node* pRoot,int key, list&amp;lt;Node*&amp;gt;&amp;amp;path){
    if(pRoot==NULL)
        return false;
    path.push_back(pRoot);//關鍵在於存放節點與判斷的順序
    if(pRoot-&amp;gt;key==key)
        return true;


    //左右子樹是否找到，找到的話，當前節點就在路徑中
    bool found=(GetNodePath(pRoot-&amp;gt;left,key,path) ||GetNodePath(pRoot-&amp;gt;right,key,path));
    if(!found)//沒有找到就彈出
         path.pop_back();
    return found;

}
//查看路徑上的節點
void PrintPath(list&amp;lt;Node*&amp;gt;&amp;amp;path){
    Node* pLast=NULL;
    list&amp;lt;Node*&amp;gt;::const_iterator iter1=path.begin();
    while(iter1!=path.end()){

        pLast=*iter1;
        cout&amp;lt;&amp;lt;pLast-&amp;gt;key&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        iter1++;
    }
    cout&amp;lt;&amp;lt;endl;
}
//得到兩條路上的最後一個公共節點
Node* GetLastCommonNode(const list&amp;lt;Node*&amp;gt;&amp;amp; path1,const list&amp;lt;Node*&amp;gt;&amp;amp; path2){
    list&amp;lt;Node*&amp;gt;::const_iterator iter1=path1.begin();
    list&amp;lt;Node*&amp;gt;::const_iterator iter2=path2.begin();
    Node* pLast=NULL;

    while(iter1!=path1.end() &amp;amp;&amp;amp; iter2!=path2.end()){
        if(*iter1==*iter2)
            pLast=*iter1;
        iter1++;
        iter2++;
    }
    return pLast;
}
//找到兩個指點節點的最低公共祖先（根節點的祖先是他自己）
Node* findLCA2(Node* pRoot, int key1,int key2){
    list&amp;lt;Node*&amp;gt; path1;
    list&amp;lt;Node*&amp;gt; path2;
    if(pRoot==NULL )//輸入無效，找不到
    {

        return NULL;
    }

    if(GetNodePath(pRoot,key1,path1) &amp;amp;&amp;amp;  GetNodePath(pRoot,key2,path2))
            return GetLastCommonNode(path1,path2);


}

//测试
int main()
{
    // 构造上面图中的树
    Node * root = newNode(1);
    root-&amp;gt;left = newNode(2);
    root-&amp;gt;right = newNode(3);
    root-&amp;gt;left-&amp;gt;left = newNode(4);
    root-&amp;gt;left-&amp;gt;right = newNode(5);
    root-&amp;gt;right-&amp;gt;left = newNode(6);
    root-&amp;gt;right-&amp;gt;right = newNode(7);
//    cout &amp;lt;&amp;lt; &amp;quot;LCA(4, 5) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 4, 5)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(4, 6) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 4, 6)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(3, 4) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 3, 4)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(2, 4) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 2, 4)-&amp;gt;key;

  // cout&amp;lt;&amp;lt;endl;


    Node* p1=NULL;Node* p2=NULL;

    p1= findLCA1(root,6,7);
    p2= findLCA2(root,6,7);
    cout&amp;lt;&amp;lt;&amp;quot;last node1:&amp;quot;&amp;lt;&amp;lt;p1-&amp;gt;key&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;last node2:&amp;quot;&amp;lt;&amp;lt;p2-&amp;gt;key&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;   /*在二叉樹中找到給定兩個節點的最低公共祖先 lowest common ancestor LCA&lt;br&gt;我們做一個規定：如果a是b的祖先，那麼他倆的LCA是a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串转换为整型</title>
    <link href="http://wxjttxs.github.io/2016/05/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E5%BD%A2/"/>
    <id>http://wxjttxs.github.io/2016/05/14/字符串转换为整形/</id>
    <published>2016-05-14T08:23:03.000Z</published>
    <updated>2016-05-14T08:23:43.725Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//不用atoi，实现字符串转数字 //考虑边界：字符串NULL，正负号，int 型最大0x7fffffff,负数最小0x80000000&lt;br&gt;//区分“0”的输出结果和无效字符串的输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
enum Status {kValid=0, kInvalid};
int g_nStatus=kValid;//输出状态
long long StrToIntCore(const char* str, bool minuss){
    long long num=0;
    while(*str!=&amp;apos;\0&amp;apos;){
        if(*str&amp;gt;=&amp;apos;0&amp;apos; &amp;amp;&amp;amp; *str&amp;lt;=&amp;apos;9&amp;apos;){//有效数字
            int flag=minuss?-1:1;
            num=num*10+flag*(*str-&amp;apos;0&amp;apos;);

            if((!minuss &amp;amp;&amp;amp; num&amp;gt;0x7fffffff)||(minuss &amp;amp;&amp;amp; num&amp;lt;(signed int)0x80000000)){//超过long long表示范围,注意signed int
                num=0;
                break;
            }
            str++;
        }
        else{//非法输入
            num=0;
            break;
        }
    }
    if(*str==&amp;apos;\0&amp;apos;)//字符串为空
    {
        g_nStatus=kValid;
    }
    return num;
}
int StrToInt(const char* str){
    g_nStatus=kInvalid;
    long long num=0;

    if(str!=NULL &amp;amp;&amp;amp; *str !=&amp;apos;\0&amp;apos;){
        bool minuss=false;//正负号
        if(*str==&amp;apos;+&amp;apos;)
            str++;
        else if(*str==&amp;apos;-&amp;apos;){
            str++;
            minuss=true;
        }
        if(*str!=&amp;apos;\0&amp;apos;){
            num=StrToIntCore(str,minuss);
        }
    }
    return (int)num;
}
int main()
{
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;-123&amp;quot;) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;+123&amp;quot;) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;0&amp;quot;) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;&amp;quot;) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//不用atoi，实现字符串转数字 //考虑边界：字符串NULL，正负号，int 型最大0x7fffffff,负数最小0x80000000&lt;br&gt;//区分“0”的输出结果和无效字符串的输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1+2+3..+n</title>
    <link href="http://wxjttxs.github.io/2016/05/13/1-2-3-n/"/>
    <id>http://wxjttxs.github.io/2016/05/13/1-2-3-n/</id>
    <published>2016-05-13T09:59:06.000Z</published>
    <updated>2016-05-13T09:59:38.606Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//���ó˳���for�� while��if else��switch caseʵ��1+2+����+n //��Ȼ���͹�ʽ�Ͳ�������&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//***********************��һ�����ù��캯������*****************************
class Temp{
public:
    Temp(){++N; Sum+=N;}
    static void Reset() {N=0;Sum=0;}
    static unsigned int GetSum(){return Sum;}
private:
    static unsigned int N;
    static unsigned int Sum;

};
unsigned int Temp::N=0;
unsigned int Temp::Sum=0;
unsigned int Sum_Solution1(unsigned int n)
{
    Temp::Reset();
    Temp *a= new Temp[n];//���ù��캯��n��
    delete[] a;
    a=NULL;
    return Temp::GetSum();

}
//***********************�ڶ��������麯������*****************************
//�麯�������������ж���������ͬ���ĺ��������ҿ���ͨ������ָ�������������ʻ������������е�ͬ������
//��������������һ���ݹ飬һ����ֹ�ݹ飬���Ǵ��ж�ѡһ���� ����������ͨ��!!n����ֵת���ɲ����͡�
class A;
A * Array[2];
class A{
public:
    virtual unsigned int Sum(unsigned int n){
        return 0;
    }
};
class B :public A{
public:
    virtual unsigned int Sum(unsigned int n){
        return Array[!!n]-&amp;gt;Sum(n-1)+n;//�Ӻ���ǰ��ʼ��
    }
};
//���麯��ʵ�ֺ�����ѡ�񣬵���ֵ��Ϊ0ѡ��B::Sum()��n=0ѡ��A::Sum()
int Sum_Solution2(int n){
    A a;
    B b;
    Array[0]=&amp;amp;a;
    Array[1]=&amp;amp;b;

    int value=Array[1]-&amp;gt;Sum(n);
    return value;
}
//***********************���������ú���ָ������*****************************
//�ڴ�C���ԵĻ����У�����ʹ���麯������ʱ�����ú���ָ����ģ��
typedef unsigned int (*fun) (unsigned int);
unsigned int Sum_Solution3_Teminator(unsigned int n){
    return 0;
}
unsigned int Sum_Solution3(unsigned int n){
    static fun f[2]={Sum_Solution3_Teminator,Sum_Solution3};//��ʵ����һά����
    return n+f[!!n](n-1);
}
//***********************������ģ����������*******************************
template &amp;lt;unsigned int n&amp;gt; struct Sum_Solution4{
    enum Value {N=Sum_Solution4&amp;lt;n-1&amp;gt;::N+n};
};
template &amp;lt;&amp;gt; struct Sum_Solution4&amp;lt;1&amp;gt;{
    enum Value {N=1};
};
int main()
{
   cout&amp;lt;&amp;lt; Sum_Solution4&amp;lt;100&amp;gt;::N;//���ֵ��÷����ܶ���
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//���ó˳���for�� while��if else��switch caseʵ��1+2+����+n //��Ȼ���͹�ʽ�Ͳ�������&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iost
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不用四则运算，实现两数相加</title>
    <link href="http://wxjttxs.github.io/2016/05/13/%E4%B8%8D%E7%94%A8%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://wxjttxs.github.io/2016/05/13/不用四则运算，实现两数相加/</id>
    <published>2016-05-13T09:03:53.000Z</published>
    <updated>2016-05-13T09:15:16.958Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//不用四则运算实现两数相加 //分成三步：首先两数相加不进位；然后对应位上的进位，最后把前两部的结果相加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int GetSum(int a,int b){
    int sum=0;int carryy=0;
    do{
        sum=a^b;//第一步
        carryy=(a&amp;amp;b)&amp;lt;&amp;lt;1;//第二步
        a=sum;//第三步
        b=carryy;//第三步

    }while(b);
    return a;
}
int main()
{
    cout&amp;lt;&amp;lt;GetSum(5,8);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//不用四则运算实现两数相加 //分成三步：首先两数相加不进位；然后对应位上的进位，最后把前两部的结果相加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespac
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>圆圈剩下的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E5%9C%86%E5%9C%88%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/09/圆圈剩下的数字/</id>
    <published>2016-05-09T15:16:13.000Z</published>
    <updated>2016-05-09T15:16:37.526Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//从0~n-1这n个数字构成环形，从0开始每次删除第m个数字，求最后一个剩下的数字 //要么借助环形链表数据结构&lt;br&gt;//要么通过数学建模找到规律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;list&amp;gt;
using namespace std;
//**********************方法一环形结构****************************
//std::list本身并不是一个环形结构，因此每当迭代器扫描到末尾时候，我们要把迭代器移到链表头部，
//Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢.
int LastRemaining(unsigned int n,unsigned int m){
    if(n&amp;lt;1 || m&amp;lt;1)
        return -1;
    unsigned int i=0;
    list&amp;lt;int&amp;gt; numbers;
    for(i=0;i&amp;lt;n;i++)
        numbers.push_back(i);//0~n-1
    list&amp;lt;int&amp;gt;::iterator current=numbers.begin();
    while(numbers.size()&amp;gt;1){
        for(int i=1;i&amp;lt;m;i++){//找到第m个要删除的位置
            current++;//current指向要删除的位置
            if(current==numbers.end())
                current=numbers.begin();

        }
        list&amp;lt;int&amp;gt;::iterator next=++current;
        if(next==numbers.end())
            next=numbers.begin();
        --current;
        numbers.erase(current);
        current=next;
    }
    return *(current);
}
//**********************方法二数学建模****************************
//令f(n,m)表示从0开始删除第m个数字后的剩下的数字；第一个删除的数字是（m-1)%n，为了简单表示，我们令k=（m-1)%n。剩下的数字0,1,2，，，，k-1,k+1,k+2..n-1;
//下一次从k+1开始计数。相当于形成这样的序列：k+1,k+2...0,1...k-1。剩下的序列也是关于n,m的函数。但是这个序列的规律和最初的规律不一样。因此记为f&amp;apos;(n-1,m).
//最初序列剩下的数字一定是删除一个数字之后的序列最后剩下的数字，即f(n,m)=f&amp;apos;(n-1,m).
//定义一种映射 ，使得k+1,k+2...0,1...k-1 -》0,1.。。n-2，p(x)=(x-k-1)%n.逆映射p&amp;apos;(x)=(x+k+1)%n
//f(n,m)=f&amp;apos;(n-1,m)=p&amp;apos;(f(n-1,m))=[f(n-1,m)+k+1]%n=[f(n-1,m)+m]%n;
//综上，递归公式：f(n,m)=0   n=1
//                      =[f(n-1,m)+m]%n  n&amp;gt;1

int LastRemaining(unsigned int n,unsigned int m){
    if(n&amp;lt;1 ||m&amp;lt;1)
        return -1;
    int last=0;
    for(int i=2;i&amp;lt;=n;i++)
        last=(last+m)%i;
    return last;
}
int main()
{
    int data[]={3,4,5,6,7,8};
    for(int i=0;i&amp;lt;6;i++)

        cout&amp;lt;&amp;lt;LastRemaining(data[i],3)&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//从0~n-1这n个数字构成环形，从0开始每次删除第m个数字，求最后一个剩下的数字 //要么借助环形链表数据结构&lt;br&gt;//要么通过数学建模找到规律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostre
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扑克牌是不是顺子</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E6%89%91%E5%85%8B%E7%89%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E9%A1%BA%E5%AD%90/"/>
    <id>http://wxjttxs.github.io/2016/05/09/扑克牌是不是顺子/</id>
    <published>2016-05-09T10:33:45.000Z</published>
    <updated>2016-05-09T10:34:19.965Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//从扑克牌中抽出五张，判断是不是顺子，A用1表示；JQK用11,12,13表示；大小王看成任意数字&lt;br&gt;//首先排序数组，然后统计0的个数和数组中间隔数，如果0的个数&amp;gt;=间隔，返回true。&lt;br&gt;//还有需要注意，如果数组中有两个数字相同，那么不可能是顺子了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

int compare(const void *arg1,const void *arg2){
    return *(int*)arg1-*(int*)arg2;
}
bool IsContinuous(int *data,int length){
    if(data==NULL ||length&amp;lt;1)
        return false;

    qsort(data,length,sizeof(int),compare);//排序

    int numberOfZero=0;//0的个数，间隔的数目
    int numberOfGap=0;

    //统计0的个数
    for(int i=0;i&amp;lt;length;i++){
        if(data[i]==0)
            numberOfZero++;
    }
    //统计间隔数目
    int small=numberOfZero;//必须从这个开始，因为0不能算在这个里面，代表的是任意
    int big=small+1;
    while(big&amp;lt;length){
        //两个数相等，对子不可能是顺子
        if(data[small]==data[big])
            return false;
        numberOfGap+=data[big]-data[small]-1;//比如 1  3   4  5
        small=big;//两个指针，依次往后挪
        big++;
    }
    return (numberOfGap&amp;lt;=numberOfZero)?true:false;

}
int main()
{
    int data[]={2,4,5,6,0};
    cout&amp;lt;&amp;lt;IsContinuous(data,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//从扑克牌中抽出五张，判断是不是顺子，A用1表示；JQK用11,12,13表示；大小王看成任意数字&lt;br&gt;//首先排序数组，然后统计0的个数和数组中间隔数，如果0的个数&amp;gt;=间隔，返回true。&lt;br&gt;//还有需要注意，如果数组中有两个数字相
    
    </summary>
    
    
  </entry>
  
</feed>
