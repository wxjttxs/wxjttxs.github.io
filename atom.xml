<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happy happy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxjttxs.github.io/"/>
  <updated>2016-05-21T14:40:06.728Z</updated>
  <id>http://wxjttxs.github.io/</id>
  
  <author>
    <name>王晓静</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>删除链表中重复的节点</title>
    <link href="http://wxjttxs.github.io/2016/05/21/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/21/删除链表中重复的节点/</id>
    <published>2016-05-21T14:39:33.000Z</published>
    <updated>2016-05-21T14:40:06.728Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//删除排序链表中重复的节点 //注意如果头结点是重复的，那么删除节点之后防止链表散掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;iostream&amp;gt;
    #include&amp;lt;stdio.h&amp;gt;
    #include&amp;lt;stdlib.h&amp;gt;
    using namespace std;
    //构建链表，显示链表
    struct ListNode
    {
        int       m_nValue;
        ListNode* m_pNext;
    };

    ListNode* CreateListNode(int value);
    void ConnectListNodes(ListNode* pCurrent, ListNode* pNext);
    void PrintListNode(ListNode* pNode);
    void PrintList(ListNode* pHead);
    void DestroyList(ListNode* pHead);
    void AddToTail(ListNode** pHead, int value);

    ListNode* CreateListNode(int value)
    {
        ListNode* pNode = new ListNode();
        pNode-&amp;gt;m_nValue = value;
        pNode-&amp;gt;m_pNext = NULL;

        return pNode;
    }

    void ConnectListNodes(ListNode* pCurrent, ListNode* pNext)
    {
        if(pCurrent == NULL)
        {
            printf(&amp;quot;Error to connect two nodes.\n&amp;quot;);
            exit(1);
        }

        pCurrent-&amp;gt;m_pNext = pNext;
    }

    void PrintListNode(ListNode* pNode)
    {
        if(pNode == NULL)
        {
            printf(&amp;quot;The node is NULL\n&amp;quot;);
        }
        else
        {
            printf(&amp;quot;The key in node is %d.\n&amp;quot;, pNode-&amp;gt;m_nValue);
        }
    }

    void PrintList(ListNode* pHead)
    {
        printf(&amp;quot;PrintList starts.\n&amp;quot;);

        ListNode* pNode = pHead;
        while(pNode != NULL)
        {
            printf(&amp;quot;%d\t&amp;quot;, pNode-&amp;gt;m_nValue);
            pNode = pNode-&amp;gt;m_pNext;
        }

        printf(&amp;quot;\nPrintList ends.\n&amp;quot;);
    }

    void DestroyList(ListNode* pHead)
    {
        ListNode* pNode = pHead;
        while(pNode != NULL)
        {
            pHead = pHead-&amp;gt;m_pNext;
            delete pNode;
            pNode = pHead;
        }
    }

    void AddToTail(ListNode** pHead, int value)
    {
        ListNode* pNew = new ListNode();
        pNew-&amp;gt;m_nValue = value;
        pNew-&amp;gt;m_pNext = NULL;

        if(*pHead == NULL)
        {
            *pHead = pNew;
        }
        else
        {
            ListNode* pNode = *pHead;
            while(pNode-&amp;gt;m_pNext != NULL)
                pNode = pNode-&amp;gt;m_pNext;

            pNode-&amp;gt;m_pNext = pNew;
        }
    }
//删除重复节点
void deleteDuplication(ListNode** pHead){//头结点也有可能被删除**
    if(pHead==NULL || *pHead==NULL)
        return;
    ListNode* pPreNode=NULL;
    ListNode* pNode=*pHead;
    while(pNode!=NULL){
        ListNode* pNext=pNode-&amp;gt;m_pNext;
        bool needDeleted=false;

        if(pNext!=NULL &amp;amp;&amp;amp; pNext-&amp;gt;m_nValue==pNode-&amp;gt;m_nValue)//重复
            needDeleted=true;

        if(!needDeleted){
            pPreNode=pNode;
            pNode=pNode-&amp;gt;m_pNext;//继续往后找有没有重复的
        }
        else{
            int value=pNode-&amp;gt;m_nValue;
            ListNode* pToBeDel=pNode;

            while(pToBeDel!=NULL &amp;amp;&amp;amp; pToBeDel-&amp;gt;m_nValue==value){
                pNext=pToBeDel-&amp;gt;m_pNext;

                delete pToBeDel;
                pToBeDel=NULL;

                pToBeDel=pNext;
            }
            if(pPreNode==NULL)//头结点重复了
                *pHead=pNext;
            else
                pPreNode-&amp;gt;m_pNext=pNext;
            pNode=pNext;//继续下一个判断
        }
    }

}
int main()
{
//构建链表

    ListNode* pNode1 = CreateListNode(1);
    ListNode* pNode2 = CreateListNode(2);
    ListNode* pNode3 = CreateListNode(3);
    ListNode* pNode4 = CreateListNode(3);
    ListNode* pNode5 = CreateListNode(5);
    ListNode* pNode6 = CreateListNode(6);

    ConnectListNodes(pNode1, pNode2);
    ConnectListNodes(pNode2, pNode3);
    ConnectListNodes(pNode3, pNode4);
    ConnectListNodes(pNode4, pNode5);
    ConnectListNodes(pNode5, pNode6);

    ListNode* pHead=pNode1;
    deleteDuplication(&amp;amp;pHead);
    PrintList(pHead);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//删除排序链表中重复的节点 //注意如果头结点是重复的，那么删除节点之后防止链表散掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;iostream&amp;gt;
    #include&amp;lt;stdio.h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到带有环的链表的入口</title>
    <link href="http://wxjttxs.github.io/2016/05/21/%E6%89%BE%E5%88%B0%E5%B8%A6%E6%9C%89%E7%8E%AF%E7%9A%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3/"/>
    <id>http://wxjttxs.github.io/2016/05/21/找到带有环的链表的入口/</id>
    <published>2016-05-21T13:39:36.000Z</published>
    <updated>2016-05-21T14:16:37.794Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到链表中环的入口节点 //如果环有n个节点，那么指针p1先向前走n步，然后p1,p2一起往前走，直到相遇,相遇的节点就是入口节点&lt;br&gt;//接下来求环的节点个数：用快慢指针，如果相遇，必存在环，然后记下这个位置，再向前一边移动一边计数，当再次回到这个节点，就求出这个huan的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
using namespace std;
//构建链表，显示链表
struct ListNode
{
    int       m_nValue;
    ListNode* m_pNext;
};

ListNode* CreateListNode(int value);
void ConnectListNodes(ListNode* pCurrent, ListNode* pNext);
void PrintListNode(ListNode* pNode);
void PrintList(ListNode* pHead);
void DestroyList(ListNode* pHead);
void AddToTail(ListNode** pHead, int value);

ListNode* CreateListNode(int value)
{
    ListNode* pNode = new ListNode();
    pNode-&amp;gt;m_nValue = value;
    pNode-&amp;gt;m_pNext = NULL;

    return pNode;
}

void ConnectListNodes(ListNode* pCurrent, ListNode* pNext)
{
    if(pCurrent == NULL)
    {
        printf(&amp;quot;Error to connect two nodes.\n&amp;quot;);
        exit(1);
    }

    pCurrent-&amp;gt;m_pNext = pNext;
}

void PrintListNode(ListNode* pNode)
{
    if(pNode == NULL)
    {
        printf(&amp;quot;The node is NULL\n&amp;quot;);
    }
    else
    {
        printf(&amp;quot;The key in node is %d.\n&amp;quot;, pNode-&amp;gt;m_nValue);
    }
}

void PrintList(ListNode* pHead)
{
    printf(&amp;quot;PrintList starts.\n&amp;quot;);

    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        printf(&amp;quot;%d\t&amp;quot;, pNode-&amp;gt;m_nValue);
        pNode = pNode-&amp;gt;m_pNext;
    }

    printf(&amp;quot;\nPrintList ends.\n&amp;quot;);
}

void DestroyList(ListNode* pHead)
{
    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        pHead = pHead-&amp;gt;m_pNext;
        delete pNode;
        pNode = pHead;
    }
}

void AddToTail(ListNode** pHead, int value)
{
    ListNode* pNew = new ListNode();
    pNew-&amp;gt;m_nValue = value;
    pNew-&amp;gt;m_pNext = NULL;

    if(*pHead == NULL)
    {
        *pHead = pNew;
    }
    else
    {
        ListNode* pNode = *pHead;
        while(pNode-&amp;gt;m_pNext != NULL)
            pNode = pNode-&amp;gt;m_pNext;

        pNode-&amp;gt;m_pNext = pNew;
    }
}
//找到快慢指针相遇的节点
ListNode* MeetingNode(ListNode* pHead){
    if(pHead==NULL)
        return NULL;
    ListNode* pSlow=pHead-&amp;gt;m_pNext;
    if(pSlow==NULL)//就那一个节点，没有环
        return NULL;

    ListNode* pFast=pSlow-&amp;gt;m_pNext;//
    while(pFast!=NULL &amp;amp;&amp;amp; pSlow!=NULL)
    {
        if(pFast==pSlow)
            return pFast;

        pSlow=pSlow-&amp;gt;m_pNext;//一次一步
        pFast=pFast-&amp;gt;m_pNext;
        if(pFast!=NULL)
            pFast=pFast-&amp;gt;m_pNext;//一次两步
    }
    return  NULL;//不存在环
}

int number(ListNode* pHead){
     ListNode* meetingNode=MeetingNode(pHead);
    if(meetingNode==NULL)
        return NULL;

    //得到环的节点数目
    int nodeOfLoop=1;
    ListNode* pNode1=meetingNode;//环中的一个节点
    while(pNode1-&amp;gt;m_pNext!=meetingNode){
        pNode1=pNode1-&amp;gt;m_pNext;
        ++nodeOfLoop;
    }
    return nodeOfLoop;

}
ListNode* EntryNodeOfLoop(ListNode* pHead){
    int nodeOfLoop=number(pHead);

    //找环的入口
    ListNode* pNode1=pHead;
    for(int i=0;i&amp;lt;nodeOfLoop;i++){
        pNode1=pNode1-&amp;gt;m_pNext;//先走环的长度
    }

    //一起移动两个指针
    ListNode* pNode2=pHead;
    while(pNode1!=pNode2){
        pNode1=pNode1-&amp;gt;m_pNext;
        pNode2=pNode2-&amp;gt;m_pNext;
    }
    return pNode1;
}
int main()
{
    //构建有环的链表
    ListNode* pNode1 = CreateListNode(1);
    ListNode* pNode2 = CreateListNode(2);
    ListNode* pNode3 = CreateListNode(3);
    ListNode* pNode4 = CreateListNode(4);
    ListNode* pNode5 = CreateListNode(5);
    ListNode* pNode6 = CreateListNode(6);

    ConnectListNodes(pNode1, pNode2);
    ConnectListNodes(pNode2, pNode3);
    ConnectListNodes(pNode3, pNode4);
    ConnectListNodes(pNode4, pNode5);
    ConnectListNodes(pNode5, pNode6);
    ConnectListNodes(pNode6, pNode3);

    ListNode* first=EntryNodeOfLoop(pNode1);
    cout&amp;lt;&amp;lt;first-&amp;gt;m_nValue;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到链表中环的入口节点 //如果环有n个节点，那么指针p1先向前走n步，然后p1,p2一起往前走，直到相遇,相遇的节点就是入口节点&lt;br&gt;//接下来求环的节点个数：用快慢指针，如果相遇，必存在环，然后记下这个位置，再向前一边移动一边计数，当再次
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="http://wxjttxs.github.io/2016/05/16/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/16/第一个只出现一次的字符/</id>
    <published>2016-05-16T13:09:33.000Z</published>
    <updated>2016-05-16T13:13:12.596Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到字符流中第一个只出现一次的字符&lt;br&gt;//构建哈希表，用字符的ASCII码做下标，数值就是该字符在字符流中的位置，如果出现多次，那么这个数值就改成一个负值-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;limits&amp;gt;
using namespace std;

class CharStatistics{
public:
    CharStatistics():index(0)//下标初始值0
    {
        for(int i=0;i&amp;lt;256;i++)
            occurence[i]=-1;//初始化哈希表
    }
    void Insert(char ch){
        if(occurence[ch]==-1)
            occurence[ch]=index;
        else if(occurence[ch]&amp;gt;=0)
            occurence[ch]=-2;//不止出现一次
        index++;
    }
    char FirstAppearingOnce(){
        char ch=&amp;apos;\0&amp;apos;;
        int minIndex=numeric_limits&amp;lt;int&amp;gt;::max();//int可以表示的最大值

        for(int i=0;i&amp;lt;256;i++){
            if(occurence[i]&amp;gt;=0 &amp;amp;&amp;amp; occurence[i]&amp;lt;minIndex){//第一个只出现一次
                 minIndex=occurence[i];
                 ch=(char)i;

            }

        }
        return ch;
    }
private:
    //occurence[i]:A character with ASCII value i;
    //occurence[i]=-1: the character has not been found;
    //occurence[i]=-2: the character has been found with multiple times
    //occurence[i]&amp;gt;=0: the character has been found once
    int occurence[256];//ASCII码有 256 个,一个字节8位
    int index;
};
int main()
{
    CharStatistics test;
    test.Insert(&amp;apos;g&amp;apos;);
    cout&amp;lt;&amp;lt;test.FirstAppearingOnce();
    cout&amp;lt;&amp;lt;endl;
    test.Insert(&amp;apos;o&amp;apos;);
    test.Insert(&amp;apos;o&amp;apos;);
    test.Insert(&amp;apos;g&amp;apos;);
    test.Insert(&amp;apos;l&amp;apos;);
    test.Insert(&amp;apos;e&amp;apos;);
     cout&amp;lt;&amp;lt;test.FirstAppearingOnce();
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到字符流中第一个只出现一次的字符&lt;br&gt;//构建哈希表，用字符的ASCII码做下标，数值就是该字符在字符流中的位置，如果出现多次，那么这个数值就改成一个负值-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串与给定模式是否匹配</title>
    <link href="http://wxjttxs.github.io/2016/05/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BB%99%E5%AE%9A%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D/"/>
    <id>http://wxjttxs.github.io/2016/05/15/字符串与给定模式是否匹配/</id>
    <published>2016-05-15T06:59:13.000Z</published>
    <updated>2016-05-15T07:00:33.980Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//判斷字符串與模式是否匹配 //.表示匹配任意字符； *表示它前面的字符出現的次數（包含0次）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

bool matchCore(char* str,char* pattern);
bool match(char* str,char* pattern){
    if(str==NULL|| pattern==NULL)
        return false;
    return matchCore(str,pattern);
}
bool matchCore(char* str, char* pattern){
    if(*str==&amp;apos;\0&amp;apos; &amp;amp;&amp;amp; *pattern==&amp;apos;\0&amp;apos;)
        return true;
    if(*str!=&amp;apos;\0&amp;apos; &amp;amp;&amp;amp; *pattern==&amp;apos;\0&amp;apos;)
        return false;
    if(*(pattern+1)==&amp;apos;*&amp;apos;){
        if(*pattern==*str ||(*pattern ==&amp;apos;.&amp;apos; &amp;amp;&amp;amp; *str!=&amp;apos;\0&amp;apos;))
            return matchCore(str+1,pattern+2) //比較下一個狀態   *前數字出現1次
            || matchCore(str+1,pattern) //停留在當前狀態   &amp;gt;=2
            || matchCore(str,pattern+2);//忽略*  0
        else//忽略*
            return matchCore(str,pattern+2);
    }
    if(*str==*pattern || (*pattern ==&amp;apos;.&amp;apos; &amp;amp;&amp;amp; *str !=&amp;apos;\0&amp;apos;))//.表示任意一個字符，肯定匹配
        return matchCore(str+1,pattern+1);

    return false;
}
int main()
{
    cout &amp;lt;&amp;lt;match(&amp;quot;aaa&amp;quot;,&amp;quot;ab*a&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//判斷字符串與模式是否匹配 //.表示匹配任意字符； *表示它前面的字符出現的次數（包含0次）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到数组中所有重复的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/15/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/15/找到数组中所有重复的数字/</id>
    <published>2016-05-15T03:21:26.000Z</published>
    <updated>2016-05-15T03:22:00.704Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;找到數組中任意一個重複的數字，或者所有重複元素 那如果是所有重複的呢？動態數組 數組長度n,數組中的元素在0~n-1之間
&lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;iterator&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//**********************方法一排序*******************************
//時間複雜度是O(nlgn)
int part(int a[],int low,int high){//划分成左右子数组，找到中间位置
 int temp=a[high];//最后一个元素作为中间元素
 int i=low-1;//i是慢速下标
 for(int j=low;j&amp;lt;high;j++){//挨个检查元素，比中间值小的在放在它的左边，大的放在右边
    if(a[j]&amp;lt;=temp){
        i++;
        swap(a[i],a[j]);
    }
 }
 swap(a[i+1],a[high]);
 return i+1;//找到第一个比中间值大的元素，返回它的位置,这就是中间元素所在位置
}
void QuickSort(int a[],int low, int high){
    if(low&amp;lt;high){
        int mid=part(a,low,high);
        QuickSort(a,low,mid-1);
        QuickSort(a,mid+1,high);
    }
}
void duplicate1(int *a,int length){
    bool flag=true;

    if(a==NULL || length&amp;lt;=0){
        flag=false;
        return ;
    }
    QuickSort(a,0,length-1);

    int i=0;
    int j=1;
    vector&amp;lt;int&amp;gt; findData;

    while(j&amp;lt;length){//畫個示意圖很容易理解 0 1 1 2 2 3 4 5

        while(a[i]!=a[j] &amp;amp;&amp;amp; j&amp;lt;length){//注意這個j&amp;lt;length問題，最後一步如果沒有這個判斷，那麼i,j就會指向同一個值，就會出現重複壓入數組的情況
            i=j;
            j++;
        }
        if(a[i]==a[j]){
            findData.push_back(a[i]);
        }
        while(a[i]==a[j])
              j++;

    }
//這個實現找到任一個重複，vector數組找到所有重複數組
//    int findData=0;
//
//    for(int i=0;i&amp;lt;length-1;i++){
//        if(a[i]==a[i+1]){
//            findData=a[i];
//            break;
//        }
//    }

    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;
}
//*********************方法二哈希表******************************
//時間複雜度是O(n),需要額外的空間O(n)
void duplicate2(int *a, int length){

    int hashtable[length]={0};
    for(int i=0;i&amp;lt;length;i++){
            hashtable[a[i]]++;
    }
    vector&amp;lt;int&amp;gt; findData;
    for(int i=0;i&amp;lt;length;i++){
        if(hashtable[a[i]]&amp;gt;1)//需要去重
        {
            findData.push_back(a[i]);
        }

    }
    //重複過程
    vector&amp;lt;int&amp;gt;::iterator iter=findData.begin();
    iter=unique(findData.begin(),findData.end());//只能刪除相鄰的重複元素
    findData.erase(iter,findData.end());

    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;


}
//**********************方法三交換*******************************
/*
O(n)時間找到數組中重複的數字，並且不需要額外分配空間，空間複雜度為O(1)
*/
//如果下標i與在所在的數值不一致，那就交換以數值為下標的數值，前提是這兩個數值不一致，如果不同的下標同一個數字，那就說明找到重複的。
void duplicate3(int *a,int length){
    bool flag=false;
    if(a==NULL ||length&amp;lt;=0){
        return ;
    }
    for(int i=0;i&amp;lt;length;i++){
        if(a[i]&amp;lt;0 || a[i]&amp;gt;length-1)
            return ;
    }

    vector&amp;lt;int&amp;gt; findData;
    for(int i=0;i&amp;lt;length;i++){
        while(a[i]!=i){
            if(a[i]==a[a[i]]){
                    vector&amp;lt;int&amp;gt;::iterator it=find(findData.begin(),findData.end(),a[i]);
                    if(it!=findData.end())//數組中沒有這個元素再放進去，有的話進行下一輪判斷
                        break;
                    findData.push_back(a[i]);
                    flag=true;
                    break;
            }
            //否則就交換以這個數值為下標的數字
            else{
                int temp=a[i];
                a[i]=a[temp];
                a[temp]=temp;
            }
        }
    }


    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;
}
int main()
{
    int a[]={0,0,1,2,2,3,4,4,5,6};
   // duplicate1(a,8);
   //duplicate2(a,10);

    duplicate3(a,10);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;找到數組中任意一個重複的數字，或者所有重複元素 那如果是所有重複的呢？動態數組 數組長度n,數組中的元素在0~n-1之間
&lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在二叉树中找到两个节点的最低公共祖先</title>
    <link href="http://wxjttxs.github.io/2016/05/14/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://wxjttxs.github.io/2016/05/14/在二叉树中找到两个节点的最低公共祖先/</id>
    <published>2016-05-14T12:27:09.000Z</published>
    <updated>2016-05-14T12:38:57.532Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;   /*在二叉樹中找到給定兩個節點的最低公共祖先 lowest common ancestor LCA&lt;br&gt;我們做一個規定：如果a是b的祖先，那麼他倆的LCA是a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;list&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;

struct Node
{
    struct Node *left, *right;
    int key;
};

Node* newNode(int key)
{
    Node *temp = new Node;
    temp-&amp;gt;key = key;
    temp-&amp;gt;left = temp-&amp;gt;right = NULL;
    return temp;
}
//************************方法一遞歸************************

/* 只用一次遍历解决LCA
學號二叉樹，用好遞歸
從root開始遍歷，如果n1,n2有一個與root匹配，那麼root就是LCA。如果都不匹配，遞歸左右子樹，如果
有一個在左子樹，一個在右子樹，那麼root是LCA。如果兩個數都在左子樹，則說明LCA在左子樹，否則在右子樹
*/

// 返回n1和n2的 LCA的指针
// 假设n1和n2都出现在树中
struct Node *findLCA1(struct Node* root, int n1, int n2)
{
    if (root == NULL) return NULL;

    // 只要n1 或 n2 的任一个匹配即可
    //  (注意：如果 一个节点是另一个祖先，则返回的是祖先节点。因为递归是要返回到祖先的 )
    if (root-&amp;gt;key == n1 || root-&amp;gt;key == n2)
        return root;
    // 分别在左右子树查找
    Node *left_lca  = findLCA1(root-&amp;gt;left, n1, n2);
    Node *right_lca = findLCA1(root-&amp;gt;right, n1, n2);
    // 如果都返回非空指针 Non-NULL, 则说明两个节点分别出现了在两个子树中，则当前节点肯定为LCA
    if (left_lca &amp;amp;&amp;amp; right_lca)  return root;
    // 如果一个为空，在说明LCA在另一个子树
    return (left_lca != NULL)? left_lca: right_lca;
}

//************************方法二找到路徑，求路徑的最後一個公共節點****************
//找到給定節點的路徑
bool GetNodePath(Node* pRoot,int key, list&amp;lt;Node*&amp;gt;&amp;amp;path){
    if(pRoot==NULL)
        return false;
    path.push_back(pRoot);//關鍵在於存放節點與判斷的順序
    if(pRoot-&amp;gt;key==key)
        return true;


    //左右子樹是否找到，找到的話，當前節點就在路徑中
    bool found=(GetNodePath(pRoot-&amp;gt;left,key,path) ||GetNodePath(pRoot-&amp;gt;right,key,path));
    if(!found)//沒有找到就彈出
         path.pop_back();
    return found;

}
//查看路徑上的節點
void PrintPath(list&amp;lt;Node*&amp;gt;&amp;amp;path){
    Node* pLast=NULL;
    list&amp;lt;Node*&amp;gt;::const_iterator iter1=path.begin();
    while(iter1!=path.end()){

        pLast=*iter1;
        cout&amp;lt;&amp;lt;pLast-&amp;gt;key&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        iter1++;
    }
    cout&amp;lt;&amp;lt;endl;
}
//得到兩條路上的最後一個公共節點
Node* GetLastCommonNode(const list&amp;lt;Node*&amp;gt;&amp;amp; path1,const list&amp;lt;Node*&amp;gt;&amp;amp; path2){
    list&amp;lt;Node*&amp;gt;::const_iterator iter1=path1.begin();
    list&amp;lt;Node*&amp;gt;::const_iterator iter2=path2.begin();
    Node* pLast=NULL;

    while(iter1!=path1.end() &amp;amp;&amp;amp; iter2!=path2.end()){
        if(*iter1==*iter2)
            pLast=*iter1;
        iter1++;
        iter2++;
    }
    return pLast;
}
//找到兩個指點節點的最低公共祖先（根節點的祖先是他自己）
Node* findLCA2(Node* pRoot, int key1,int key2){
    list&amp;lt;Node*&amp;gt; path1;
    list&amp;lt;Node*&amp;gt; path2;
    if(pRoot==NULL )//輸入無效，找不到
    {

        return NULL;
    }

    if(GetNodePath(pRoot,key1,path1) &amp;amp;&amp;amp;  GetNodePath(pRoot,key2,path2))
            return GetLastCommonNode(path1,path2);


}

//测试
int main()
{
    // 构造上面图中的树
    Node * root = newNode(1);
    root-&amp;gt;left = newNode(2);
    root-&amp;gt;right = newNode(3);
    root-&amp;gt;left-&amp;gt;left = newNode(4);
    root-&amp;gt;left-&amp;gt;right = newNode(5);
    root-&amp;gt;right-&amp;gt;left = newNode(6);
    root-&amp;gt;right-&amp;gt;right = newNode(7);
//    cout &amp;lt;&amp;lt; &amp;quot;LCA(4, 5) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 4, 5)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(4, 6) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 4, 6)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(3, 4) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 3, 4)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(2, 4) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 2, 4)-&amp;gt;key;

  // cout&amp;lt;&amp;lt;endl;


    Node* p1=NULL;Node* p2=NULL;

    p1= findLCA1(root,6,7);
    p2= findLCA2(root,6,7);
    cout&amp;lt;&amp;lt;&amp;quot;last node1:&amp;quot;&amp;lt;&amp;lt;p1-&amp;gt;key&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;last node2:&amp;quot;&amp;lt;&amp;lt;p2-&amp;gt;key&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;   /*在二叉樹中找到給定兩個節點的最低公共祖先 lowest common ancestor LCA&lt;br&gt;我們做一個規定：如果a是b的祖先，那麼他倆的LCA是a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串转换为整型</title>
    <link href="http://wxjttxs.github.io/2016/05/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E5%BD%A2/"/>
    <id>http://wxjttxs.github.io/2016/05/14/字符串转换为整形/</id>
    <published>2016-05-14T08:23:03.000Z</published>
    <updated>2016-05-14T08:23:43.725Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//不用atoi，实现字符串转数字 //考虑边界：字符串NULL，正负号，int 型最大0x7fffffff,负数最小0x80000000&lt;br&gt;//区分“0”的输出结果和无效字符串的输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
enum Status {kValid=0, kInvalid};
int g_nStatus=kValid;//输出状态
long long StrToIntCore(const char* str, bool minuss){
    long long num=0;
    while(*str!=&amp;apos;\0&amp;apos;){
        if(*str&amp;gt;=&amp;apos;0&amp;apos; &amp;amp;&amp;amp; *str&amp;lt;=&amp;apos;9&amp;apos;){//有效数字
            int flag=minuss?-1:1;
            num=num*10+flag*(*str-&amp;apos;0&amp;apos;);

            if((!minuss &amp;amp;&amp;amp; num&amp;gt;0x7fffffff)||(minuss &amp;amp;&amp;amp; num&amp;lt;(signed int)0x80000000)){//超过long long表示范围,注意signed int
                num=0;
                break;
            }
            str++;
        }
        else{//非法输入
            num=0;
            break;
        }
    }
    if(*str==&amp;apos;\0&amp;apos;)//字符串为空
    {
        g_nStatus=kValid;
    }
    return num;
}
int StrToInt(const char* str){
    g_nStatus=kInvalid;
    long long num=0;

    if(str!=NULL &amp;amp;&amp;amp; *str !=&amp;apos;\0&amp;apos;){
        bool minuss=false;//正负号
        if(*str==&amp;apos;+&amp;apos;)
            str++;
        else if(*str==&amp;apos;-&amp;apos;){
            str++;
            minuss=true;
        }
        if(*str!=&amp;apos;\0&amp;apos;){
            num=StrToIntCore(str,minuss);
        }
    }
    return (int)num;
}
int main()
{
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;-123&amp;quot;) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;+123&amp;quot;) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;0&amp;quot;) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; StrToInt(&amp;quot;&amp;quot;) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//不用atoi，实现字符串转数字 //考虑边界：字符串NULL，正负号，int 型最大0x7fffffff,负数最小0x80000000&lt;br&gt;//区分“0”的输出结果和无效字符串的输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1+2+3..+n</title>
    <link href="http://wxjttxs.github.io/2016/05/13/1-2-3-n/"/>
    <id>http://wxjttxs.github.io/2016/05/13/1-2-3-n/</id>
    <published>2016-05-13T09:59:06.000Z</published>
    <updated>2016-05-13T09:59:38.606Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//���ó˳���for�� while��if else��switch caseʵ��1+2+����+n //��Ȼ���͹�ʽ�Ͳ�������&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//***********************��һ�����ù��캯������*****************************
class Temp{
public:
    Temp(){++N; Sum+=N;}
    static void Reset() {N=0;Sum=0;}
    static unsigned int GetSum(){return Sum;}
private:
    static unsigned int N;
    static unsigned int Sum;

};
unsigned int Temp::N=0;
unsigned int Temp::Sum=0;
unsigned int Sum_Solution1(unsigned int n)
{
    Temp::Reset();
    Temp *a= new Temp[n];//���ù��캯��n��
    delete[] a;
    a=NULL;
    return Temp::GetSum();

}
//***********************�ڶ��������麯������*****************************
//�麯�������������ж���������ͬ���ĺ��������ҿ���ͨ������ָ�������������ʻ������������е�ͬ������
//��������������һ���ݹ飬һ����ֹ�ݹ飬���Ǵ��ж�ѡһ���� ����������ͨ��!!n����ֵת���ɲ����͡�
class A;
A * Array[2];
class A{
public:
    virtual unsigned int Sum(unsigned int n){
        return 0;
    }
};
class B :public A{
public:
    virtual unsigned int Sum(unsigned int n){
        return Array[!!n]-&amp;gt;Sum(n-1)+n;//�Ӻ���ǰ��ʼ��
    }
};
//���麯��ʵ�ֺ�����ѡ�񣬵���ֵ��Ϊ0ѡ��B::Sum()��n=0ѡ��A::Sum()
int Sum_Solution2(int n){
    A a;
    B b;
    Array[0]=&amp;amp;a;
    Array[1]=&amp;amp;b;

    int value=Array[1]-&amp;gt;Sum(n);
    return value;
}
//***********************���������ú���ָ������*****************************
//�ڴ�C���ԵĻ����У�����ʹ���麯������ʱ�����ú���ָ����ģ��
typedef unsigned int (*fun) (unsigned int);
unsigned int Sum_Solution3_Teminator(unsigned int n){
    return 0;
}
unsigned int Sum_Solution3(unsigned int n){
    static fun f[2]={Sum_Solution3_Teminator,Sum_Solution3};//��ʵ����һά����
    return n+f[!!n](n-1);
}
//***********************������ģ����������*******************************
template &amp;lt;unsigned int n&amp;gt; struct Sum_Solution4{
    enum Value {N=Sum_Solution4&amp;lt;n-1&amp;gt;::N+n};
};
template &amp;lt;&amp;gt; struct Sum_Solution4&amp;lt;1&amp;gt;{
    enum Value {N=1};
};
int main()
{
   cout&amp;lt;&amp;lt; Sum_Solution4&amp;lt;100&amp;gt;::N;//���ֵ��÷����ܶ���
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//���ó˳���for�� while��if else��switch caseʵ��1+2+����+n //��Ȼ���͹�ʽ�Ͳ�������&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iost
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不用四则运算，实现两数相加</title>
    <link href="http://wxjttxs.github.io/2016/05/13/%E4%B8%8D%E7%94%A8%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://wxjttxs.github.io/2016/05/13/不用四则运算，实现两数相加/</id>
    <published>2016-05-13T09:03:53.000Z</published>
    <updated>2016-05-13T09:15:16.958Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//不用四则运算实现两数相加 //分成三步：首先两数相加不进位；然后对应位上的进位，最后把前两部的结果相加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int GetSum(int a,int b){
    int sum=0;int carryy=0;
    do{
        sum=a^b;//第一步
        carryy=(a&amp;amp;b)&amp;lt;&amp;lt;1;//第二步
        a=sum;//第三步
        b=carryy;//第三步

    }while(b);
    return a;
}
int main()
{
    cout&amp;lt;&amp;lt;GetSum(5,8);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//不用四则运算实现两数相加 //分成三步：首先两数相加不进位；然后对应位上的进位，最后把前两部的结果相加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespac
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>圆圈剩下的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E5%9C%86%E5%9C%88%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/09/圆圈剩下的数字/</id>
    <published>2016-05-09T15:16:13.000Z</published>
    <updated>2016-05-09T15:16:37.526Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//从0~n-1这n个数字构成环形，从0开始每次删除第m个数字，求最后一个剩下的数字 //要么借助环形链表数据结构&lt;br&gt;//要么通过数学建模找到规律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;list&amp;gt;
using namespace std;
//**********************方法一环形结构****************************
//std::list本身并不是一个环形结构，因此每当迭代器扫描到末尾时候，我们要把迭代器移到链表头部，
//Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢.
int LastRemaining(unsigned int n,unsigned int m){
    if(n&amp;lt;1 || m&amp;lt;1)
        return -1;
    unsigned int i=0;
    list&amp;lt;int&amp;gt; numbers;
    for(i=0;i&amp;lt;n;i++)
        numbers.push_back(i);//0~n-1
    list&amp;lt;int&amp;gt;::iterator current=numbers.begin();
    while(numbers.size()&amp;gt;1){
        for(int i=1;i&amp;lt;m;i++){//找到第m个要删除的位置
            current++;//current指向要删除的位置
            if(current==numbers.end())
                current=numbers.begin();

        }
        list&amp;lt;int&amp;gt;::iterator next=++current;
        if(next==numbers.end())
            next=numbers.begin();
        --current;
        numbers.erase(current);
        current=next;
    }
    return *(current);
}
//**********************方法二数学建模****************************
//令f(n,m)表示从0开始删除第m个数字后的剩下的数字；第一个删除的数字是（m-1)%n，为了简单表示，我们令k=（m-1)%n。剩下的数字0,1,2，，，，k-1,k+1,k+2..n-1;
//下一次从k+1开始计数。相当于形成这样的序列：k+1,k+2...0,1...k-1。剩下的序列也是关于n,m的函数。但是这个序列的规律和最初的规律不一样。因此记为f&amp;apos;(n-1,m).
//最初序列剩下的数字一定是删除一个数字之后的序列最后剩下的数字，即f(n,m)=f&amp;apos;(n-1,m).
//定义一种映射 ，使得k+1,k+2...0,1...k-1 -》0,1.。。n-2，p(x)=(x-k-1)%n.逆映射p&amp;apos;(x)=(x+k+1)%n
//f(n,m)=f&amp;apos;(n-1,m)=p&amp;apos;(f(n-1,m))=[f(n-1,m)+k+1]%n=[f(n-1,m)+m]%n;
//综上，递归公式：f(n,m)=0   n=1
//                      =[f(n-1,m)+m]%n  n&amp;gt;1

int LastRemaining(unsigned int n,unsigned int m){
    if(n&amp;lt;1 ||m&amp;lt;1)
        return -1;
    int last=0;
    for(int i=2;i&amp;lt;=n;i++)
        last=(last+m)%i;
    return last;
}
int main()
{
    int data[]={3,4,5,6,7,8};
    for(int i=0;i&amp;lt;6;i++)

        cout&amp;lt;&amp;lt;LastRemaining(data[i],3)&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//从0~n-1这n个数字构成环形，从0开始每次删除第m个数字，求最后一个剩下的数字 //要么借助环形链表数据结构&lt;br&gt;//要么通过数学建模找到规律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostre
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扑克牌是不是顺子</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E6%89%91%E5%85%8B%E7%89%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E9%A1%BA%E5%AD%90/"/>
    <id>http://wxjttxs.github.io/2016/05/09/扑克牌是不是顺子/</id>
    <published>2016-05-09T10:33:45.000Z</published>
    <updated>2016-05-09T10:34:19.965Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//从扑克牌中抽出五张，判断是不是顺子，A用1表示；JQK用11,12,13表示；大小王看成任意数字&lt;br&gt;//首先排序数组，然后统计0的个数和数组中间隔数，如果0的个数&amp;gt;=间隔，返回true。&lt;br&gt;//还有需要注意，如果数组中有两个数字相同，那么不可能是顺子了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

int compare(const void *arg1,const void *arg2){
    return *(int*)arg1-*(int*)arg2;
}
bool IsContinuous(int *data,int length){
    if(data==NULL ||length&amp;lt;1)
        return false;

    qsort(data,length,sizeof(int),compare);//排序

    int numberOfZero=0;//0的个数，间隔的数目
    int numberOfGap=0;

    //统计0的个数
    for(int i=0;i&amp;lt;length;i++){
        if(data[i]==0)
            numberOfZero++;
    }
    //统计间隔数目
    int small=numberOfZero;//必须从这个开始，因为0不能算在这个里面，代表的是任意
    int big=small+1;
    while(big&amp;lt;length){
        //两个数相等，对子不可能是顺子
        if(data[small]==data[big])
            return false;
        numberOfGap+=data[big]-data[small]-1;//比如 1  3   4  5
        small=big;//两个指针，依次往后挪
        big++;
    }
    return (numberOfGap&amp;lt;=numberOfZero)?true:false;

}
int main()
{
    int data[]={2,4,5,6,0};
    cout&amp;lt;&amp;lt;IsContinuous(data,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//从扑克牌中抽出五张，判断是不是顺子，A用1表示；JQK用11,12,13表示；大小王看成任意数字&lt;br&gt;//首先排序数组，然后统计0的个数和数组中间隔数，如果0的个数&amp;gt;=间隔，返回true。&lt;br&gt;//还有需要注意，如果数组中有两个数字相
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>n个骰子和为S的次数以及相应的概率</title>
    <link href="http://wxjttxs.github.io/2016/05/09/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E5%92%8C%E4%B8%BAS%E7%9A%84%E6%AC%A1%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%BA%94%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <id>http://wxjttxs.github.io/2016/05/09/n个骰子和为S的次数以及相应的概率/</id>
    <published>2016-05-09T09:10:41.000Z</published>
    <updated>2016-05-09T09:11:12.215Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//把n个骰子扔地上，所有骰子朝上一面的点数之和为 S。输入n,打印出S中所有可能出现的值的概率。&lt;br&gt;//动态规划.找到最优子结构。采用备忘录的方法避免重复计算。&lt;br&gt;//最优子结构：f(n,s)表示n个骰子点数和为S的种类，N表示骰子个数，S表示N个骰子的点数和&lt;br&gt;//F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)+F(n-1,s-6)&lt;br&gt;n&amp;gt;0,n&amp;lt;=S&amp;lt;=6&lt;em&gt;n //      =0  n&amp;gt;S  or  S&amp;gt;6&lt;/em&gt;k&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int FACE_NUM=6;//骰子的面数
//函数功能：N个骰子的向上一面的和
//函数参数：骰子数目

void PrintSumProbabilityOfDices(int n){
    if(n&amp;lt;=0)
        return;
    int *pSum=new int[n*FACE_NUM+1];//和的种类
    double total=pow(6.0,n);//和的所有可能性
    int sizee=n*FACE_NUM;
    int i,j,k;
    //初始化
    pSum[0]=0;//没有骰子
    for(i=1;i&amp;lt;=FACE_NUM;i++)
        pSum[i]=1;//只有一个骰子,和的可能性为1~6，只可能出现一次
    for(;i&amp;lt;=sizee;i++)
        pSum[i]=0;//数组初始化0
    for(i=2;i&amp;lt;=n;i++){//骰子数目从2~n
        for(j=i*FACE_NUM;j&amp;gt;=i;j--){//i个骰子和的范围是i~i*FACE_NUM，j代表的是可能的和的种类
            pSum[j]=0;//每次要清零
            for(k=1;k&amp;lt;=6 &amp;amp;&amp;amp; j&amp;gt;=k;k++){//这个就是F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)+F(n-1,s-6)
                pSum[j]+=pSum[j-k];
            }
        }
        //不可能的情况
        for(j=i-1;j&amp;gt;=0;j--)
            pSum[j]=0;
    }
   //打印结果
   for(i=0;i&amp;lt;=sizee;i++){
        cout&amp;lt;&amp;lt;&amp;quot;sum= &amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot;, p= &amp;quot;&amp;lt;&amp;lt;pSum[i]/total&amp;lt;&amp;lt;endl;
   }
}
int main()
{
    PrintSumProbabilityOfDices(3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//把n个骰子扔地上，所有骰子朝上一面的点数之和为 S。输入n,打印出S中所有可能出现的值的概率。&lt;br&gt;//动态规划.找到最优子结构。采用备忘录的方法避免重复计算。&lt;br&gt;//最优子结构：f(n,s)表示n个骰子点数和为S的种类，N表示骰子个数，
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>翻转单词顺序 VS 左旋转字符串</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F-VS-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wxjttxs.github.io/2016/05/09/翻转单词顺序-VS-左旋转字符串/</id>
    <published>2016-05-09T03:01:09.000Z</published>
    <updated>2016-05-09T08:10:16.222Z</updated>
    
    <content type="html">&lt;p&gt;//一个字符串。要求翻转单词顺序，但是单词内部字符顺序不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string.h&amp;gt;
using namespace std;
//翻转一个单词
void Reverse(char* pBegin,char* pEnd){
    if(pBegin==NULL || pEnd==NULL)
        return;
    while(pBegin&amp;lt;pEnd){
        char temp=*pBegin;
        *pBegin=*pEnd;
        *pEnd=temp;
        pBegin++;
        pEnd--;
    }
}
char* ReverseSentence(char *pData)
{
    if(pData == NULL)
        return NULL;

    char *pBegin = pData;

    char *pEnd = pData+strlen(pData)-1;

    // 翻转整个句子
    Reverse(pBegin, pEnd);

    // 翻转句子中的每个单词
    pBegin = pEnd = pData;
    while(*pEnd!=&amp;apos;\0&amp;apos;){
        if(*pEnd!=&amp;apos; &amp;apos;)
            pEnd++;
        else{
            Reverse(pBegin,pEnd-1);//空格前一个
            pBegin=++pEnd;//pBegin指向空格后一个
        }
    }
    Reverse(pBegin,pEnd-1);//最后一个单词，pEnd指向&amp;apos;\0&amp;apos;
    return pData;
}

//********************左旋转n位字符**************************
//前n位看做空格前字母，比如“hello world”
char* LeftRotateString(char* pStr,int n){
    if(pStr!=NULL){
        int length=static_cast&amp;lt;int&amp;gt;(strlen(pStr));
        if(length&amp;gt;0 &amp;amp;&amp;amp; n&amp;gt;0 &amp;amp;&amp;amp;n&amp;lt;length){//输入是有效的
            char* pFirstBegin=pStr;
            char* pFirstEnd=pStr+n-1;
            char* pSecondBegin=pStr+n;
            char* pSecondEnd=pStr+length-1;
            Reverse(pFirstBegin,pFirstEnd);//旋转第一段
            Reverse(pSecondBegin,pSecondEnd);//旋转第二段
            Reverse(pFirstBegin,pSecondEnd);//旋转整个单词
        }
    }
    return pStr;
}
int main()
{
      char sentence[]=&amp;quot;stu dent!&amp;quot;;
      char *reverced=ReverseSentence(sentence);
      cout&amp;lt;&amp;lt;reverced&amp;lt;&amp;lt;endl;

      char sentence1[]=&amp;quot;abcdefg&amp;quot;;
      char *reverced1=LeftRotateString(sentence1,7);
     // char *reverced1=LeftRotateString(“abcdef”,2);不承认这样的赋值方式
      cout&amp;lt;&amp;lt;reverced1&amp;lt;&amp;lt;endl;
      return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//一个字符串。要求翻转单词顺序，但是单词内部字符顺序不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string.h&amp;gt;
using namespace std;
//翻转一个单词
void Revers
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>和为S，输出数组的子序列</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E5%92%8C%E4%B8%BAS%EF%BC%8C%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/05/09/和为S，输出数组的子序列/</id>
    <published>2016-05-09T02:57:04.000Z</published>
    <updated>2016-05-09T02:58:07.869Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//数组已经排好序，假设升序。
//当给定和为S,返回数组中两个数使得他们和为s


#include &amp;lt;iostream&amp;gt;

using namespace std;
//找到排序数组和为S的两个数
//void FindNumbersWithSum(int *data,int length,int s){
//    bool flag=false;
//    if(data==NULL ||length&amp;lt;1)
//        return;
//    int ahead=0;
//    int behind=length-1;
//    while(ahead&amp;lt;behind){
//        if(data[ahead]+data[behind]==s){
//            flag=true;
//            break;//找到就跳出循环，不然就死了
//        }
//        else if(data[ahead]+data[behind]&amp;gt;s)
//            behind--;
//        else
//            ahead++;
//    }
//    if(flag){
//        cout&amp;lt;&amp;lt;data[ahead]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;data[behind];
//    }
//    else
//        cout&amp;lt;&amp;lt;&amp;quot;not found&amp;quot;&amp;lt;&amp;lt;endl;
//}
//************拓展*********************************8
//找到连续正数序列（1,2,3.。。。。S）中和为S的序列，打印出来,至少为3
void PrintContinueSequence(int small, int big){
    for(int i=small;i&amp;lt;=big;i++)
        cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;
}
void FindContinueSequence(int sum){
    if(sum&amp;lt;3)
        return ;
    int small=1;
    int big=2;
    int mid=(sum+1)/2;//因为是递增，所以最小的数不可能超过中间值
    int curSum=small+big;
    while(small&amp;lt;mid){
        if(curSum==sum){
            PrintContinueSequence(small,big);
        }
        while(curSum&amp;gt;sum &amp;amp;&amp;amp; small&amp;lt;mid){
            curSum-=small;//先减去已经在里面的小的数值
            small++;

            if(curSum==sum)
                PrintContinueSequence(small,big);
        }
        big++;
        curSum+=big;//后加上不在里面的大的数值
    }
}
int main()
{
//    int data[]={1,2,3,7,11,15};
//    FindNumbersWithSum(data,6,1);
      FindContinueSequence(13);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//数组已经排好序，假设升序。
//当给定和为S,返回数组中两个数使得他们和为s


#include &amp;lt;iostream&amp;gt;

using namespace std;
//找到排序数组和为S的两个数
//void FindNumbersWith
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组中只出现一次的两个数字</title>
    <link href="http://wxjttxs.github.io/2016/05/09/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/09/数组中只出现一次的两个数字/</id>
    <published>2016-05-09T02:16:17.000Z</published>
    <updated>2016-05-09T02:17:14.185Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//这样的数组：只有两个数字只出现一次，其他数字出现两次。输出只出现一次的数字&lt;br&gt;//如果是只出现一次的数字有一个，那么异或整个数组元素，得到的结果恰好就是那个单独的元素&lt;br&gt;//所以把原始数组分成两个子数组。每个子数组只包含一个只出现一次的数字。&lt;br&gt;//先异或整个数组元素，得到不是0的结果，化成二进制，找到第一个1的位置index，然后把原数组按照这个index是不是1来分开。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

//最右边1的位置
unsigned int FindFirst1Bit(int num);
//从右边数起的indexBit位是不是1
bool IsBit1(int num,unsigned int indexBit);
//主要实现
void FindNumberAppearOnce(int *data,int length){
    if(data==NULL || length&amp;lt;2)//,int &amp;amp;num1,int &amp;amp;num2
        return ;
    int resExclusiveOr=0;
    for(int i=0;i&amp;lt;length;i++){
        resExclusiveOr^=data[i];
    }
    unsigned int indexOf1=FindFirst1Bit(resExclusiveOr);//根据异或结果找到右边起第一个1
    int num[2]={0};
   // num1=num2=0;//两个只出现一次的数字
    for(int j=0;j&amp;lt;length;j++){
        if(IsBit1(data[j],indexOf1))
            num[0]^=data[j];
        else
            num[1]^=data[j];
    }
    for(int i=0;i&amp;lt;2;i++)
        cout&amp;lt;&amp;lt; num[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
}
//找到最右边第一个1的位置
unsigned int FindFirst1Bit(int num){
    int indexBit=0;
    while(((num&amp;amp;1)==0) &amp;amp;&amp;amp; (indexBit&amp;lt;8 * sizeof(int))){
        num=num&amp;gt;&amp;gt;1;
        ++indexBit;
    }
    return  indexBit;
}
//从右边起indexBit位是不是1
bool IsBit1(int num,unsigned int indexBit){
    num=num&amp;gt;&amp;gt;indexBit;
    return (num&amp;amp;1);
}
int main()
{
    int data[]={2,4,3,6,3,2,5,5};
   // int a,b;
    FindNumberAppearOnce(data,8);
  //  cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;b;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//这样的数组：只有两个数字只出现一次，其他数字出现两次。输出只出现一次的数字&lt;br&gt;//如果是只出现一次的数字有一个，那么异或整个数组元素，得到的结果恰好就是那个单独的元素&lt;br&gt;//所以把原始数组分成两个子数组。每个子数组只包含一个只出现一次的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>是不是平衡树</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/08/是不是平衡树/</id>
    <published>2016-05-08T14:40:57.000Z</published>
    <updated>2016-05-08T14:41:33.443Z</updated>
    
    <content type="html">&lt;p&gt;//平衡二叉树的概念：左右子树的深度相差不超过1&lt;br&gt;//判断一棵二叉树是不是平衡二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//构建二叉树
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
//*****************方法一****************************
////二叉树的深度
//    int TreeDepth(BinaryTreeNode* pRoot){
//        if(!pRoot)
//            return 0;
//    //    if(!pRoot-&amp;gt;m_pLeft &amp;amp;&amp;amp; !pRoot-&amp;gt;m_pRight)//不需要
//    //        return 1;
//
//        //else{
//            int nLeft=TreeDepth(pRoot-&amp;gt;m_pLeft);
//            int nRight=TreeDepth(pRoot-&amp;gt;m_pRight);
//            return (nLeft&amp;gt;nRight)?(nLeft+1):(nRight+1);
//      //  }
//
//    }
//bool IsBalanced(BinaryTreeNode* pRoot){
//    if(pRoot==NULL)
//        return true;
//    int left=TreeDepth(pRoot-&amp;gt;m_pLeft);
//    int right=TreeDepth(pRoot-&amp;gt;m_pRight);
//    int diff= left-right;
//    if(diff&amp;gt;1 ||diff&amp;lt;-1)
//        return false;
//    return IsBalanced(pRoot-&amp;gt;m_pLeft)&amp;amp;&amp;amp;IsBalanced(pRoot-&amp;gt;m_pRight);
//}
//***********************方法二***********************88
//每个节点遍历一遍，就能判断二叉树是不是平衡的；采用后序遍历,遍历一个节点的时候，它的左右子树已经遍历过了。
//在遍历节点的时候记录 它的深度，就能一边遍历，一边判断每个节点是不是平衡的
bool IsBalancedCore(BinaryTreeNode* pRoot, int* pDepth){
    if(pRoot==NULL){
        *pDepth=0;
        return true;
    }
    int left,right;
    if(IsBalancedCore(pRoot-&amp;gt;m_pLeft,&amp;amp;left)&amp;amp;&amp;amp; IsBalancedCore(pRoot-&amp;gt;m_pRight,&amp;amp;right)){
        int diff=left-right;
        if(diff&amp;lt;=1 &amp;amp;&amp;amp; diff&amp;gt;=-1){
            *pDepth=1+(left&amp;gt;right?left:right);
            return true;
        }
    }
    return false;
}
bool IsBalanced(BinaryTreeNode* pRoot){
    int depth=0;
    return IsBalancedCore(pRoot,&amp;amp;depth);
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    cout&amp;lt;&amp;lt;IsBalanced(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//平衡二叉树的概念：左右子树的深度相差不超过1&lt;br&gt;//判断一棵二叉树是不是平衡二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的深度</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/08/二叉树的深度/</id>
    <published>2016-05-08T13:40:22.000Z</published>
    <updated>2016-05-08T13:41:04.539Z</updated>
    
    <content type="html">&lt;p&gt;//查找二叉树的深度，也就是从根节点到叶子节点所有路径中，最长路径的节点数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//构建二叉树
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
//二叉树的深度：如果树只有一个节点，那么树的深度就是1；如果没有右子树，
//那么就等于左子树的深度+1；没有左子树的情况类似；如果左右子树都存在，那么就等于两个子树路径较大的那个+1
int TreeDepth(BinaryTreeNode* pRoot){
    if(!pRoot)
        return 0;
//    if(!pRoot-&amp;gt;m_pLeft &amp;amp;&amp;amp; !pRoot-&amp;gt;m_pRight)//不需要
//        return 1;

    //else{
        int nLeft=TreeDepth(pRoot-&amp;gt;m_pLeft);
        int nRight=TreeDepth(pRoot-&amp;gt;m_pRight);
        return (nLeft&amp;gt;nRight)?(nLeft+1):(nRight+1);
  //  }

}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    cout&amp;lt;&amp;lt;TreeDepth(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//查找二叉树的深度，也就是从根节点到叶子节点所有路径中，最长路径的节点数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nV
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>指定数字在排序数组中出现的次数</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/08/指定数字在排序数组中出现的次数/</id>
    <published>2016-05-08T13:05:56.000Z</published>
    <updated>2016-05-08T13:06:20.332Z</updated>
    
    <content type="html">&lt;p&gt;//得到已经排序的数组中指定数字k出现的次数&lt;br&gt;//已经排好序，所以想到用二分查找算法；&lt;br&gt;//重复次数=最后一次出现的位置-第一次出现的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int GetFirstK(int *data,int length,int k, int start,int endd){
    if(start&amp;gt;endd)
        return -1;
    int mid=(start+endd)/2;//一分为二
    int midData=data[mid];
    if(midData==k){//中间恰好等于k，那么第一个k的位置要么就是这个中间；要么位于前半段数组
        if((data[mid-1]!=k &amp;amp;&amp;amp; mid&amp;gt;0) || mid==0)
            return mid;
        else
            endd=mid-1;
    }
    else if(midData&amp;gt;k)
        endd=mid-1;
    else
        start=mid+1;
    return GetFirstK(data,length,k,start,endd);
}
int GetLastK(int *data,int length,int k,int start, int endd){
    if(data==NULL||start&amp;gt;endd)
        return -1;
    int mid=(start+endd)/2;//一分为二
    int midData=data[mid];
    if(midData==k){//中间恰好等于k，那么最后一个k的位置要么就是这个中间；要么位于后半段数组
        if((data[mid+1]!=k &amp;amp;&amp;amp; mid+1&amp;lt;length) || mid+1==length){
            return mid;
        }
        else
            start=mid+1;
    }
    else if(midData&amp;lt;k){
        start =mid+1;
    }
    else
        endd=mid-1;
    return GetLastK(data,length,k,start,endd);

}
int GetKNumbers(int *data,int length,int k){
    if(!data || length&amp;lt;=0)
        return -1;
    int number=0;
    int first=GetFirstK(data,length,k,0,length-1);
    int endd=GetLastK(data,length,k,0,length-1);
    if(first&amp;gt;-1 &amp;amp;&amp;amp; endd&amp;gt;-1)
        number= endd-first+1;
    return number;
}
int main()
{
    int data[]={1,2,3,3,3,3,4,5};
    cout&amp;lt;&amp;lt;GetKNumbers(data,8,1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//得到已经排序的数组中指定数字k出现的次数&lt;br&gt;//已经排好序，所以想到用二分查找算法；&lt;br&gt;//重复次数=最后一次出现的位置-第一次出现的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>两个链表的第一个公共节点</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/08/两个链表的第一个公共节点/</id>
    <published>2016-05-08T07:06:14.000Z</published>
    <updated>2016-05-08T07:06:54.040Z</updated>
    
    <content type="html">&lt;p&gt;//得到两个链表第一个公共节点并返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}

unsigned int GetListLength(ListNode* pHead);

int FindFirstCommonNode( ListNode *pHead1, ListNode *pHead2)
{
    // 得到两个链表的长度
    unsigned int nLength1 = GetListLength(pHead1);
    unsigned int nLength2 = GetListLength(pHead2);
    int nLengthDif = nLength1 - nLength2;

    ListNode* pListHeadLong = pHead1;
    ListNode* pListHeadShort = pHead2;
    if(nLength2 &amp;gt; nLength1)
    {
        pListHeadLong = pHead2;
        pListHeadShort = pHead1;
        nLengthDif = nLength2 - nLength1;
    }

    // 先在长链表上走几步，再同时在两个链表上遍历
    for(int i = 0; i &amp;lt; nLengthDif; ++ i)
        pListHeadLong = pListHeadLong-&amp;gt;m_pNext;

    while((pListHeadLong != NULL) &amp;amp;&amp;amp;
        (pListHeadShort != NULL) &amp;amp;&amp;amp;
        (pListHeadLong-&amp;gt;m_nValue != pListHeadShort-&amp;gt;m_nValue))
    {
        pListHeadLong = pListHeadLong-&amp;gt;m_pNext;
        pListHeadShort = pListHeadShort-&amp;gt;m_pNext;
    }
    if(!pListHeadLong &amp;amp;&amp;amp; !pListHeadShort)//没有公共节点

        return 0;
    if(pListHeadLong-&amp;gt;m_nValue == pListHeadShort-&amp;gt;m_nValue){
        ListNode* pFisrtCommonNode = pListHeadLong;// 得到第一个公共结点
        return pFisrtCommonNode-&amp;gt;m_nValue;
    }


}

unsigned int GetListLength(ListNode* pHead)
{
    unsigned int nLength = 0;
    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        ++ nLength;
        pNode = pNode-&amp;gt;m_pNext;
    }

    return nLength;
}

int main()
{
    List l1=NULL;
    Insert(l1,7);
    Insert(l1,6);
    Insert(l1,3);
    Insert(l1,2);
    Insert(l1,1);
    Print(l1);


    List l2=NULL;
    Insert(l2,7);
    Insert(l2,7);
    Insert(l2,5);
    Insert(l2,4);
    Print(l2);
    int tmp=FindFirstCommonNode(l1,l2);
    cout&amp;lt;&amp;lt;tmp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//得到两个链表第一个公共节点并返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef struct ListNode{
    int
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>逆序对</title>
    <link href="http://wxjttxs.github.io/2016/05/07/post%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/07/post逆序对/</id>
    <published>2016-05-07T09:00:04.000Z</published>
    <updated>2016-05-08T11:56:14.493Z</updated>
    
    <content type="html">&lt;p&gt;//一个数组中的元素构成的逆序对数目&lt;br&gt;//分治法，递归，类似于堆排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int InversePairsCore(int* data, int* cpy,int start, int endd){
    if(start==endd){
        cpy[start]=data[start];
        return 0;
    }
    int half_len=(endd-start)/2;
    int left=InversePairsCore(cpy,data,start,start+half_len);//子数组内部构成的逆序对,有两步操作：1是统计逆序对数目；2是排序（方便计算子数组间的逆序数数目）
    int right=InversePairsCore(cpy,data,start+half_len+1,endd);//注意前两个参数的顺序。第一个参数代表的是排好序的数组。

    int i=start+half_len;//子数组之间的逆序对,子数组是有序的
    int j=endd;
    int cpyIndex=endd;
    int countt=0;
    while(i&amp;gt;=start &amp;amp;&amp;amp; j&amp;gt;=start+half_len+1){
         if(data[i]&amp;gt;data[j]){
            cpy[cpyIndex--]=data[i--];//从右往左，从大往小放进辅助数组中
            countt+=j-start-half_len;//j代表的右边子数组中大的那个数字,所以它之前的数字均能与左边子数组构成逆序对
         }
         else{
            cpy[cpyIndex--]=data[j--];
         }
    }
    for(;i&amp;gt;=start;i--){//j到头了，终止退出循环
        cpy[cpyIndex--]=data[i];
    }
    for(;j&amp;gt;=start+half_len+1;j--)
        cpy[cpyIndex--]=data[j];
    return left+right+countt;
}
int InversePairs(int *data,int length){
    if(data==NULL||length&amp;lt;=0)
        return 0;
    int *cpy=new int [length];//辅助数组
    for(int i=0;i&amp;lt;length;i++){
        cpy[i]=data[i];
    }
    int countt=InversePairsCore(data,cpy,0,length-1);
    delete[] cpy;
    return countt;
}
int main()
{
    int a[]={7,5,6,4};
    cout &amp;lt;&amp;lt; InversePairs(a,4)&amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//一个数组中的元素构成的逆序对数目&lt;br&gt;//分治法，递归，类似于堆排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int InversePairsCore(int* data, int*
    
    </summary>
    
    
  </entry>
  
</feed>
