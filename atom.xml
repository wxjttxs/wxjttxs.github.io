<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happy happy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxjttxs.github.io/"/>
  <updated>2016-05-02T14:56:39.653Z</updated>
  <id>http://wxjttxs.github.io/</id>
  
  <author>
    <name>王晓静</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>子数组最大和</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://wxjttxs.github.io/2016/05/02/子数组最大和/</id>
    <published>2016-05-02T14:54:25.000Z</published>
    <updated>2016-05-02T14:56:39.653Z</updated>
    
    <content type="html">&lt;p&gt;//数组的最大子数组的和并返回&lt;br&gt;//动态规划分f(i)=pData[i] i=0 or f(i-1)&amp;lt;=0;&lt;br&gt;//f(i)=f(i-1)+pData[i]  i!=0 and f(i-)&amp;gt;0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
bool g_InvalidInput=false;//标记结果0到底是无效输入还是 最大和是0
int FindGreatestSumOfSubArray(int* pData,int nLength){
    if(pData==NULL||nLength&amp;lt;=0){
        g_InvalidInput=true;
        return 0;
    }
    g_InvalidInput=false;
    int nCurSum=0;
    int nGreatestSum=0x80000000;
    for(int i=0;i&amp;lt;nLength;i++){
        if(nCurSum&amp;lt;=0)
            nCurSum=pData[i];
        else
            nCurSum+=pData[i];
        if(nCurSum&amp;gt;nGreatestSum)
            nGreatestSum=nCurSum;
    }


return nGreatestSum;
}

int main()
{
    int a[]={1,-2,3,10,-4,7,2,-5};
    cout&amp;lt;&amp;lt;FindGreatestSumOfSubArray(a,8);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//数组的最大子数组的和并返回&lt;br&gt;//动态规划分f(i)=pData[i] i=0 or f(i-1)&amp;lt;=0;&lt;br&gt;//f(i)=f(i-1)+pData[i]  i!=0 and f(i-)&amp;gt;0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最小的K个数</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E2%80%9C%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%E2%80%9C/"/>
    <id>http://wxjttxs.github.io/2016/05/02/“最小的K个数“/</id>
    <published>2016-05-02T14:24:15.000Z</published>
    <updated>2016-05-02T14:25:53.110Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;vector&amp;gt;

using namespace std;
//0(n)时间找到最小的K个数，而且这K个数是排好序的，但是会修改原始数组
//借鉴快排的划分

//int Partition(int *a, int start ,int ent){
//    if(a==NULL||start&amp;lt;0||ent&amp;lt;0)
//        throw new exception();
//    int temp=a[ent];//最后一个值作为基准
//    int i=start-1;
//    for(int j=start;j&amp;lt;ent;j++){
//        if(a[j]&amp;lt;=temp){
//            i++;
//            swap(a[i],a[j]);
//        }
//    }
//    swap(a[i+1],a[ent]);
//    return i+1;
//}
//void GetLeastNumber(int *input,int n,int k){
//   // int output[k]={0};
//    if(input==NULL||n&amp;lt;=0||k&amp;lt;=0||k&amp;gt;n)
//        return;
//    int start=0;
//    int endt=n-1;
//    int index=Partition(input,start,endt);
//    while(index!=k-1){
//        if(index&amp;lt;k-1){
//            start=index+1;
//           index=Partition(input,start,endt);
//        }
//        else{
//            endt=index-1;
//            index=Partition(input,start,endt);
//        }
//    }
//    for(int i=0;i&amp;lt;=index;i++){
//
//        cout&amp;lt;&amp;lt;input[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
//    }
//    cout&amp;lt;&amp;lt;endl;
//
//}
//int main()
//{
//    int a[]={4,5,1,6,2,7,3,8};
//
//    GetLeastNumber(a,8,6);
//    return 0;
//}

//****************方法二********************************
//上面的时间很快，但是会改变原始数据
//所以用一个k大的容器 来装k个最小值，容器没有满那就直接插入。如果满了，那就做三件事：1.找到容器中最大值；2.删除最大值；3.插入新的数据
//找到最大值，最快的是最大堆，基于红黑树结构实现的set and multiset
typedef multiset&amp;lt;int,greater&amp;lt;int&amp;gt; &amp;gt; intSet;//greater作用实现降序排列
typedef multiset&amp;lt;int ,greater&amp;lt;int&amp;gt; &amp;gt;::iterator setItertor;
void GetLeastNumbers(const vector&amp;lt;int&amp;gt;&amp;amp; data, intSet&amp;amp; leastNumber,int k){
    leastNumber.clear();
    if(k&amp;lt;1||data.size()&amp;lt;k)
        return;
    vector&amp;lt;int&amp;gt;::const_iterator iter=data.begin();
    for(;iter!=data.end();++iter){

        if(leastNumber.size()&amp;lt;k)
            leastNumber.insert(*iter);
        else{
            setItertor iterGreatest=leastNumber.begin();
            if(*iter&amp;lt;*(leastNumber.begin())){
                leastNumber.erase(iterGreatest);
                leastNumber.insert(*iter);
            }
        }
    }
}
int main(){
    int a[8]={4,5,1,6,2,7,3,8};

    vector&amp;lt;int&amp;gt; data(a,a+8);
    intSet leastNumber;
    GetLeastNumbers(data,leastNumber,8);
    cout&amp;lt;&amp;lt;&amp;quot;the actual output numbers are:&amp;quot;&amp;lt;&amp;lt;endl;
    for(setItertor iter=leastNumber.begin();iter!=leastNumber.end();iter++)
        cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;vector&amp;gt;

using namespace std;
//0(n)时间找到最小
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E2%80%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97hexo-new-post-%E2%80%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/02/“数组中出现次数超过一半的数字hexo-new-post-“数组中出现次数超过一半的数字/</id>
    <published>2016-05-02T12:31:42.000Z</published>
    <updated>2016-05-02T12:32:25.888Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//是不是有效输入
bool IsValidMatrix(int * matrix,int length){
    if(matrix==NULL||length&amp;lt;=0)
        return false;
    return  true;
}
//如果出现次数最多的也不能达到数组长度的一半怎么办呢
bool IsMoreThanHalf(int* matrix,int length,int number){//number 是数组中出现次数最大的那个数
    int countt=0;
    for(int i=0;i&amp;lt;length;i++){
        if(matrix[i]==number)
            countt++;
    }
    if(countt*2&amp;lt;length)
        return false;
    return true;
}
int MoreThanHalfNum(int *matrix,int length){
    if(IsValidMatrix(matrix,length)){
        int MaxNumber=matrix[0];
        int times=1;
        for(int i=1;i&amp;lt;length;i++){//此后的数字相同的加1，不同的减1，直到times变成0，从下一个数字开始重头开始这个过程。
            if(times==0){
                MaxNumber=matrix[i];//重新开始  1,2,2
                times=1;
            }
           else if(MaxNumber==matrix[i])
                times++;
            else{

                times--;
            }
        }
        if(IsMoreThanHalf(matrix,length,MaxNumber)){

            return MaxNumber;
        }


        else
            cout&amp;lt;&amp;lt;&amp;quot;无效&amp;quot;;
    }

}
int main()
{
    int a[]={1};
    cout&amp;lt;&amp;lt;MoreThanHalfNum(a,1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//是不是有效输入
bool IsValidMatrix(int * matrix,int length){
    if(matrix==NULL||lengt
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串全排列(去重)以及全组合（2^n-1）</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/05/02/字符串全排列/</id>
    <published>2016-05-02T07:26:54.000Z</published>
    <updated>2016-05-02T11:43:51.677Z</updated>
    
    <content type="html">&lt;p&gt;//实现字符串每个字符 的全排列,并求取全排列的个数&lt;br&gt;//分为三部分：1.首先，求取所有可能出现在第一个位置的字符；&lt;br&gt;//2.其次，把第一个字符和其后面的字符一一交换；&lt;br&gt;//3.接着，固定第一个字符，求后面所有字符的排列。重复步骤2&lt;/p&gt;
&lt;p&gt;   //全排列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
//  调试开关
#define __tmain main

#ifdef __tmain

#define debug cout

#else

#define debug 0 &amp;amp;&amp;amp; cout

#endif // __tmain
class Solution{
protected:
    vector&amp;lt;string&amp;gt; m_res;//字符数组，存储排好序的字符串
public:
    void Permutation(string str){
        int countt=0;
        m_res.clear();
        if(str.empty())
            return ;

        Perm(str,0);

        sort(m_res.begin(),m_res.end());
        //删除容器中重复 元素
        vector&amp;lt;string&amp;gt;::iterator new_end;
        new_end=unique(m_res.begin(),m_res.end());//把重复元素放在容器末尾
        //assert(m_res.size()==N);
        m_res.erase(new_end,m_res.end());//真正删除重复元素
        //输出容器中元素
        vector&amp;lt;string&amp;gt;::iterator iter=m_res.begin();
        for(;iter!=m_res.end();iter++)
        {
            countt++;
            cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;endl;
        }
        cout&amp;lt;&amp;lt;endl;
        cout&amp;lt;&amp;lt;countt&amp;lt;&amp;lt;endl;
       // return m_res;

    }

    void Perm(string str,int Begin){//str要排序的字符串，Begin代表排序部分的第一个字符的位置
        if(str[Begin]==&amp;apos;\0&amp;apos;){//全部已经排好序
           // debug&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl;
            m_res.push_back(str);
        }
        for(int i=Begin;str[i]!=&amp;apos;\0&amp;apos;;i++){
            if(i==Begin||str[i]!=str[Begin]){//排除重复
                swap(str[i],str[Begin]);//排序部分第一个位置的字符全部找到
                Perm(str,Begin+1);//递归排序之后的字符
                swap(str[i],str[Begin]);

            }
        }
    }
};
int __tmain( )
{
    Solution solu;
    solu.Permutation(&amp;quot;abb&amp;quot;);

    return 0;
}


//********************************************************************
//组合。从n个字符中挑选m个字符放到组合当中。有两个方案：第一个字符放到组合当中，剩下的m-1个字符从n-1个字符中挑选，
//另一种方案：第一个字符不放到组合当中，那么从剩下的n-1中挑选m-1个字符放到组合当中
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
#include&amp;lt;assert.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;

void Combination(char *string ,int number,vector&amp;lt;char&amp;gt; &amp;amp;result);

void Combination(char *string)
{
    assert(string != NULL);
    vector&amp;lt;char&amp;gt; result;
    int i , length = strlen(string);
    for(i = 1 ; i &amp;lt;= length ; ++i)
        Combination(string , i ,result);
}

void Combination(char *string ,int number , vector&amp;lt;char&amp;gt; &amp;amp;result)
{
    assert(string != NULL);
    if(number == 0)
    {
        static int num = 1;
        printf(&amp;quot;第%d个组合\t&amp;quot;,num++);

        vector&amp;lt;char&amp;gt;::iterator iter = result.begin();
        for( ; iter != result.end() ; ++iter)
            printf(&amp;quot;%c&amp;quot;,*iter);
        printf(&amp;quot;\n&amp;quot;);
        return ;
    }
    if(*string == &amp;apos;\0&amp;apos;)
        return ;
    result.push_back(*string);
    Combination(string + 1 , number - 1 , result);
    result.pop_back();
    Combination(string + 1 , number , result);
}

int main(void)
{
    char str[] = &amp;quot;abc&amp;quot;;
    Combination(str);
    return 0;
}


//******************************************************************
//组合，位运算，没有解决重复问题,组合中出现这个字符，那么字符所在位置为1，否则为0.a:100,b:010...
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
void Combination(string str){
    int countt=0;
    if(str.empty())
        return;
    int len=str.size();
    for(int i=1;i&amp;lt;(1&amp;lt;&amp;lt;len);i++){//从0~2^n-1，中可能出现的情况
        for(int j=0;j&amp;lt;len;j++){
            if(i&amp;amp;(1&amp;lt;&amp;lt;j)){//这个位置上有数
                cout&amp;lt;&amp;lt;str[j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

            }
        }
        countt++;
        cout&amp;lt;&amp;lt;endl;

    }
    cout&amp;lt;&amp;lt;countt;
}
int main(){
    Combination(&amp;quot;abc&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   //&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;**&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;br&gt;   //八皇后问题。不同行，不同列，不同斜角线。&lt;/p&gt;
&lt;p&gt;#include&lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;
&lt;p&gt;#include&lt;stdio.h&gt;&lt;br&gt;using namespace std;&lt;br&gt;int count_number=0;&lt;br&gt;bool isDiagnal(int ColumnIndex[],int length){&lt;br&gt;    for(int i=0;i&amp;lt;length;i++){&lt;br&gt;        for(int j=i+1;j&amp;lt;length;j++){&lt;br&gt;            if(i-j==ColumnIndex[i]-ColumnIndex[j] || j-i==ColumnIndex[i]-ColumnIndex[j])//对角关系&lt;br&gt;                return false;&lt;br&gt;        }&lt;/stdio.h&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
return true;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;void Print(int ColumnIndex[],int length){&lt;br&gt;    cout&amp;lt;&amp;lt;count_number&amp;lt;&amp;lt;”:”;&lt;br&gt;    for(int  i=0;i&amp;lt;length;i++){&lt;br&gt;        cout&amp;lt;&amp;lt;ColumnIndex[i]&amp;lt;&amp;lt;” “;//输出列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
cout&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void Permutation(int ColumnIndex[],int length,int index){&lt;br&gt;    if(index==length){//index代表排列好的列&lt;br&gt;        if(isDiagnal(ColumnIndex,length)){//状态合法，没有斜对角关系&lt;br&gt;            count_number++;//一次符合要求的状态&lt;br&gt;            Print(ColumnIndex,length);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    else{&lt;br&gt;        for(int i=index;i&amp;lt;length;i++){&lt;br&gt;            swap(ColumnIndex[index],ColumnIndex[i]);//第一个位置可能的情况&lt;br&gt;            Permutation(ColumnIndex,length,index+1);//递归后面的部分分成第一个元素以及剩下的元素&lt;br&gt;            swap(ColumnIndex[index],ColumnIndex[i]);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;void EightQueen(){&lt;br&gt;    const int length=8;&lt;br&gt;    int ColumnIndex[length];&lt;br&gt;    for(int i=0;i&amp;lt;length;i++){&lt;br&gt;        ColumnIndex[i]=i;//下标表示行，值代表列&lt;br&gt;    }&lt;br&gt;    Permutation(ColumnIndex,length,0);&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;int main(void)&lt;br&gt;{&lt;br&gt;    EightQueen();&lt;br&gt;    return 0;&lt;br&gt;}&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//实现字符串每个字符 的全排列,并求取全排列的个数&lt;br&gt;//分为三部分：1.首先，求取所有可能出现在第一个位置的字符；&lt;br&gt;//2.其次，把第一个字符和其后面的字符一一交换；&lt;br&gt;//3.接着，固定第一个字符，求后面所有字符的排列。重复步骤2&lt;/p&gt;
&lt;p&gt;   /
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BST转换双向链表</title>
    <link href="http://wxjttxs.github.io/2016/05/02/BST%E8%BD%AC%E6%8D%A2%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://wxjttxs.github.io/2016/05/02/BST转换双向链表/</id>
    <published>2016-05-02T02:48:02.000Z</published>
    <updated>2016-05-02T07:28:46.433Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//实现二叉搜索树到双向链表的转换
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot){
    if(!pTreeRoot)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; que;
    que.push(pTreeRoot);
    while(que.size()){
        BinaryTreeNode* pNode=que.front();//指向队列的第一个元素，要被弹出的元素
        que.pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft)//打印节点的左右子节点
            que.push(pNode-&amp;gt;m_pLeft);
        if(pNode-&amp;gt;m_pRight)
            que.push(pNode-&amp;gt;m_pRight);
    }
}
void Print(BinaryTreeNode*  &amp;amp;pHead){
    if(pHead==NULL)
        return ;
    BinaryTreeNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pRight;
    }
    cout&amp;lt;&amp;lt;endl;
}
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void CovertNode(BinaryTreeNode* pNode,BinaryTreeNode** pLastNodeInList){
    if(pNode==NULL)
        return;
    BinaryTreeNode* pCurrent=pNode;
    if(pCurrent-&amp;gt;m_pLeft!=NULL)//转换左子树为排序的双向链表
        CovertNode(pCurrent-&amp;gt;m_pLeft,pLastNodeInList);
    pCurrent-&amp;gt;m_pLeft=*pLastNodeInList;//pCurrent指向根节点
    if(*pLastNodeInList!=NULL)
        (*pLastNodeInList)-&amp;gt;m_pRight=pCurrent;//连接上根节点
    *pLastNodeInList=pCurrent;//当前双向链表的最后一个几点就是根节点
    if(pCurrent-&amp;gt;m_pRight!=NULL)
        CovertNode(pCurrent-&amp;gt;m_pRight,pLastNodeInList);

}
BinaryTreeNode* Covert(BinaryTreeNode* pRootOfTree){
    BinaryTreeNode* pLastNodeInList=NULL;//双向链表为 空
    CovertNode(pRootOfTree,&amp;amp;pLastNodeInList);
    //pLastNodeInList指向双向链表的最后
    //我们需要返回最后结点
    BinaryTreeNode* pHeadOfList=pLastNodeInList;
    while(pHeadOfList!=NULL &amp;amp;&amp;amp; pHeadOfList-&amp;gt;m_pLeft!=NULL)//最后找到双向链表的头结点
        pHeadOfList=pHeadOfList-&amp;gt;m_pLeft;
    return pHeadOfList;
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,6,4,8,14,12,16};
    int inorder[]={4,6,8,10,12,14,16};
    Btree= Contrust(preorder,inorder,7);
    PrintFromTopToBottom(Btree);
    cout&amp;lt;&amp;lt;endl;

    BinaryTreeNode* L=Covert(Btree);

    Print(L);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//实现二叉搜索树到双向链表的转换
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复制复杂链表</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8/"/>
    <id>http://wxjttxs.github.io/2016/04/30/复制复杂链表/</id>
    <published>2016-04-30T14:54:35.000Z</published>
    <updated>2016-04-30T14:55:44.459Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//复制复杂链表
#include &amp;lt;iostream&amp;gt;

using namespace std;
struct ComplexListNode{
    int m_nValue;
    ComplexListNode* m_pNext;
    ComplexListNode* m_pSibling;
};
void Insert(ComplexListNode* &amp;amp;pHead,int data){
    ComplexListNode* pNode=new ComplexListNode();
    pNode-&amp;gt;m_nValue=data;
    pNode-&amp;gt;m_pNext=NULL;
    pNode-&amp;gt;m_pSibling=NULL;
    if(pHead==NULL)
        pHead=pNode;
    else{
        pNode-&amp;gt;m_pNext=pHead;
        pHead=pNode;
    }
}
void Print(ComplexListNode* &amp;amp;pHead){
    if(pHead==NULL)
        return;
    ComplexListNode* pNode=pHead;
    while(pNode){
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        pNode=pNode-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
//第一步复制各个节点，并形成链表
void CloneNodes(ComplexListNode* pHead){
    ComplexListNode *pNode=pHead;
    while(pNode!=NULL){
        ComplexListNode* pCloned=new ComplexListNode();
        pCloned-&amp;gt;m_nValue=pNode-&amp;gt;m_nValue;
        pCloned-&amp;gt;m_pNext=pNode-&amp;gt;m_pNext;
        pCloned-&amp;gt;m_pSibling=NULL;
        pNode-&amp;gt;m_pNext=pCloned;//插入Cloned节点
        pNode=pCloned-&amp;gt;m_pNext;   //依次往后挪
    }
}
//复制原来节点m_pSibling指针的指向情况
void ConnectSiblingNodes(ComplexListNode* pHead){
    ComplexListNode* pNode=pHead;
    while(pNode!=NULL){
        ComplexListNode* pCloned=pNode-&amp;gt;m_pNext;
        if(pNode-&amp;gt;m_pSibling!=NULL)
                pCloned-&amp;gt;m_pSibling=pNode-&amp;gt;m_pSibling-&amp;gt;m_pNext;
        pNode=pCloned-&amp;gt;m_pNext;
    }
}
//按照奇偶位置拆分原始链表和复制链表
ComplexListNode* ReconnectNodes(ComplexListNode* pHead){
    ComplexListNode* pNode=pHead;
    ComplexListNode* pClonedHead=NULL;
    ComplexListNode* pClonedNode=NULL;
    if(pNode!=NULL){
        pClonedHead=pClonedNode=pNode-&amp;gt;m_pNext;
        pNode-&amp;gt;m_pNext=pClonedNode-&amp;gt;m_pNext;
        pNode=pNode-&amp;gt;m_pNext;
        while(pNode!=NULL){
            pClonedNode-&amp;gt;m_pNext=pNode-&amp;gt;m_pNext;
            pClonedNode=pClonedNode-&amp;gt;m_pNext;
            pNode-&amp;gt;m_pNext=pClonedNode-&amp;gt;m_pNext;
            pNode=pNode-&amp;gt;m_pNext;

        }
        return pClonedHead;
    }
}
ComplexListNode* Clone(ComplexListNode* pHead){
    CloneNodes(pHead);
    ConnectSiblingNodes(pHead);
    return ReconnectNodes(pHead);
}
int main()
{
    ComplexListNode* l=NULL;
    ComplexListNode* c=NULL;
    Insert(l,1);
    Insert(l,2);
    Insert(l,3);
    Insert(l,4);
    Insert(l,5);
    Print(l);

    c=Clone(l);
    Print(c);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//复制复杂链表
#include &amp;lt;iostream&amp;gt;

using namespace std;
struct ComplexListNode{
    int m_nValue;
    ComplexListNode* m_pNext;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树中和为给定值的路径</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://wxjttxs.github.io/2016/04/30/二叉树中和为给定值的路径/</id>
    <published>2016-04-30T13:27:40.000Z</published>
    <updated>2016-04-30T13:28:24.945Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//给定二叉树和一个值，找到二叉树中和等于这个值的路径
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void FindAllPath(BinaryTreeNode* pRoot,int expectedSum,vector&amp;lt;int&amp;gt;&amp;amp; path,int currentSum){
    currentSum+=pRoot-&amp;gt;m_nValue;
    path.push_back(pRoot-&amp;gt;m_nValue);
    bool isLeaf=(pRoot-&amp;gt;m_pLeft==NULL)&amp;amp;&amp;amp;(pRoot-&amp;gt;m_pRight==NULL);
    //叶子节点，并且路径上的节点的和等于期望的和
    if(currentSum==expectedSum &amp;amp;&amp;amp; isLeaf){
        cout&amp;lt;&amp;lt;&amp;quot;the path is found:&amp;quot;;
        vector&amp;lt;int&amp;gt;::iterator iter=path.begin();
        for(;iter!=path.end();iter++)
            cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        cout&amp;lt;&amp;lt;endl;
    }
    //不是叶子节点，那就继续遍历左右子树
    if(pRoot-&amp;gt;m_pLeft)
        FindAllPath(pRoot-&amp;gt;m_pLeft,expectedSum,path,currentSum);
    if(pRoot-&amp;gt;m_pRight)
        FindAllPath(pRoot-&amp;gt;m_pRight,expectedSum,path,currentSum);
    //是叶子节点，但是路径的和并不等于期望的和,那就回退
    path.pop_back();
}
void FindPath(BinaryTreeNode* pRoot,int expectedSum){
    if(pRoot==NULL)
        return;
    vector&amp;lt;int&amp;gt; path;
    int currentSum=0;
    FindAllPath(pRoot,expectedSum,path,currentSum);
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    FindPath(Btree,22);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//给定二叉树和一个值，找到二叉树中和等于这个值的路径
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
struct Bi
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>后序序列可以构成BST？</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8F%AF%E4%BB%A5%E6%9E%84%E6%88%90BST%EF%BC%9F/"/>
    <id>http://wxjttxs.github.io/2016/04/30/后序序列可以构成BST？/</id>
    <published>2016-04-30T12:35:43.000Z</published>
    <updated>2016-04-30T12:36:25.367Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//判断一个后序序列是不是二叉搜索树的后序遍历序列
//二叉搜索树的左子树＜根节点；右子树大于根节点
#include &amp;lt;iostream&amp;gt;

using namespace std;
bool SequenceIsBST(int *sequence, int length){
    if(sequence==NULL || length&amp;lt;=0)
        return false;
    int root=sequence[length-1];
    int i=0;
    for(;i&amp;lt;length-1;i++)
    {
        if(sequence[i]&amp;gt;root)
            break;
    }
    int j=i;
    for(;j&amp;lt;length-1;j++){
        if(sequence[j]&amp;lt;root)
            return false;
    }
    //上面的过程找到了左右子树
    bool left=true;//左子树是BST吗？
    if(i&amp;gt;0)//左子树存在
        left=SequenceIsBST(sequence,i);
    bool right=true;
    if(i&amp;lt;length-1)//存在右子树
        right=SequenceIsBST(sequence+i,j);
    return (left&amp;amp;&amp;amp;right);
}
int main()
{
    int a[]={5,7,6,9,11,10,8};
    cout&amp;lt;&amp;lt;SequenceIsBST(a,7);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//判断一个后序序列是不是二叉搜索树的后序遍历序列
//二叉搜索树的左子树＜根节点；右子树大于根节点
#include &amp;lt;iostream&amp;gt;

using namespace std;
bool SequenceIsBST(int *sequen
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按层打印二叉树(广度优先遍历)</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/04/30/按层打印二叉树/</id>
    <published>2016-04-30T11:51:36.000Z</published>
    <updated>2016-04-30T11:54:24.189Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树,然后按层打印每个节点,队列
#include  &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;exception&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot){
    if(!pTreeRoot)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; que;
    que.push(pTreeRoot);
    while(que.size()){
        BinaryTreeNode* pNode=que.front();//指向队列的第一个元素，要被弹出的元素
        que.pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft)//打印节点的左右子节点
            que.push(pNode-&amp;gt;m_pLeft);
        if(pNode-&amp;gt;m_pRight)
            que.push(pNode-&amp;gt;m_pRight);
    }
}
int main(){
    BinaryTreeNode* Btree;
    int preorder[]={8,6,5,7,10,9,11};
    int inorder[]={5,6,7,8,9,10,11};
    Btree= Contrust(preorder,inorder,7);
    PrintFromTopToBottom(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树,然后按层打印每个节点,队列
#include  &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;exception&amp;gt;
using namespace std;
stru
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>弹入序列 VS 弹出序列</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%BC%B9%E5%85%A5%E5%BA%8F%E5%88%97-VS-%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/04/30/弹入序列-VS-弹出序列/</id>
    <published>2016-04-30T07:26:15.000Z</published>
    <updated>2016-04-30T11:26:19.827Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//给定输入序列，判断给定的输出序列是不是真的
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

 bool IsPopOrder(const int* pPush, const int* pPop, int length){
    bool flag=false;
    if(pPush !=NULL  &amp;amp;&amp;amp; pPop!=NULL &amp;amp;&amp;amp; length&amp;gt;0){
        stack&amp;lt;int&amp;gt; stackData;//存取输入数据的栈,辅助栈
        const int* pNextPush=pPush;
        const int* pNextPop=pPop;
        while(pNextPop-pPop&amp;lt; length){
            while(stackData.empty()|| stackData.top()!=*pNextPop){//辅助栈的元素不等于
                if(pNextPush-pPush==length)
                    break;
                stackData.push(*pNextPush);
                pNextPush++;
            }
            if(stackData.top()!=*pNextPop)//找到最后也没有在 输入栈的栈顶元素找到输出栈的下一个元素,说明输出序列与输入不匹配
                break;
            stackData.pop();//找到匹配的元素
            pNextPop++;
        }
        if(stackData.empty() &amp;amp;&amp;amp; (pNextPop-pPop)==length)
            flag=true;

    }
    return flag;
 }
int main()
{
    const int push[]={1,2,3,4,5};
    const int pop[]={4,5,3,2,1};
    cout&amp;lt;&amp;lt;IsPopOrder(push,pop,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//给定输入序列，判断给定的输出序列是不是真的
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

 bool IsPopOrder(const int* pPush, 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>O(1)找到栈的最小值</title>
    <link href="http://wxjttxs.github.io/2016/04/30/O-1-%E6%89%BE%E5%88%B0%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://wxjttxs.github.io/2016/04/30/O-1-找到栈的最小值/</id>
    <published>2016-04-30T07:14:19.000Z</published>
    <updated>2016-04-30T07:14:58.735Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//O(1)时间找到栈中最小元素
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
template &amp;lt;typename T&amp;gt; class StackWithMin{
public:
    StackWithMin(void){};
    ~StackWithMin(void) {};
    void push(const T&amp;amp; value);
    void pop();
   const T minV();
private:
    stack&amp;lt;T&amp;gt; m_data;//原始的数据栈
    stack&amp;lt;T&amp;gt; m_min;//存放每次 压入栈的最小值
};
template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::push(const T&amp;amp;value){
    m_data.push(value);
    if(m_min.size()==0||value&amp;lt;m_min.top()){//辅助栈为空或者栈顶元素比新新输入的元素大，那么就把这个元素送入辅助栈
        m_min.push(value);
    }
    else
        m_min.push(m_min.top());//比如m_data 有的是3,4 ,那么m_min就会相应的是 3 3
}
template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::pop(){
    assert(m_data.size()&amp;gt;0 &amp;amp;&amp;amp; m_min.size()&amp;gt;0);
    m_data.pop();
    m_min.pop();
}
template &amp;lt;typename T&amp;gt;const T StackWithMin&amp;lt;T&amp;gt;::minV(){
    assert(m_data.size()&amp;gt;0&amp;amp;&amp;amp; m_min.size()&amp;gt;0);
    return m_min.top();
}
int main()
{
    StackWithMin&amp;lt;int&amp;gt; s;
    s.push(3);
    s.push(4);
    s.push(2);
    s.push(1);
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.pop();
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.pop();
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.push(0);
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//O(1)时间找到栈中最小元素
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
template &amp;lt;typen
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>今日头条</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    <id>http://wxjttxs.github.io/2016/04/27/今日头条/</id>
    <published>2016-04-27T13:28:24.000Z</published>
    <updated>2016-04-27T13:28:25.006Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>合并链表</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://wxjttxs.github.io/2016/04/27/合并链表/</id>
    <published>2016-04-27T06:59:54.000Z</published>
    <updated>2016-04-27T07:11:15.350Z</updated>
    
    <content type="html">&lt;p&gt;//原来有序的两个链表合并之后依然有序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
List Merge(List&amp;amp; L1, List&amp;amp; L2){
    ListNode* p1=L1;
    ListNode* p2=L2;
    ListNode* pMergeHead=NULL;
    if(L1==NULL)
        return L2;
    else if(L2==NULL)
        return L1;
    if((p1-&amp;gt;m_nValue) &amp;gt; (p2-&amp;gt;m_nValue)){
        pMergeHead=p1;
        pMergeHead-&amp;gt;m_pNext=Merge(p1-&amp;gt;m_pNext,p2);
    }
    else{
        pMergeHead=p2;
        pMergeHead-&amp;gt;m_pNext=Merge(p1,p2-&amp;gt;m_pNext);
    }
    return pMergeHead;
}
int main()
{

    List L=NULL;
    List S=NULL;
    Insert(L,1);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    Insert(S,2);
    Insert(S,3);
    Insert(S,4);
    Insert(S,5);
    Print(S);
    List tt=Merge(L,S);
    ListNode* p=tt;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;//还记得typedef struct and struct的区别吗？
下面的结果也是正确的  理解为ListNode *=List；
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
};//必须是一个链表


void Insert(ListNode* &amp;amp;pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(ListNode* &amp;amp;pHead){//ListNode* 链表，&amp;amp;pHead不会改变头结点
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
//ListNode* FindKthTotail(ListNode* pHead, int k){
//    if(pHead==NULL||k&amp;lt;=0)//非法输入
//        return NULL;
//    ListNode* p1=pHead, *p2=pHead;
//
//    for(int i=0;i&amp;lt;k-1;i++){
//        if(p1-&amp;gt;m_pNext!=NULL){
//            p1=p1-&amp;gt;m_pNext;//第一个指针走k-1步
//        }
//        else
//            return NULL;//长度不够k个节点
//     }
//
//
//    while(p1-&amp;gt;m_pNext!=NULL){
//            p2=p2-&amp;gt;m_pNext;
//            p1=p1-&amp;gt;m_pNext;
//    }
//    return p2;
//}
//ListNode *ReverseList(List &amp;amp;L){
//    ListNode* pNode=L;
//    List ReverseHead=NULL;
//    ListNode* pPre=NULL;//前一个节点
//    while(pNode!=NULL){
//        ListNode* pNext=pNode-&amp;gt;m_pNext;//保存后一个节点，不至于反转时候丢失
//
//        if(pNext==NULL)
//            ReverseHead=pNode;//就一个节点
//        pNode-&amp;gt;m_pNext=pPre;//实现反转
//        pPre=pNode;
//        pNode=pNext;//继续下一对节点的反转
//    }
//    return ReverseHead;
//}
ListNode  *Merge(ListNode  *L1, ListNode  *L2){
    ListNode* p1=L1;
    ListNode* p2=L2;
    ListNode* pMergeHead=NULL;
    if(L1==NULL)
        return L2;
    else if(L2==NULL)
        return L1;
    if((p1-&amp;gt;m_nValue) &amp;gt; (p2-&amp;gt;m_nValue)){
        pMergeHead=p1;
        pMergeHead-&amp;gt;m_pNext=Merge(p1-&amp;gt;m_pNext,p2);
    }
    else{
        pMergeHead=p2;
        pMergeHead-&amp;gt;m_pNext=Merge(p1,p2-&amp;gt;m_pNext);
    }
    return pMergeHead;
}
int main()
{

    ListNode  *L=NULL;
    ListNode  *S=NULL;
    Insert(L,1);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    Insert(S,2);
    Insert(S,3);
    Insert(S,4);
    Insert(S,5);
    Print(S);
    ListNode* p=Merge(L,S);
   // ListNode* p=tt;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//原来有序的两个链表合并之后依然有序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNod
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表反转</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <id>http://wxjttxs.github.io/2016/04/27/链表反转/</id>
    <published>2016-04-27T03:29:09.000Z</published>
    <updated>2016-04-27T03:30:13.730Z</updated>
    
    <content type="html">&lt;p&gt;//反转链表注意别断链&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
ListNode *ReverseList(List &amp;amp;L){
    ListNode* pNode=L;
    List ReverseHead=NULL;
    ListNode* pPre=NULL;//前一个节点
    while(pNode!=NULL){
        ListNode* pNext=pNode-&amp;gt;m_pNext;//保存后一个节点，不至于反转时候丢失

        if(pNext==NULL)
            ReverseHead=pNode;//就一个节点
        pNode-&amp;gt;m_pNext=pPre;//实现反转
        pPre=pNode;
        pNode=pNext;//继续下一对节点的反转
    }
    return ReverseHead;
}
int main()
{
    ListNode *p;
    List L=NULL;
    Insert(L,5);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    p=ReverseList(L);
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//反转链表注意别断链&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNe
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查找倒数第k个节点</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E6%9F%A5%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/04/27/查找倒数第k个节点/</id>
    <published>2016-04-27T02:51:00.000Z</published>
    <updated>2016-04-27T02:53:20.655Z</updated>
    
    <content type="html">&lt;p&gt;在O(1)时间实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
ListNode* FindKthTotail(ListNode* pHead, int k){
    if(pHead==NULL||k&amp;lt;=0)//非法输入
        return NULL;
    ListNode* p1=pHead, *p2=pHead;

    for(int i=0;i&amp;lt;k-1;i++){
        if(p1-&amp;gt;m_pNext!=NULL){
            p1=p1-&amp;gt;m_pNext;//第一个指针走k-1步
        }
        else
            return NULL;//长度不够k个节点
     }


    while(p1-&amp;gt;m_pNext!=NULL){
            p2=p2-&amp;gt;m_pNext;
            p1=p1-&amp;gt;m_pNext;
    }
    return p2;
}
int main()
{
    ListNode *p;
    ListNode* L=NULL;
    Insert(L,1);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    p=FindKthTotail(L,4);
    cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在O(1)时间实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>特定要求的排序：奇数移动到偶数前面</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E7%89%B9%E5%AE%9A%E8%A6%81%E6%B1%82%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%A5%87%E6%95%B0%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://wxjttxs.github.io/2016/04/27/特定要求的排序：奇数移动到偶数前面/</id>
    <published>2016-04-27T02:07:30.000Z</published>
    <updated>2016-04-27T02:09:29.838Z</updated>
    
    <content type="html">&lt;p&gt;//偶数移动到奇数后面,定义两个指针&lt;br&gt;//这个要求也可以改成别的，比如正数移到负数前面，只需要重写isodd()即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

bool isodd(int n){
    return n&amp;amp;0x01;
}
void ReorderOddEven(int *m,int length){
    if(m==NULL||length&amp;lt;=0)
        return;
    int *pBegin=m;
    int *pEnd=m+length-1;
    while(pBegin&amp;lt;pEnd){
        //向后移动pBegin直到指向偶数
        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; isodd(*pBegin))
            pBegin++;
        //向前移动EnD,直到指向奇数
        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; !isodd(*pEnd))
            pEnd--;
        if(pBegin&amp;lt;pEnd){
            swap(*pBegin,*pEnd);
        }
    }
    for(int i=0;i&amp;lt;length;i++)
        cout&amp;lt;&amp;lt;m[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
}

int main()
{
    int a[]={1,3,5,2,4};
    ReorderOddEven(a,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//偶数移动到奇数后面,定义两个指针&lt;br&gt;//这个要求也可以改成别的，比如正数移到负数前面，只需要重写isodd()即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

bool isodd(i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>O(1)删除指定节点</title>
    <link href="http://wxjttxs.github.io/2016/04/26/O-1-%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/04/26/O-1-删除指定节点/</id>
    <published>2016-04-26T15:21:25.000Z</published>
    <updated>2016-04-27T01:16:28.222Z</updated>
    
    <content type="html">&lt;p&gt;引入对typedef struct and struct 的结构的比较。&lt;a href=&quot;http://wenku.baidu.com/view/484d1f0b52ea551810a6875c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度文库&lt;/a&gt;&lt;br&gt;在C 和C++中有三种定义结构的方法&lt;br&gt;1.//这种方法可以在C and C++中定义一个S1结构体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct{

   }S1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.//只能在C++使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct S2{
   };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.//这种方法并没有定义结构体，而是定义了一个S3的结构变量，编译器会为S3分配内存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct{
  }S3;
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct Node&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int m_nValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;Node,*List;//必须添加typedef&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void InsertNode(List&amp;amp; L,int data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* p=new Node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;m_nValue=data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(NULL==L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&amp;#123;//采用头插法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p-&amp;gt;m_pNext=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void DeleteNode(List&amp;amp; L, Node* pToBeDeleted)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* p=new Node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(!L||!pToBeDeleted)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(pToBeDeleted==L)&amp;#123;//删除头结点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L=L-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delete pToBeDeleted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pToBeDeleted=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(pToBeDeleted-&amp;gt;m_pNext==NULL)&amp;#123;//尾节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(p-&amp;gt;m_pNext!=pToBeDeleted)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                p=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p-&amp;gt;m_pNext=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            delete pToBeDeleted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pToBeDeleted=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&amp;#123;//中间节点,用后一个数据直接覆盖前一个数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           p=pToBeDeleted-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           pToBeDeleted-&amp;gt;m_nValue=p-&amp;gt;m_nValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           pToBeDeleted-&amp;gt;m_pNext=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           delete p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           p=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void PrintNode(List&amp;amp; L)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(NULL==L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node* p=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List L=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PrintNode(L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;&amp;quot;输入删除节点：&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cin&amp;gt;&amp;gt;data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(p-&amp;gt;m_nValue!=data&amp;amp;&amp;amp; p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DeleteNode(L,p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PrintNode(L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cin&amp;gt;&amp;gt;data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;引入对typedef struct and struct 的结构的比较。&lt;a href=&quot;http://wenku.baidu.com/view/484d1f0b52ea551810a6875c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度文库&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>post打印1~n的最大</title>
    <link href="http://wxjttxs.github.io/2016/04/22/post%E6%89%93%E5%8D%B01-n%E7%9A%84%E6%9C%80%E5%A4%A7/"/>
    <id>http://wxjttxs.github.io/2016/04/22/post打印1-n的最大/</id>
    <published>2016-04-22T01:28:32.000Z</published>
    <updated>2016-04-22T02:15:59.958Z</updated>
    
    <content type="html">&lt;p&gt;##字符串表示大树问题&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;string&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//判断什么到达最大的n位数是重中之重,第一位进1时候一定达到最大位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//bool Increment(char* number)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    int n=strlen(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    bool isOverflow=false;//最低位是否进位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    int nTakeOver=0;//每一位上的进位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    for(int i=n-1;i&amp;gt;=0;i--)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        int ithNum=number[i]-&amp;apos;0&amp;apos;+nTakeOver;//第i位上的数字,这个地方是“-”，由字符转换成数字是“-”，而由数字转换成字符是“+”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(i==n-1)//最高位那么就加1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            ithNum++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(ithNum&amp;gt;=10)&amp;#123;//第i位有进位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                if(i==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    isOverflow=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    ithNum-=10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    nTakeOver=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    number[i]=&amp;apos;0&amp;apos;+ithNum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            number[i]=&amp;apos;0&amp;apos;+ithNum;//没有进位，还没到最大&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return isOverflow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//void PrintNumber(char* number)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    bool isBegin0=true;//从第一个不是0开头的数字开始打印&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    int n=strlen(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    for(int i=0;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(isBegin0 &amp;amp;&amp;amp; number[i]!=&amp;apos;0&amp;apos;)//不是以0开头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            isBegin0=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(!isBegin0)//开头不是0就输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            cout&amp;lt;&amp;lt;number[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//void Print1ToMaxofNdigits(int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    if(n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    char* number=new char[n+1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    memset(number,&amp;apos;0&amp;apos;,n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    number[n]=&amp;apos;\0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    while(!Increment(number))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        PrintNumber(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    delete []number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    Print1ToMaxofNdigits(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void PrintNumber(char* number)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool isBegin0=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int n=strlen(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(isBegin0&amp;amp;&amp;amp;number[i]!=&amp;apos;0&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isBegin0=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(!isBegin0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cout&amp;lt;&amp;lt;number[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void Print1ToMaxofNdigitsRecursively(char* number,int n, int index)&amp;#123;//把每一位都值成0~9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(index==n-1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PrintNumber(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number[index+1]=i+&amp;apos;0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Print1ToMaxofNdigitsRecursively(number,n,index+1);//递归打印下一位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void Print1ToMaxofNdigits(int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char* number=new char(n+1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    number[n]=&amp;apos;\0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number[0]=i+&amp;apos;0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Print1ToMaxofNdigitsRecursively(number,n,0);//从第一位开始打印&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Print1ToMaxofNdigits(-1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##字符串表示大树问题&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>post错误处理方式</title>
    <link href="http://wxjttxs.github.io/2016/04/21/post%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://wxjttxs.github.io/2016/04/21/post错误处理方式/</id>
    <published>2016-04-21T14:22:15.000Z</published>
    <updated>2016-04-21T14:22:29.992Z</updated>
    
    <content type="html">&lt;p&gt;##三种处理错误异常的方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回值     优:和系统API一致;     
          缺：不能方便的使用结算结果;
全局变量   优：能够方便的使用结算结果;   
          缺：用户可能会检查全局变量;                                                                         
异常      优：可以为不同的出错原因定义不同异常类型，逻辑清晰明了；     
          缺：有些语言（C）不支持异常，抛出异常可能对性能有负面影响
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##实现阶乘陷阱多多&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//以为pow(x,n)很简单，但是好多陷阱,比如指数为负，底数为0，所以需要错误处理(全局变量)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//基本而且完整的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool flag_error=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//double PowerUnsignedExp(double base,unsigned int exp)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    double result=1.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    if(exp==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    for(int i=0;i&amp;lt;exp;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        result*=base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//下面联系一下效率更高的一种。首先 x^n=x^(n/2)*x^(n/2)(n为偶数)；n为奇数（x^n=x^((n-1)/2)*...*x）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double PowerUnsignedExp(double base,unsigned int exp)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(exp==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double result=PowerUnsignedExp(base,exp&amp;gt;&amp;gt;1);//右移一位除以2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result*=result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(exp&amp;amp;0x1==1)//这个数为奇数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result*=base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool equalt(double a,double b)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((a-b&amp;lt;0.0000001)&amp;amp;&amp;amp;(b-a)&amp;lt;0.0000001)?1:0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double Power(double base, int exponent)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flag_error=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(equalt(base,0.0))&amp;#123;//底数W为0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flag_error=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 0;//因为底数为0造成的返回结果为0，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned int absExp=(exponent&amp;lt;0)?(-exponent):exponent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double result=PowerUnsignedExp(base,absExp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(exponent&amp;lt;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result=1.0/result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt;Power(10,3) &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##三种处理错误异常的方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回值     优:和系统API一致;     
          缺：不能方便的使用结算结果;
全局变量   优：能够方便的使用结算结果;   
          缺：用户可能会检查全局变量;         
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序给定人数的年龄o(n)</title>
    <link href="http://wxjttxs.github.io/2016/04/21/%E6%8E%92%E5%BA%8F%E7%BB%99%E5%AE%9A%E4%BA%BA%E6%95%B0%E7%9A%84%E5%B9%B4%E9%BE%84o-n/"/>
    <id>http://wxjttxs.github.io/2016/04/21/排序给定人数的年龄o-n/</id>
    <published>2016-04-21T13:01:26.000Z</published>
    <updated>2016-04-21T13:04:03.523Z</updated>
    
    <content type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//实现上万个人的年龄的排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void ageSort(int *a,int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(a==NULL||n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    const  int Maxage=99;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int countAge[Maxage+1];//0~99,一共100个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;Maxage+1;i++)&amp;#123;//每种年龄出现的次数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countAge[i]=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int age=a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(age&amp;lt;0||age&amp;gt;Maxage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;//输入不合法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countAge[age]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int index=0;//排好序的下标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for(int i=0;i&amp;lt;Maxage;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     for(int j=0;j&amp;lt;countAge[i];j++)&amp;#123;//,来控制每个年龄出现的次数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[index++]=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a[9]=&amp;#123;3,4,5,6,7,5,4,3,2&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ageSort(a,9);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;9;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
    
    </summary>
    
    
  </entry>
  
</feed>
