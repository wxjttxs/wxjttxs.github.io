<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happy happy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxjttxs.github.io/"/>
  <updated>2016-06-13T00:23:57.797Z</updated>
  <id>http://wxjttxs.github.io/</id>
  
  <author>
    <name>王晓静</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百度2017实习生编程题</title>
    <link href="http://wxjttxs.github.io/2016/06/12/%E7%99%BE%E5%BA%A62017%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://wxjttxs.github.io/2016/06/12/百度2017实习生编程题/</id>
    <published>2016-06-12T15:05:28.000Z</published>
    <updated>2016-06-13T00:23:57.797Z</updated>
    
    <content type="html">&lt;p&gt;// 0612.cpp : Defines the entry point for the console application.&lt;br&gt;//&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process&lt;br&gt;Next)；是对FCFS算法的改进，其目标是减少平均周转时间。 短作业优先调度算法基于这样一种思想： 运行时间短的优先调度；&lt;br&gt;如果运行时间相同则调度最先发起请求的进程。 等待时间：一个进程从发起请求到开始执行的时间间隔。&lt;br&gt;现在有n个进程请求cpu，每个进程用一个二元组表示：(p,q),p代表该进程发起请求的时间，p代表需要占用cpu的时间。&lt;br&gt;请计算n个进程的平均等待时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;//短作业优先（SJF）调度是FIFO的改进，减少了平均周转时间
    #include&amp;lt;iostream&amp;gt;
using namespace std;
#include&amp;lt;vector&amp;gt;

struct Job
{
    int start;
    int need;
};

int compareJob(Job j1, Job j2)
{
    if (j1.start == j2.start)
        return j1.need - j2.need;
    return j1.start - j2.start;
}

int main()
{
    int n;
    while (cin &amp;gt;&amp;gt; n)
    {
        vector&amp;lt;Job&amp;gt; wait;
        int  st, nd, sum_w = 0;
        for (int i = 0; i &amp;lt; n; ++i)
        {
            cin &amp;gt;&amp;gt; st &amp;gt;&amp;gt; nd;
            wait.push_back({ st, nd });
        }
        for (int i = wait.size() - 1; i &amp;gt; 0; --i)
        {
            bool change = false;
            for (int j = 0; j &amp;lt; i; ++j)
            {
                if (compareJob(wait[j], wait[j + 1])&amp;gt;0)
                {
                    Job t = wait[j];
                    wait[j] = wait[j + 1];
                    wait[j + 1] = t;
                    change = true;
                }
            }
            if (change == false)
                break;
        }
        int thisTime = wait[0].start + wait[0].need;
        for (int i = 1; i &amp;lt; wait.size(); ++i)
        {
            if (thisTime &amp;lt; wait[i].start)
                thisTime = wait[i].start;
            sum_w += (thisTime - wait[i].start);
            thisTime += wait[i].need;
        }
        printf(&amp;quot;%.4f\n&amp;quot;, sum_w / (double)n);
    }
    return 0;
}

在计算机中，页式虚拟存储器实现的一个难点是设计页面调度（置换）算法。其中一种实现方式是FIFO算法。 FIFO算法根据页面进入内存的时间先后选择淘汰页面，先进入内存的页面先淘汰，后进入内存的后淘汰。 假设Cache的大小为2,有5个页面请求，分别为 2 1 2 3 1，则Cache的状态转换为：(2)-&amp;gt;(2,1)-&amp;gt;(2,1)-&amp;gt;(1,3)-&amp;gt;(1,3)，其中第1,2,4次缺页，总缺页次数为3。 现在给出Cache的大小n和m个页面请求，请算出缺页数。

#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
bool findd(vector&amp;lt;int&amp;gt;q,int n){
    bool flag=false;
    for(int i=0;i&amp;lt;q.size();i++)
    {
        if(q[i]==n)
            flag=true;

    }
    return flag;
}

int main(){
    int n,m;
    while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)
    {

        vector&amp;lt;int&amp;gt; v;
        for(int i=0;i&amp;lt;m;i++)
        {
            int temp;
            cin&amp;gt;&amp;gt;temp;
            v.push_back(temp);
        }
        vector&amp;lt;int&amp;gt; q;
        int countt=0;
        for(int j=0;j&amp;lt;m;j++)
        {
           if(!findd(q,v[j]))
           {
                if(q.size()&amp;lt;n)
                    q.push_back(v[j]);
                else
                    {
                        q.erase(q.begin());
                        q.push_back(v[j]);
                    }
               countt++;
           }
           else
                continue;
        }
       cout&amp;lt;&amp;lt;countt&amp;lt;&amp;lt;endl;

    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;    拉姆刚开始学习英文单词，对单词排序很感兴趣。
如果给拉姆一组单词，他能够迅速确定是否可以将这些单词排列在一个列表中，使得该列表中任何单词的首字母与前一单词的为字母相同。
你能编写一个程序来帮助拉姆进行判断吗？
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;

int main()
{
    int n;
    while (cin&amp;gt;&amp;gt;n)
    {
        vector&amp;lt;string&amp;gt; vc(n);
        for (int i = 0; i &amp;lt; n;i++)
        {
            cin &amp;gt;&amp;gt; vc[i];
        }
        bool flag = true;
        for (int i = 0; i &amp;lt; n-1;i++)   //提出为bool的函数
        {
            int size = vc[i].size();
            if (vc[i][size-1]==vc[i+1][0])
            {
                continue;
            }
            else{
                flag = false;           
                break;
            }

        }
        if (flag)
        {
            cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;// 0612.cpp : Defines the entry point for the console application.&lt;br&gt;//&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>完美度最大的子串</title>
    <link href="http://wxjttxs.github.io/2016/06/10/%E5%AE%8C%E7%BE%8E%E5%BA%A6%E6%9C%80%E5%A4%A7%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>http://wxjttxs.github.io/2016/06/10/完美度最大的子串/</id>
    <published>2016-06-10T13:57:26.000Z</published>
    <updated>2016-06-10T14:04:26.051Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//牛牛参加了一个文学比赛，比赛的规则是写一段话，使得这段话中不重复的字最多，当然还要有文采。一段话的完美度就是这段话中仅出现一次的字符个数。&lt;br&gt;现在牛牛写了N段话，他想把这N段话按顺序连在一起，然后从中找出一个最短连续子串，使得这个子串的完美度最高。&lt;br&gt;&lt;strong&gt;输入描述：&lt;/strong&gt; 多组测试数据，对于每组测试数据： 第一行包含一个整数N，代表牛牛写了N段话 接下来包含N段话，每段话之间中空格隔开，均有大写字母组成。 保证：1&amp;lt;=N&amp;lt;=50,1&amp;lt;=Ai&amp;lt;=50&lt;br&gt;&lt;strong&gt;输出描述：&lt;/strong&gt; 对于每组数据，输出一个字符串，代表完美度最高的最长连续 子串。如果有多个，输出最早出现的子串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;quot;stdafx.h&amp;quot;
#include&amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;
//方法一穷举法
//得到一个字符串的完美度
//int getPerfectDegree(string s){
//    int length = s.size();
//    int countt = 0;//完美度,也就是不重复字符个数
//    int hashtable[256] = { 0 };
//    for (int i = 0; i&amp;lt;length; i++)
//    {
//        hashtable[s[i]]++;
//    }
//    for (int i = 0; i&amp;lt;length; i++)
//    {
//        if (hashtable[s[i]] == 1)
//            countt++;
//    }
//
//    return countt;
//}
//string getMaxSubstr(string s){
//    int length = s.size();
//    int D[2500][2500] = { 0 };
//    for (int i = 0; i&amp;lt;length; i++)
//    {
//        for (int j = 0; j &amp;lt;= i; j++)
//        {
//            D[i][j] = getPerfectDegree(s.substr(j, i - j + 1));
//        }
//    }
//    int maxx = 0;
//    int row = 0;
//    int col = 0;
//    for (int i = 0; i&amp;lt;length; i++)
//    {
//        for (int j = 0; j &amp;lt;= i; j++)
//        {
//            if (D[i][j]&amp;gt;maxx)
//            {
//                maxx = D[i][j];
//                row = i;
//                col = j;
//            }
//
//        }
//    }
//    cout &amp;lt;&amp;lt; maxx &amp;lt;&amp;lt; endl;;
//    return s.substr(col, row - col + 1);
//}
//方法二，当前结果基于前一次结果
void getMaxSubstr(string s)
{
    int a[50][50] = { 0 };
    string ans;
    int iStrlen = s.size();
    for (int i = 0; i &amp;lt; iStrlen; i++)
        a[i][i] = 1;
    for (int j = 1; j&amp;lt;iStrlen; j++)  //第j列
    {
        int index1 = -1, index2 = -1;
        for (int i = j - 1; i &amp;gt;= 0; i--)   //首次出现位置
        {
            if (s[i] == s[j])
            {
                if (index1 == -1)//j之前重复1次
                    index1 = i;
                else if (index2 == -1)//j之前重复多次
                {
                    index2 = i;
                    break;
                }
            }
        }

        for (int i = 0; i&amp;lt;j; i++)
        {
            if (i&amp;gt;index1)//j之前未重复
                a[i][j] = a[i][j - 1] + 1;
            else if (i&amp;gt;index2 &amp;amp;&amp;amp; i &amp;lt;= index1)//j之前重复一次
                a[i][j] = a[i][j - 1] - 1;
            else//j 之前重复多次
                a[i][j] = a[i][j - 1];
        }
    }

    //for(int i=0; i&amp;lt;iStrlen; i++)
    //{
    //    for(int j=0; j&amp;lt;iStrlen; j++)
    //        cout&amp;lt;&amp;lt;a[i][j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    //    cout&amp;lt;&amp;lt;endl;
    //}

    int iStart = 0, iEnd = 0, iMax = 0;
    for (int j = 0; j&amp;lt;iStrlen; j++)
    {
        for (int i = 0; i&amp;lt;iStrlen; i++)
        {
            if (a[i][j]&amp;gt;iMax)
            {
                iMax = a[i][j];
                iStart = i;
                iEnd = j;
            }
        }
    }

    ans = s.substr(iStart, iEnd - iStart + 1);
    cout &amp;lt;&amp;lt; a[iStart][iEnd] &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

}
int main(){
    string s = &amp;quot;hello&amp;quot;;
    // cout&amp;lt;&amp;lt;s.substr(0,5);从0开始5个

    /*cout &amp;lt;&amp;lt; getMaxSubstr(s);*/
    getMaxSubstr(&amp;quot;aohhad&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//牛牛参加了一个文学比赛，比赛的规则是写一段话，使得这段话中不重复的字最多，当然还要有文采。一段话的完美度就是这段话中仅出现一次的字符个数。&lt;br&gt;现在牛牛写了N段话，他想把这N段话按顺序连在一起，然后从中找出一个最短连续子串，使得这个子串的完美
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2009^2009</title>
    <link href="http://wxjttxs.github.io/2016/06/09/2009/"/>
    <id>http://wxjttxs.github.io/2016/06/09/2009/</id>
    <published>2016-06-09T08:28:52.000Z</published>
    <updated>2016-06-09T15:10:47.729Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;��������2009^2009�Ľ����ĸ�λ���ӵĽ��� �� ����������λ��ab,cd���ˣ�&lt;br&gt;��10a+b)&lt;em&gt;(10c+d)=100ac+10ad+10bc+bd&lt;br&gt;����һ��������x�ĸ���λ�����ӣ�������10x��һ���ģ���Ϊ���������ֶ���0.�������������⡣����23��230,8��80�ȡ� Ҳ���Ǻ�&lt;br&gt;��a+b)&lt;/em&gt;(c+d) = ac+ad+bc+bd  �ĸ���λ���������ȵġ�&lt;br&gt;���ԣ����Եó����ۣ�������λ�����˵Ľ����ĸ�λ���������Ǻ�ÿ�����ĸ�λ�����Ӻ������˵Ľ��������ȵġ�&lt;br&gt;ͬ�����Ƴ�����λ�������������˵Ľ����ĸ�λ�������ӽ������������������ˡ�  ��ô2009^2009�ĸ�λ������&lt;br&gt;��(2+0+0+9)^2009���ȣ�11^2009)  ��(1+1)^2009==&amp;gt;2^2009���ȡ�&lt;br&gt;ʵ����2^2009Ҳ���ó�2009�Σ��������Լ򻯳�(2^1004)^2 * 2ֻ��Ҫ��1006�Σ�ͬ�����Լ����Ż���ȥ&lt;/p&gt;
&lt;p&gt;2^n ��n��1��n �ó������� 1,2,4,8,7,5,1,2,4,8,7,5 ��������6Ϊ���ڣ�2009%6=5��������Ϊ5&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;��������2009^2009�Ľ����ĸ�λ���ӵĽ��� �� ����������λ��ab,cd���ˣ�&lt;br&gt;��10a+b)&lt;em&gt;(10c+d)=100ac+10ad+10bc+bd&lt;br&gt;����һ��������x�ĸ�
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最少操作使得数组回文</title>
    <link href="http://wxjttxs.github.io/2016/06/08/%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%BE%97%E6%95%B0%E7%BB%84%E5%9B%9E%E6%96%87/"/>
    <id>http://wxjttxs.github.io/2016/06/08/最少操作使得数组回文/</id>
    <published>2016-06-08T01:41:41.000Z</published>
    <updated>2016-06-08T02:47:18.593Z</updated>
    
    <content type="html">&lt;p&gt;//给定一个数列，每次操作可以选择相邻的两个数，然后用他们的和来替换这两个数，最少需要多少次操作才能使这个数列变为一个回文数列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;

bool isHuiwen(int *a,int length){//没有用，判断是否回文
    int start=0;
    int endd=length-1;
    int midd=(start+endd)/2;

    if(a[start]!=a[endd])
        return false;
    while(start&amp;lt;=endd){
        if(a[start]==a[endd]){
            start++;
            endd--;
        }
        else
            break;
    }
    if(midd==(start+endd)/2)
        return true;
}
int minDoCore(int *a,int start,int endd);
int minDo(int *a,int length){
    int start=0;
    int endd=length-1;
    int countt=0;
    if(a!=NULL &amp;amp;&amp;amp; length&amp;gt;1){
        countt=minDoCore(a,start,endd);
    }
    return countt;
}
int minDoCore(int *a,int start,int endd){
    int countt=0;
    int min1=0;
    int min2=0;

    if(start&amp;gt;=endd)
        return 0;
    else if(a[start]==a[endd])//两端相等
        countt= minDoCore(a,start+1,endd-1);

    else//两端不相等
    {
        a[start+1]=a[start]+a[start+1];//左端加
        min1=minDoCore(a,start+1,endd)+1;
        a[start+1]=a[start+1]-a[start];//恢复左端操作

        a[endd-1]=a[endd-1]+a[endd];//右端加
        min2=minDoCore(a,start,endd-1)+1;
        a[endd-1]=a[endd-1]-a[endd];//恢复右端操作

        countt=(min1&amp;lt;=min2)?min1:min2;
    }

//    if(countt==min1)
//        start++;
    return countt;
}
int main(){
//    int a[]={1,2,3,4,2,1};
//    int start=0;
//    int endd=5;
//    int temp[50];
//    while(start&amp;lt;=endd){
//         if(a[start]==a[endd]){
//            start++;
//            endd--;
//         }
//         else
//            break;
//    }
//    for(int i=0;i&amp;lt;length-start*2;i++){
//        temp[i]=a[i+start];
//    }
//     for(int i=0;i&amp;lt;length-start*2;i++)
//        cout&amp;lt;&amp;lt;temp[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;



    int n;
    int a[50];
    cin&amp;gt;&amp;gt;n;
    for(int i=0;i&amp;lt;n;i++){
        cin&amp;gt;&amp;gt;a[i];
    }
    int temp=minDo(a,n);
    cout&amp;lt;&amp;lt;temp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//给定一个数列，每次操作可以选择相邻的两个数，然后用他们的和来替换这两个数，最少需要多少次操作才能使这个数列变为一个回文数列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
using nam
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络地址知多少</title>
    <link href="http://wxjttxs.github.io/2016/06/07/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
    <id>http://wxjttxs.github.io/2016/06/07/网络地址知多少/</id>
    <published>2016-06-07T13:52:19.000Z</published>
    <updated>2016-06-07T13:53:23.873Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;IP 和子网掩码
我们都知道， IP 是由四段数字组成，在此，我们先来了解一下 3 类常用的 IP
A 类 IP 段 0.0.0.0 到 127.255.255.255 (0 段和 127 段不使用 )
B 类 IP 段 128.0.0.0 到 191.255.255.255
C 类 IP 段 192.0.0.0 到 223.255.255.255
XP 默认分配的子网掩码每段只有 255 或 0
A 类的默认子网掩码 255.0.0.0 一个子网最多可以容纳 1677 万多台电脑
B 类的默认子网掩码 255.255.0.0 一个子网最多可以容纳 6 万台电脑
C 类的默认子网掩码 255.255.255.0 一个子网最多可以容纳 254 台电脑
我们必须有一个子网掩码，因为：
1 ）当配置 IP 时，所有计算机都必须填写子网掩码
2 ）我们必须在我们的网络中设置一些逻辑边界
3 ）我们必须至少输入所使用 IP 类的默认子网掩码
我以前认为，要想把一些电脑搞在同一网段，只要 IP 的前三段一样就可以了，今天，我才知道我错了。如果照我这样说的话，一个子网就只能容纳 254 台电脑？真是有点笑话。我们来说详细看看吧。
要想在同一网段，只要网络标识相同就可以了，那要怎么看网络标识呢？首先要做的是把每段的 IP 转换为二进制。（有人说，我不会转换耶，没关系，我们用 Windows 自带计算器就行。打开计算器，点查看 &amp;gt; 程序员，输入十进制的数字，再点一下“二进制”这个单选点，就可以切换至二进制了。）
把子网掩码切换至二进制，我们会发现，所有的子网掩码是由一串连续的 1 和一串连续的 0 组成的（一共 4 段，每段 8 位，一共 32 位数）。
255.0.0.0 11111111.00000000.00000000.00000000
255.255.0.0 11111111.11111111.00000000.00000000
255.255.255.0 11111111.11111111.11111111.00000000
这是 A/B/C 三类默认子网掩码的二进制形式，其实，还有好多种子网掩码，只要是一串连续的 1 （不少于 8 个）和一串连续的 0 就可以了（每段都是 8 位）。如 11111111.11111111.11111000.00000000 ，这也是一段合法的子网掩码。子网掩码决定的是一个子网的计算机数目，计算机公式是 2 的 m 次方，其中，我们可以把 m 看到是后面的多少个 0 。如 255.255.255.0 转换成二进制，那就是 11111111.11111111.11111111.00000000 ，后面有 8 个 0 ，那 m 就是 8 ， 255.255.255.0 这个子网掩码可以容纳 2 的 8 次方（台）电脑，也就是 256 台，但是有两个 IP 是不能用的，那就是最后一段不能为 0 和 255 ，减去这两台，就是 254 台。
划分方法

子网的划分，实际上就是设计子网掩码的过程。子网掩码主要是用来区分 IP 地址中的网络 ID 和主机 ID ，它用来屏蔽 IP 地址的一部分，从 IP 地址中分离出网络 ID 和主机 ID. 子网掩码是由 4 个十进制数组成的数值 &amp;quot; 中间用 &amp;quot;.&amp;quot; 分隔，如 255.255.255.0 。若将它写成二进制的形式为 :11111111.11111111.11111111.00000000 ，其中为 &amp;quot;1&amp;quot; 的位分离出网络 ID, 为 &amp;quot;0&amp;quot; 的位分离出主机 ID ，也就是通过将 IP 地址与子网掩码进行 &amp;quot; 与 &amp;quot; 逻辑操作，得出网络号。
例如，假设 IP 地址为 192.160.4.1 ，子网掩码为 255.255.255.0 ，则网络 ID 为 192.160.4.0, 主机 ID 为 0.0.0.1 。计算机网络 ID 的不同，则说明他们不在同一个物理子网内，需通过路由器转发才能进行数据交换。
每类地址具有默认的子网掩码 : 对于 A 类为 255.0.0.0 ，对于 B 类为 255.255.0.0 ，对于 C 类为 255.255.255.0 。除了使用上述的表示方法之外，还有使用子网掩码中 &amp;quot;1&amp;quot; 的位数来表示的，在默认情况下， A 类地址为 8 位， B 类地址为 16 位， C 类地址为 24 位。例如， A 类的某个地址为 12.10.10.3/8 ，这里的最后一个 &amp;quot;8&amp;quot; 说明该地址的子网掩码为 8 位，而 199.42.26.0/28 表示网络 199.42.26.0 的子网掩码位数有 28 位。
如果希望在一个网络中建立子网，就要在这个默认的子网掩码中加入一些位，它减少了用于主机地址的位数。加入到掩码中的位数决定了可以配置的子网。因而，在一个划分了子网的网络中，每个地址包含一个网络地址、一个子网位数和一个主机地址
示例

255.255.248.0 这个子网掩码可以最多容纳多少台电脑？
计算方法

把将其转换为二进制的四段数字（每段要是 8 位，如果是 0 ，可以写成 8 个 0 ，也就是 00000000 ）
11111111.1111111.11111000.00000000
然后，数数后面有几颗 0 ，一共是有 11 颗，那就是 2 的 11 次方，等于 2048 ( 注意：主机号中全 0 是保留地址，全 1 是广播地址，所以它们不算可用主号地址。网络号也是一样的。子网号是可以用全 0 和全 1 的 ) ，所以这个子网掩码最多可以容纳 2048-2=2046 台电脑。
一个子网最多可以容纳多少台电脑你会算了吧，下面我们来个逆向算法的题。
一个公司有 530 台电脑，组成一个对等局域网，子网掩码设多少最合适？
首先，无疑， 530 台电脑用 B 类 IP 最合适（ A 类不用说了，太多， C 类又不够，肯定是 B 类），但是 B 类默认的子网掩码是 255.255.0.0 ，可以容纳 6 万台电脑，显然不太合适，那子网掩码设多少合适呢？我们先来列个公式。
公式

2 的 m 次方 &amp;gt;=560
首先，我们确定 2 的 m 次方一定是大于 2 的 8 次方的，因为我们知道 2 的 8 次方是 256 ，也就是 C 类 IP 的最大容纳电脑的数目，我们从 9 次方一个一个试， 2 的 9 次方是 512 ，不到 560 ， 2 的 10 次方是 1024 ，看来 2 的 10 次方最合适了。子网掩码一共由 32 位组成，已确定后面 10 位是 0 了，那前面的 22 位就是 1 ，最合适的子网掩码就是： 11111111.11111111.11111100.00000000 ，转换成 10 进制，那就是 255.255.252.0 。
分配和计算子网掩码你会了吧，下面，我们来看看 IP 地址的网段。
相信好多人都和我一样，认为 IP 只要前三段相同，就是在同一网段了，其实，不是这样的，同样，我也把 IP 的每一段转换为一个二进制数，这里就拿 IP ： 192.168.0.1 ，子网掩码： 255.255.255.0 做实验吧。
192.168.0.1
11000000.10101000.00000000.00000001
（这里说明一下，和子网掩码一样，每段 8 位，不足 8 位的，前面加 0 补齐。）
IP 11000000.10101000.00000000.00000001
子网掩码 11111111.11111111.11111111.00000000
同一网段

在这里，向大家说一下到底怎么样才算同一网段。
要想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？各类 IP 的网络标识算法都是不一样的。 A 类的，只算第一段。 B 类，只算第一、二段。 C 类，算第一、二、三段。
算法只要把 IP 和子网掩码的每位数 AND 就可以了。
AND 方法： 0 和 1=0 0 和 0=0 1 和 1=1
如： And 192.168.0.1 ， 255.255.255.0 ，先转换为二进制，然后 AND 每一位
IP 11000000.10101000.00000000.00000001
子网掩码 11111111.11111111.11111111.00000000
得出 AND 结果 11000000.10101000.00000000.00000000
转换为十进制 192.168.0.0 ，这就是网络标识，
再将子网掩码反取，也就是 00000000.00000000.00000000.11111111 ，与 IP AND
得出结果 00000000.00000000.00000000.00000001 ，转换为 10 进制，即 0.0.0.1 ，
这 0.0.0.1 就是主机标识。要想在同一网段，必需做到网络标识一样。
我们再来看看这个改为默认子网掩码的 B 类 IP
如 IP ： 188.188.0.111 ， 188.188.5.222 ，子网掩码都设为 255.255.254.0 ，在同一网段吗？
先将这些转换成二进制
188.188.0.111 10111100.10111100.00000000.01101111
188.188.5.222 10111100.10111100.00000101.11011110
255.255.254.0 11111111.11111111.11111110.00000000
分别 AND ，得
10111100.10111100.00000000.00000000
10111100.10111100.00000100.00000000
网络标识不一样（看 255.255.254.0 转换成二进制后 1 的数位，所以可以看到不一样），即不在同一网段。
判断是不是在同一网段，你会了吧，下面，我们来点实际的。
一个公司有 530 台电脑，组成一个对等局域网，子网掩码和 IP 设多少最合适？
子网掩码不说了，前面算出结果来了 11111111.11111111.11111100.00000000 ，也就是 255.255.252.0
B 类地址

选一个 B 类 IP 段，这里就选 188.188.x.x 吧
这样， IP 的前两段确定的，关键是要确定第三段，只要网络标识相同就可以了。我们先来确定网络号。（我们把子网掩码中的 1 和 IP 中的 ? 对就起来， 0 和 * 对应起来，如下：）
255.255.252.0 11111111.11111111.11111100.00000000
188.188.x.x 10111100.10111100.??????**.********
网络标识 10111100.10111100.??????00.00000000
由此可知， ? 处随便填（只能用 0 和 1 填，不一定全是 0 和 1 ），我们就用全填 0 吧， * 处随便，这样呢，我们的 IP 就是
10111100.10111100.000000**.******** ，一共有 530 台电脑， IP 的最后一段 1 ～ 254 可以分给 254 台计算机， 530/254=2.086 ，采用进 1 法，得整数 3 ，这样，我们确定了 IP 的第三段要分成三个不同的数字，也就是说，把 000000** 中的 ** 填三次数字，只能填 1 和 0 ，而且每次的数字都不一样，至于填什么，就随我们便了，如 00000001 ， 00000010 ， 00000011 ，转换成十进制，分别是 1 ， 2 ， 3 ，这样，第三段也确定了，这样，就可以把 IP 分成 188.188.1.y ， 188.188.2.y ， 188.188.3.y ， y 处随便填，只要在 1 ～ 254 范围之内，并且这 530 台电脑每台和每台的 IP 不一样，就可以了。
有人也许会说，既然算法这么麻烦，干脆用 A 类 IP 和 A 类默认子网掩码得了，偶要告诉你的是，由于 A 类 IP 和 A 类默认子网掩码的主机数目过大，这样做无疑是大海捞针，如果同时局域网访问量过频繁、过大，会影响效率的，所以，最好设置符合自己的 IP 和子网掩码 ^_^
举个实例：比如公司分配到的网段是 192.168.1.0/24 ，首先我要分一个 8 个主机的网段出来，那么这个网段的首地址是什么 ? 之后，我又要划分一个 16 个主机的地址出来，那么 16 个主机的首地址是什么？
划分实例

C 类地址例子 : 网络地址 192.168.10.0; 子网掩码 255.255.255.192(/26)
1. 子网数 =2*2=4
2. 主机数 =2 的 6 次方 -2=62
3. 有效子网 ?:block size=256-192=64; 所以第一个子网为 192.168.10.64, 第二个为 192.168.10.128
4. 广播地址 : 下个子网 -1. 所以 2 个子网的广播地址分别是 192.168.10.127 和 192.168.10.191
5. 有效主机范围是 : 所以第一个子网为 192.168.10.0 ，第二个为 192.168.10.64 ，第三个为 192.168.10.128 ，第四个为 192.168.10.192
B 类地址例子 1: 网络地址 :172.16.0.0; 子网掩码 255.255.192.0(/18)
1. 子网数 =2*2=4
2. 主机数 =2 的 14 次方 -2=16382
3. 有效子网 ?:block size=256-192=64; 所以第一个子网为 172.16.64.0, 最后 1 个为 172.16.128.0
4. 广播地址 : 下个子网 -1. 所以 2 个子网的广播地址分别是 172.16.127.255 和 172.16.191.255
5. 有效主机范围是 : 第一个子网的主机地址是 172.16.64.1 到 172.16.127.254; 第二个是 172.16.128.1 到 172.16.191.254
B 类地址例子 2: 网络地址 :172.16.0.0; 子网掩码 255.255.255.224(/27)
1. 子网数 =2 的 11 次方 -2=2046( 因为 B 类地址默认掩码是 255.255.0.0, 所以网络位为 8+3=11)
2. 主机数 =2 的 5 次方 -2=30
3. 有效子网 ?:block size=256-224=32; 所以第一个子网为 172.16.0.32, 最后 1 个为 172.16.255.192
4. 广播地址 : 下个子网 -1. 所以第一个子网和最后 1 个子网的广播地址分别是 172.16.0.63 和 172.16.255.223
5. 有效主机范围是 : 第一个子网的主机地址是 172.16.0.33 到 172.16.0.62; 最后 1 个是 172.16.255.193 到 172.16.255.223
Variable Length Subnet Masks(VLSM)
变长子网掩码 (VLSM) 的作用 : 节约 IP 地址空间 ; 减少路由表大小 . 使用 VLSM 时 , 所采用的路由协议必须能够支持它 , 这些路由协议包括 RIPv2,OSPF,EIGRP 和 BGP.
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;IP 和子网掩码
我们都知道， IP 是由四段数字组成，在此，我们先来了解一下 3 类常用的 IP
A 类 IP 段 0.0.0.0 到 127.255.255.255 (0 段和 127 段不使用 )
B 类 IP 段 128.0.0.0 到 191.25
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>横列坐标数位之和不大于K的可移动方格数目</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E6%A8%AA%E5%88%97%E5%9D%90%E6%A0%87%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C%E4%B8%8D%E5%A4%A7%E4%BA%8EK%E7%9A%84%E5%8F%AF%E7%A7%BB%E5%8A%A8%E6%96%B9%E6%A0%BC%E6%95%B0%E7%9B%AE/"/>
    <id>http://wxjttxs.github.io/2016/05/23/横列坐标数位之和不大于K的可移动方格数目/</id>
    <published>2016-05-23T09:10:42.000Z</published>
    <updated>2016-05-23T09:12:00.582Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//有一个m*N的方格，从（0，0）开始移动，每一次可以向上下左右移动一格，不能进入行列坐标的数位之和大于K的格子,机器人可以达到的最大格子数目?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//判断能否进入坐标（row,col），主要在于获得各个数位
int getDigitNum(int number){
    int sum=0;
    while(number&amp;gt;0){
        sum+=number%10;
        number/=10;
    }
    return sum;
}
bool check(int threshold,int rows, int cols,int row, int col,bool * visited){
    if(row&amp;gt;=0 &amp;amp;&amp;amp; row&amp;lt;rows &amp;amp;&amp;amp; col&amp;gt;=0 &amp;amp;&amp;amp; col&amp;lt;cols &amp;amp;&amp;amp; getDigitNum(row)+getDigitNum(col)&amp;lt;=threshold &amp;amp;&amp;amp;!visited[row*cols+col])
        return true;
    return false;
}
int movingCountCore(int threshold,int rows,int cols,int row,int col,bool* visited);
int movingCount(int threshold,int rows,int cols){
    bool* visited=new bool[rows*cols];
    for(int i=0;i&amp;lt;rows*cols;i++)
        visited[i]=false;

    int countt=movingCountCore(threshold,rows,cols,0,0,visited);
    delete[] visited;
    return countt;
}

int movingCountCore(int threshold,int rows,int cols,int row,int col,bool* visited){
    int countt=0;
    if(check(threshold,rows,cols,row,col,visited)){
        visited[row*cols+col]=true;

        countt=1+movingCountCore(threshold,rows,cols,row-1,col,visited)+
                movingCountCore(threshold,rows,cols,row,col-1,visited)+
                movingCountCore(threshold,rows,cols,row+1,col,visited)+
                movingCountCore(threshold,rows,cols,row,col+1,visited);

    }
    return countt;
}
// ================ test code============================
void test(char* testName, int threshold, int rows, int cols, int expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    if(movingCount(threshold, rows, cols) == expected)
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

void test1()
{
    test(&amp;quot;Test1&amp;quot;, 5, 10, 10, 21);
}

void test2()
{
    test(&amp;quot;Test2&amp;quot;, 15, 20, 20, 359);
}

void test3()
{
    test(&amp;quot;Test3&amp;quot;, 10, 1, 100, 29);
}

void test4()
{
    test(&amp;quot;Test4&amp;quot;, 10, 1, 10, 10);
}

void test5()
{
    test(&amp;quot;Test5&amp;quot;, 15, 100, 1, 79);
}

void test6()
{
    test(&amp;quot;Test6&amp;quot;, 15, 10, 1, 10);
}

void test7()
{
    test(&amp;quot;Test7&amp;quot;, 15, 1, 1, 1);
}

void test8()
{
    test(&amp;quot;Test8&amp;quot;, -10, 10, 10, 0);
}

int main(int agrc, char* argv[])
{
    test1();
    test2();
    test3();
    test4();
    test5();
    test6();
    test7();
    test8();
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//有一个m*N的方格，从（0，0）开始移动，每一次可以向上下左右移动一格，不能进入行列坐标的数位之和大于K的格子,机器人可以达到的最大格子数目?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>矩阵中的路径与字符串的匹配问题</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://wxjttxs.github.io/2016/05/23/矩阵中的路径与字符串的匹配问题/</id>
    <published>2016-05-23T08:52:35.000Z</published>
    <updated>2016-05-23T08:53:01.990Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//判断矩阵中是否存在一条包含某字符串所有字符的路径,路径不能重复进入矩阵的格子 //回溯法+栈&lt;br&gt;//在第N个字符的周围格子没有找到第N+1个字符，这个时候要回退到第N-1个字符，重新设定第N个字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
bool hasPathCore(char* matrix, int rows, int cols,int row,int col,char* str, int&amp;amp; pathLength, bool* visited);
bool hasPath(char* matrix, int rows, int cols, char* str){
    if(matrix==NULL || rows&amp;lt;1 || cols&amp;lt;1 ||str==NULL)
        return false;
    bool *visited=new bool[rows*cols];//标记这个格子是否走过
    memset(visited,0,rows*cols);

    int pathLength=0;
    for(int row=0;row&amp;lt;rows;++row){
        for(int col=0;col&amp;lt;cols;++col){
            if(hasPathCore(matrix,rows,cols,row,col,str,pathLength,visited))
                return true;
        }
    }
    delete[] visited;
    return false;
}
bool hasPathCore(char* matrix, int rows, int cols,int row,int col,char* str, int&amp;amp; pathLength, bool* visited){
    if(str[pathLength]==&amp;apos;\0&amp;apos;)//初始
        return true;
    bool hasPath=false;

    if(row&amp;gt;=0 &amp;amp;&amp;amp; row&amp;lt;rows &amp;amp;&amp;amp; col&amp;gt;=0 &amp;amp;&amp;amp; col&amp;lt;cols &amp;amp;&amp;amp; matrix[row*cols+col]==str[pathLength] &amp;amp;&amp;amp; !visited[row*cols+col]){//字符相等，没来过
        ++pathLength;
        visited[row*cols+col]=true;

        hasPath=hasPathCore(matrix,rows,cols,row,col-1,str,pathLength,visited)||//左
                hasPathCore(matrix,rows,cols,row-1,col,str,pathLength,visited)||//上
                hasPathCore(matrix,rows,cols,row,col+1,str,pathLength,visited)||//右
                hasPathCore(matrix,rows,cols,row+1,col,str,pathLength,visited);//下
        if(!hasPath){//这条路径不行

            --pathLength;
            visited[row*cols+col]=false;//回退到n-1
        }
    }
    return hasPath;
}

//**********************************test code*********************************
void Test(char* testName, char* matrix, int rows, int cols, char* str, bool expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    if(hasPath(matrix, rows, cols, str) == expected)
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

//ABCE
//SFCS
//ADEE

//ABCCED
void Test1()
{
    char matrix[] = &amp;quot;ABCESFCSADEE&amp;quot;;
    char* str = &amp;quot;ABCCED&amp;quot;;

    Test(&amp;quot;Test1&amp;quot;, (char*)matrix, 3, 4, str, true);
}

//ABCE
//SFCS
//ADEE

//SEE
void Test2()
{
    char matrix[] = &amp;quot;ABCESFCSADEE&amp;quot;;
    char* str = &amp;quot;SEE&amp;quot;;

    Test(&amp;quot;Test2&amp;quot;, (char*)matrix, 3, 4, str, true);
}

//ABCE
//SFCS
//ADEE

//ABCB
void Test3()
{
    char matrix[] = &amp;quot;ABCESFCSADEE&amp;quot;;
    char* str = &amp;quot;ABCB&amp;quot;;

    Test(&amp;quot;Test3&amp;quot;, (char*)matrix, 3, 4, str, false);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SLHECCEIDEJFGGFIE
void Test4()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SLHECCEIDEJFGGFIE&amp;quot;;

    Test(&amp;quot;Test4&amp;quot;, (char*)matrix, 5, 8, str, true);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SGGFIECVAASABCEHJIGQEM
void Test5()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SGGFIECVAASABCEHJIGQEM&amp;quot;;

    Test(&amp;quot;Test5&amp;quot;, (char*)matrix, 5, 8, str, true);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SGGFIECVAASABCEEJIGOEM
void Test6()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SGGFIECVAASABCEEJIGOEM&amp;quot;;

    Test(&amp;quot;Test6&amp;quot;, (char*)matrix, 5, 8, str, false);
}

//ABCEHJIG
//SFCSLOPQ
//ADEEMNOE
//ADIDEJFM
//VCEIFGGS

//SGGFIECVAASABCEHJIGQEMS
void Test7()
{
    char matrix[] = &amp;quot;ABCEHJIGSFCSLOPQADEEMNOEADIDEJFMVCEIFGGS&amp;quot;;
    char* str = &amp;quot;SGGFIECVAASABCEHJIGQEMS&amp;quot;;

    Test(&amp;quot;Test7&amp;quot;, (char*)matrix, 5, 8, str, false);
}

//AAAA
//AAAA
//AAAA

//AAAAAAAAAAAA
void Test8()
{
    char matrix[] = &amp;quot;AAAAAAAAAAAA&amp;quot;;
    char* str = &amp;quot;AAAAAAAAAAAA&amp;quot;;

    Test(&amp;quot;Test8&amp;quot;, (char*)matrix, 3, 4, str, true);
}

//AAAA
//AAAA
//AAAA

//AAAAAAAAAAAAA
void Test9()
{
    char matrix[] = &amp;quot;AAAAAAAAAAAA&amp;quot;;
    char* str = &amp;quot;AAAAAAAAAAAAA&amp;quot;;

    Test(&amp;quot;Test9&amp;quot;, (char*)matrix, 3, 4, str, false);
}

//A

//A
void Test10()
{
    char matrix[] = &amp;quot;A&amp;quot;;
    char* str = &amp;quot;A&amp;quot;;

    Test(&amp;quot;Test10&amp;quot;, (char*)matrix, 1, 1, str, true);
}

//A

//B
void Test11()
{
    char matrix[] = &amp;quot;A&amp;quot;;
    char* str = &amp;quot;B&amp;quot;;

    Test(&amp;quot;Test11&amp;quot;, (char*)matrix, 1, 1, str, false);
}

int main(int argc, char* argv[])
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    Test8();
    Test9();
    Test10();
    Test11();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//判断矩阵中是否存在一条包含某字符串所有字符的路径,路径不能重复进入矩阵的格子 //回溯法+栈&lt;br&gt;//在第N个字符的周围格子没有找到第N+1个字符，这个时候要回退到第N-1个字符，重新设定第N个字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://wxjttxs.github.io/2016/05/23/滑动窗口的最大值/</id>
    <published>2016-05-23T08:03:51.000Z</published>
    <updated>2016-05-23T08:04:19.405Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//给定一数组，找到指定滑动窗口中的最大值 //使用两端开口的队列deque&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;deque&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;

vector&amp;lt;int&amp;gt; maxInWindows(const vector&amp;lt;int&amp;gt;&amp;amp; numbers, unsigned int sizee){
    vector&amp;lt;int&amp;gt; maxInWindows;
    if(numbers.size()&amp;gt;=sizee &amp;amp;&amp;amp; sizee&amp;gt;=1){
        deque&amp;lt;int&amp;gt; index;//队列中的下标
        for(unsigned int i=0;i&amp;lt;sizee;i++){//滑动窗口没有填满
            while(!index.empty() &amp;amp;&amp;amp; numbers[i]&amp;gt;=numbers[index.back()])//已有的数据小于待存入的数据，那么它不可能是最大值，所以从队列尾部删除
                index.pop_back();
            index.push_back(i);
        }
        for(unsigned int i=sizee;i&amp;lt;numbers.size();++i){//
            maxInWindows.push_back(numbers[index.front()]);

            while(!index.empty() &amp;amp;&amp;amp; numbers[i]&amp;gt;=numbers[index.back()])//已有的数据小于待存入的数据，那么它不可能是最大值，所以从队列尾部删除
                index.pop_back();

            if(!index.empty() &amp;amp;&amp;amp; index.front()&amp;lt;=(int)(i-sizee))//滑出这个窗口，无论值多大，都从队列的头部删除
                index.pop_front();

            index.push_back(i);//插入新数据的下标，有可能成为最大值
        }
        maxInWindows.push_back(numbers[index.front()]);//index的首部front始终存放滑动窗口的最大值的下标
    }
    return maxInWindows;//滑动窗口的最大值

}

// ==================== Test Code ====================
void Test(char* testName, const vector&amp;lt;int&amp;gt;&amp;amp; num, unsigned int size, const vector&amp;lt;int&amp;gt;&amp;amp; expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    vector&amp;lt;int&amp;gt; result = maxInWindows(num, size);

    vector&amp;lt;int&amp;gt;::const_iterator iterResult = result.begin();
    vector&amp;lt;int&amp;gt;::const_iterator iterExpected = expected.begin();
    while(iterResult &amp;lt; result.end() &amp;amp;&amp;amp; iterExpected &amp;lt; expected.end())
    {
        if(*iterResult != *iterExpected)
            break;

        ++iterResult;
        ++iterExpected;
    }

    if(iterResult == result.end() &amp;amp;&amp;amp; iterExpected == expected.end())
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

void Test1()
{
    int num[] = {2, 3, 4, 2, 6, 2, 5, 1};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {4, 4, 6, 6, 6, 5};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 3;

    Test(&amp;quot;Test1&amp;quot;, vecNumbers, size, vecExpected);
}

void Test2()
{
    int num[] = {1, 3, -1, -3, 5, 3, 6, 7};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {3, 3, 5, 5, 6, 7};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 3;

    Test(&amp;quot;Test2&amp;quot;, vecNumbers, size, vecExpected);
}

// increasingly sorted
void Test3()
{
    int num[] = {1, 3, 5, 7, 9, 11, 13, 15};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {7, 9, 11, 13, 15};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 4;

    Test(&amp;quot;Test3&amp;quot;, vecNumbers, size, vecExpected);
}

// decreasingly sorted
void Test4()
{
    int num[] = {16, 14, 12, 10, 8, 6, 4};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {16, 14, 12};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 5;

    Test(&amp;quot;Test4&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is 1
void Test5()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 1;

    Test(&amp;quot;Test5&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is same as the array length
void Test6()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    int expected[] = {14};
    vector&amp;lt;int&amp;gt; vecExpected(expected, expected + sizeof(expected) / sizeof(int));

    unsigned int size = 4;

    Test(&amp;quot;Test6&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is 0
void Test7()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    vector&amp;lt;int&amp;gt; vecExpected;

    unsigned int size = 0;

    Test(&amp;quot;Test7&amp;quot;, vecNumbers, size, vecExpected);
}

// size of sliding windows is greater than the array length
void Test8()
{
    int num[] = {10, 14, 12, 11};
    vector&amp;lt;int&amp;gt; vecNumbers(num, num + sizeof(num) / sizeof(int));

    vector&amp;lt;int&amp;gt; vecExpected;

    unsigned int size = 5;

    Test(&amp;quot;Test8&amp;quot;, vecNumbers, size, vecExpected);
}

int main(int argc, char* argv[])
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    Test8();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//给定一数组，找到指定滑动窗口中的最大值 //使用两端开口的队列deque&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#inclu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉排序树的第K大节点</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/23/二叉排序树的第K大节点/</id>
    <published>2016-05-23T03:43:47.000Z</published>
    <updated>2016-05-23T03:44:35.379Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到二叉搜索树的第K大节点 //中序遍历 二叉搜索树，那它就是排序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
using namespace std;
BinaryTreeNode* KthNodeCore(BinaryTreeNode* pRoot,unsigned int &amp;amp;k){//根左右
    BinaryTreeNode* target=NULL;
    if(pRoot-&amp;gt;m_pLeft!=NULL)//在左子树
        target=KthNodeCore(pRoot-&amp;gt;m_pLeft,k);
    if(target==NULL){//不在左子树
        if(k==1)
            target=pRoot;
        k--;
    }
    if(target==NULL &amp;amp;&amp;amp; pRoot-&amp;gt;m_pRight!=NULL)
        target=KthNodeCore(pRoot-&amp;gt;m_pRight,k);
    return target;
}
BinaryTreeNode* KthNode(BinaryTreeNode* pRoot,unsigned int &amp;amp;k){
    if(pRoot==NULL || k==0)
        return NULL;
    return KthNodeCore(pRoot,k);
}
//**********************test code**************************
void Test(char* testName, BinaryTreeNode* pRoot, unsigned int k, bool isNull, int expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    BinaryTreeNode* pTarget = KthNode(pRoot, k);
    if((isNull &amp;amp;&amp;amp; pTarget == NULL) || (!isNull &amp;amp;&amp;amp; pTarget-&amp;gt;m_nValue == expected))
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

//            8
//        6      10
//       5 7    9  11
void TestA()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    Test(&amp;quot;TestA0&amp;quot;, pNode8, 0, true, -1);
    Test(&amp;quot;TestA1&amp;quot;, pNode8, 1, false, 5);
    Test(&amp;quot;TestA2&amp;quot;, pNode8, 2, false, 6);
    Test(&amp;quot;TestA3&amp;quot;, pNode8, 3, false, 7);
    Test(&amp;quot;TestA4&amp;quot;, pNode8, 4, false, 8);
    Test(&amp;quot;TestA5&amp;quot;, pNode8, 5, false, 9);
    Test(&amp;quot;TestA6&amp;quot;, pNode8, 6, false, 10);
    Test(&amp;quot;TestA7&amp;quot;, pNode8, 7, false, 11);
    Test(&amp;quot;TestA8&amp;quot;, pNode8, 8, true, -1);

    DestroyTree(pNode8);

    printf(&amp;quot;\n\n&amp;quot;);
}

//               5
//              /
//             4
//            /
//           3
//          /
//         2
//        /
//       1
void TestB()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);
    ConnectTreeNodes(pNode2, pNode1, NULL);

    Test(&amp;quot;TestB0&amp;quot;, pNode5, 0, true, -1);
    Test(&amp;quot;TestB1&amp;quot;, pNode5, 1, false, 1);
    Test(&amp;quot;TestB2&amp;quot;, pNode5, 2, false, 2);
    Test(&amp;quot;TestB3&amp;quot;, pNode5, 3, false, 3);
    Test(&amp;quot;TestB4&amp;quot;, pNode5, 4, false, 4);
    Test(&amp;quot;TestB5&amp;quot;, pNode5, 5, false, 5);
    Test(&amp;quot;TestB6&amp;quot;, pNode5, 6, true, -1);

    DestroyTree(pNode5);

    printf(&amp;quot;\n\n&amp;quot;);
}

// 1
//  \
//   2
//    \
//     3
//      \
//       4
//        \
//         5
void TestC()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, NULL, pNode2);
    ConnectTreeNodes(pNode2, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode5);

    Test(&amp;quot;TestC0&amp;quot;, pNode1, 0, true, -1);
    Test(&amp;quot;TestC1&amp;quot;, pNode1, 1, false, 1);
    Test(&amp;quot;TestC2&amp;quot;, pNode1, 2, false, 2);
    Test(&amp;quot;TestC3&amp;quot;, pNode1, 3, false, 3);
    Test(&amp;quot;TestC4&amp;quot;, pNode1, 4, false, 4);
    Test(&amp;quot;TestC5&amp;quot;, pNode1, 5, false, 5);
    Test(&amp;quot;TestC6&amp;quot;, pNode1, 6, true, -1);

    DestroyTree(pNode1);

    printf(&amp;quot;\n\n&amp;quot;);
}

// There is only one node in a tree
void TestD()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);

    Test(&amp;quot;TestD0&amp;quot;, pNode1, 0, true, -1);
    Test(&amp;quot;TestD1&amp;quot;, pNode1, 1, false, 1);
    Test(&amp;quot;TestD2&amp;quot;, pNode1, 2, true, -1);

    DestroyTree(pNode1);

    printf(&amp;quot;\n\n&amp;quot;);
}

// empty tree
void TestE()
{
    Test(&amp;quot;TestE0&amp;quot;, NULL, 0, true, -1);
    Test(&amp;quot;TestE1&amp;quot;, NULL, 1, true, -1);

    printf(&amp;quot;\n\n&amp;quot;);
}

int main()
{
   TestA();
    TestB();
    TestC();
    TestD();
    TestE();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到二叉搜索树的第K大节点 //中序遍历 二叉搜索树，那它就是排序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化和反序列化二叉树</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/23/序列化和反序列化二叉树/</id>
    <published>2016-05-23T03:28:44.000Z</published>
    <updated>2016-05-23T03:29:44.175Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//序列化以及反序列化二叉树
//从根节点开始序列化，就可以从根节点开始反序列化,前序遍历输出节点

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;fstream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

void Serialize(BinaryTreeNode* pRoot,ostream&amp;amp; stream){
    if(pRoot==NULL){
        stream&amp;lt;&amp;lt;&amp;quot;$,&amp;quot;;//没有节点或者叶子节点的左右子节点用这个符号代替

        return;
    }
    stream&amp;lt;&amp;lt;pRoot-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot;,&amp;quot;;
    Serialize(pRoot-&amp;gt;m_pLeft,stream);
    Serialize(pRoot-&amp;gt;m_pRight,stream);
}
bool ReadStream(istream&amp;amp; stream, int* number)
{
    if(stream.eof())//判断文件是否为空或者是否读到文件结尾,eof()函数返回true时是读到文件结束符0xFF，而文件结束符是最后一个字符的下一个字符
        return false;

    char buffer[32];
    buffer[0] = &amp;apos;\0&amp;apos;;

    char ch;
    stream &amp;gt;&amp;gt; ch;
    int i = 0;
    while(!stream.eof() &amp;amp;&amp;amp; ch != &amp;apos;,&amp;apos;)
    {
        buffer[i++] = ch;
        stream &amp;gt;&amp;gt; ch;
    }

    bool isNumeric = false;
    if(i &amp;gt; 0 &amp;amp;&amp;amp; buffer[0] != &amp;apos;$&amp;apos;)
    {
        *number = atoi(buffer);
        isNumeric = true;
    }

    return isNumeric;
}

void Deserialize(BinaryTreeNode** pRoot,istream&amp;amp; stream){
    int number;
    if(ReadStream(stream,&amp;amp;number)){
        *pRoot=new BinaryTreeNode();
        (*pRoot)-&amp;gt;m_nValue=number;
        (*pRoot)-&amp;gt;m_pLeft=NULL;
        (*pRoot)-&amp;gt;m_pRight=NULL;

        Deserialize(&amp;amp;((*pRoot)-&amp;gt;m_pLeft),stream);
        Deserialize(&amp;amp;((*pRoot)-&amp;gt;m_pRight),stream);
    }
}
// ==================== Test Code ====================
bool isSameTree(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    if(pRoot1 == NULL &amp;amp;&amp;amp; pRoot2 == NULL)
        return true;

    if(pRoot1 == NULL || pRoot2 == NULL)
        return false;

    if(pRoot1-&amp;gt;m_nValue != pRoot2-&amp;gt;m_nValue)
        return false;

    return isSameTree(pRoot1-&amp;gt;m_pLeft, pRoot2-&amp;gt;m_pLeft) &amp;amp;&amp;amp;
        isSameTree(pRoot1-&amp;gt;m_pRight, pRoot2-&amp;gt;m_pRight);
}

void Test(char* testName, BinaryTreeNode* pRoot)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: \n&amp;quot;, testName);

    PrintTree(pRoot);

    char* fileName = &amp;quot;test.txt&amp;quot;;
    ofstream fileOut;
    fileOut.open(fileName);

    Serialize(pRoot, fileOut);
    fileOut.close();

    // print the serialized file
    ifstream fileIn1;
    char ch;
    fileIn1.open(fileName);
    while(!fileIn1.eof())
    {
        fileIn1 &amp;gt;&amp;gt; ch;
        cout &amp;lt;&amp;lt; ch;
    }
    fileIn1.close();
    cout &amp;lt;&amp;lt; endl;

    ifstream fileIn2;
    fileIn2.open(fileName);
    BinaryTreeNode* pNewRoot = NULL;
    Deserialize(&amp;amp;pNewRoot, fileIn2);
    fileIn2.close();

    PrintTree(pNewRoot);

    if(isSameTree(pRoot, pNewRoot))
        printf(&amp;quot;The deserialized tree is same as the oritinal tree.\n\n&amp;quot;);
    else
        printf(&amp;quot;The deserialized tree is NOT same as the oritinal tree.\n\n&amp;quot;);

    DestroyTree(pNewRoot);
}

//            8
//        6      10
//       5 7    9  11
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    Test(&amp;quot;Test1&amp;quot;, pNode8);

    DestroyTree(pNode8);
}

//            5
//          4
//        3
//      2
void Test2()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);

    Test(&amp;quot;Test2&amp;quot;, pNode5);

    DestroyTree(pNode5);
}

//        5
//         4
//          3
//           2
void Test3()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode2);

    Test(&amp;quot;Test3&amp;quot;, pNode5);

    DestroyTree(pNode5);
}

void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    Test(&amp;quot;Test4&amp;quot;, pNode5);

    DestroyTree(pNode5);
}

void Test5()
{
    Test(&amp;quot;Test5&amp;quot;, NULL);
}

//        5
//         5
//          5
//         5
//        5
//       5 5
//      5   5
void Test6()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, NULL, pNode2);
    ConnectTreeNodes(pNode2, NULL, pNode3);
    ConnectTreeNodes(pNode3, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode5, NULL);
    ConnectTreeNodes(pNode5, pNode61, pNode62);
    ConnectTreeNodes(pNode61, pNode71, NULL);
    ConnectTreeNodes(pNode62, NULL, pNode72);

    Test(&amp;quot;Test6&amp;quot;, pNode1);

    DestroyTree(pNode1);
}
int main()
{
    Test1();
//    Test2();
//    Test3();
//    Test4();
//    Test5();
//    Test6();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//序列化以及反序列化二叉树
//从根节点开始序列化，就可以从根节点开始反序列化,前序遍历输出节点

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
#includ
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S型打印二叉树</title>
    <link href="http://wxjttxs.github.io/2016/05/23/S%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/23/S型打印二叉树/</id>
    <published>2016-05-23T02:30:04.000Z</published>
    <updated>2016-05-23T02:30:34.393Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//按照S型打印二叉树,分成奇偶行，奇数从左到右；偶数从右到左
//奇数层保存下一层的节点先保存左子节点，再保存右子节点；偶数层保存下一层节点相反。使用两个栈

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../common/ConstructBST.h&amp;quot;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stack&amp;gt;

using namespace std;
void Print(BinaryTreeNode* pRoot){
    if(pRoot==NULL)
        return;

    stack&amp;lt;BinaryTreeNode*&amp;gt; levels[2];//存储 奇偶层的节点
    int current=0;
    int next=1;

    levels[current].push(pRoot);//存储奇数层
    while(!levels[0].empty() || !levels[1].empty()){//如果两个都为空，打印完了
        BinaryTreeNode* pNode=levels[current].top();
        levels[current].pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

        if(current==0){//奇数层，存储下一层节点先左再右
            if(pNode-&amp;gt;m_pLeft!=NULL)
                levels[next].push(pNode-&amp;gt;m_pLeft);
            if(pNode-&amp;gt;m_pRight!=NULL)
                levels[next].push(pNode-&amp;gt;m_pRight);
        }
        else{//ou数层，存储下一层节点先右再左
            if(pNode-&amp;gt;m_pRight!=NULL)
                levels[next].push(pNode-&amp;gt;m_pRight);
            if(pNode-&amp;gt;m_pLeft!=NULL)
                levels[next].push(pNode-&amp;gt;m_pLeft);
        }
        if(levels[current].empty()){//一层的节点都打印玩了，交换两个栈，并继续打印下一层。
            cout&amp;lt;&amp;lt;endl;
            current=1-current;
            next=1-next;
        }

    }

}


//            8
//        6      10
//       5 7    9  11
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    printf(&amp;quot;====Test1 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;8 \n&amp;quot;);
    printf(&amp;quot;10 6 \n&amp;quot;);
    printf(&amp;quot;5 7 9 11 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode8);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode8);
}

//            5
//          4
//        3
//      2
void Test2()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);

    printf(&amp;quot;====Test2 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

//        5
//         4
//          3
//           2
void Test3()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode2);

    printf(&amp;quot;====Test3 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    printf(&amp;quot;====Test4 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test5()
{
    printf(&amp;quot;====Test5 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(NULL);
    printf(&amp;quot;\n&amp;quot;);
}

//        100
//        /
//       50
//         \
//         150
void Test6()
{
    BinaryTreeNode* pNode100 = CreateBinaryTreeNode(100);
    BinaryTreeNode* pNode50 = CreateBinaryTreeNode(50);
    BinaryTreeNode* pNode150 = CreateBinaryTreeNode(150);

    ConnectTreeNodes(pNode100, pNode50, NULL);
    ConnectTreeNodes(pNode50, NULL, pNode150);

    printf(&amp;quot;====Test6 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;100 \n&amp;quot;);
    printf(&amp;quot;50 \n&amp;quot;);
    printf(&amp;quot;150 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode100);
    printf(&amp;quot;\n&amp;quot;);
}

//                8
//        4              12
//     2     6       10      14
//   1  3  5  7     9 11   13  15
void Test7()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(12);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode14 = CreateBinaryTreeNode(14);
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);
    BinaryTreeNode* pNode13 = CreateBinaryTreeNode(13);
    BinaryTreeNode* pNode15 = CreateBinaryTreeNode(15);

    ConnectTreeNodes(pNode8, pNode4, pNode12);
    ConnectTreeNodes(pNode4, pNode2, pNode6);
    ConnectTreeNodes(pNode12, pNode10, pNode14);
    ConnectTreeNodes(pNode2, pNode1, pNode3);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);
    ConnectTreeNodes(pNode14, pNode13, pNode15);

    printf(&amp;quot;====Test7 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;8 \n&amp;quot;);
    printf(&amp;quot;12 4 \n&amp;quot;);
    printf(&amp;quot;2 6 10 14 \n&amp;quot;);
    printf(&amp;quot;15 13 11 9 7 5 3 1 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode8);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode8);
}

int main()
{

    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//按照S型打印二叉树,分成奇偶行，奇数从左到右；偶数从右到左
//奇数层保存下一层的节点先保存左子节点，再保存右子节点；偶数层保存下一层节点相反。使用两个栈

#include &amp;lt;iostream&amp;gt;
#include&amp;quot;../commo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按行打印二叉树</title>
    <link href="http://wxjttxs.github.io/2016/05/23/%E6%8C%89%E8%A1%8C%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/23/按行打印二叉树/</id>
    <published>2016-05-23T01:50:12.000Z</published>
    <updated>2016-05-23T01:50:50.717Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//按行打印二叉树 //一个变量表示当前层还没有打印的节点数，另一个变量表示下一层节点的数目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include &amp;quot;../common/ConstructBST.h&amp;quot;
using namespace std;
//按行打印二叉树
void Print(BinaryTreeNode* pRoot){
    if(pRoot==NULL)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; nodes;
    nodes.push(pRoot);
    int nextLevel=0;//下一层的节点数目
    int toBePrinted=1;//当前层剩下的节点数

    while(!nodes.empty()){
        BinaryTreeNode* pNode=nodes.front();

        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft!=NULL){
            nodes.push(pNode-&amp;gt;m_pLeft);
            ++nextLevel;

        }
        if(pNode-&amp;gt;m_pRight!=NULL){
            nodes.push(pNode-&amp;gt;m_pRight);
            ++nextLevel;
        }
        nodes.pop();//弹出节点
        --toBePrinted;//第一个层打印完了
        if(toBePrinted==0){
            cout&amp;lt;&amp;lt;endl;
            toBePrinted=nextLevel;
            nextLevel=0;
        }


    }
}
// ==================== Test Code ====================
//            8
//        6      10
//       5 7    9  11
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    printf(&amp;quot;====Test1 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;8 \n&amp;quot;);
    printf(&amp;quot;6 10 \n&amp;quot;);
    printf(&amp;quot;5 7 9 11 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode8);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode8);
}

//            5
//          4
//        3
//      2
void Test2()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, pNode4, NULL);
    ConnectTreeNodes(pNode4, pNode3, NULL);
    ConnectTreeNodes(pNode3, pNode2, NULL);

    printf(&amp;quot;====Test2 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

//        5
//         4
//          3
//           2
void Test3()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode4 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode3 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode2 = CreateBinaryTreeNode(2);

    ConnectTreeNodes(pNode5, NULL, pNode4);
    ConnectTreeNodes(pNode4, NULL, pNode3);
    ConnectTreeNodes(pNode3, NULL, pNode2);

    printf(&amp;quot;====Test3 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n&amp;quot;);
    printf(&amp;quot;4 \n&amp;quot;);
    printf(&amp;quot;3 \n&amp;quot;);
    printf(&amp;quot;2 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);

    printf(&amp;quot;====Test4 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;5 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode5);
    printf(&amp;quot;\n&amp;quot;);

    DestroyTree(pNode5);
}

void Test5()
{
    printf(&amp;quot;====Test5 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(NULL);
    printf(&amp;quot;\n&amp;quot;);
}

//        100
//        /
//       50
//         \
//         150
void Test6()
{
    BinaryTreeNode* pNode100 = CreateBinaryTreeNode(100);
    BinaryTreeNode* pNode50 = CreateBinaryTreeNode(50);
    BinaryTreeNode* pNode150 = CreateBinaryTreeNode(150);

    ConnectTreeNodes(pNode100, pNode50, NULL);
    ConnectTreeNodes(pNode50, NULL, pNode150);

    printf(&amp;quot;====Test6 Begins: ====\n&amp;quot;);
    printf(&amp;quot;Expected Result is:\n&amp;quot;);
    printf(&amp;quot;100 \n&amp;quot;);
    printf(&amp;quot;50 \n&amp;quot;);
    printf(&amp;quot;150 \n\n&amp;quot;);

    printf(&amp;quot;Actual Result is: \n&amp;quot;);
    Print(pNode100);
    printf(&amp;quot;\n&amp;quot;);
}

int main()
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//按行打印二叉树 //一个变量表示当前层还没有打印的节点数，另一个变量表示下一层节点的数目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树是否对称</title>
    <link href="http://wxjttxs.github.io/2016/05/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/22/二叉树是否对称/</id>
    <published>2016-05-22T14:32:13.000Z</published>
    <updated>2016-05-22T14:32:47.734Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//判断一棵二叉树是不是对称的 //充要条件：如果二叉树是对称的，那么它的前序遍历序列和这颗二叉树的对称二叉树的前序遍历序列是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//**********************二叉树是否对称************************
bool isSymmetrical(BinaryTreeNode* pRoot1,BinaryTreeNode* pRoot2){
    if(pRoot1==NULL &amp;amp;&amp;amp; pRoot2==NULL)
        return true;
    if(pRoot1==NULL || pRoot2==NULL)
        return false;
    if(pRoot1-&amp;gt;m_nValue!=pRoot2-&amp;gt;m_nValue)
        return false;

    return isSymmetrical(pRoot1-&amp;gt;m_pLeft,pRoot2-&amp;gt;m_pRight)&amp;amp;&amp;amp;isSymmetrical(pRoot1-&amp;gt;m_pRight,pRoot2-&amp;gt;m_pLeft);
}
bool isSymmetrical(BinaryTreeNode* pRoot){
   return  isSymmetrical(pRoot,pRoot);
}
//************************构造二叉树*************************
BinaryTreeNode* CreateBinaryTreeNode(int value)
{
    BinaryTreeNode* pNode = new BinaryTreeNode();
    pNode-&amp;gt;m_nValue = value;
    pNode-&amp;gt;m_pLeft = NULL;
    pNode-&amp;gt;m_pRight = NULL;

    return pNode;
}

void ConnectTreeNodes(BinaryTreeNode* pParent, BinaryTreeNode* pLeft, BinaryTreeNode* pRight)
{
    if(pParent != NULL)
    {
        pParent-&amp;gt;m_pLeft = pLeft;
        pParent-&amp;gt;m_pRight = pRight;
    }
}

void PrintTreeNode(BinaryTreeNode* pNode)
{
    if(pNode != NULL)
    {
        printf(&amp;quot;value of this node is: %d\n&amp;quot;, pNode-&amp;gt;m_nValue);

        if(pNode-&amp;gt;m_pLeft != NULL)
            printf(&amp;quot;value of its left child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pLeft-&amp;gt;m_nValue);
        else
            printf(&amp;quot;left child is null.\n&amp;quot;);

        if(pNode-&amp;gt;m_pRight != NULL)
            printf(&amp;quot;value of its right child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pRight-&amp;gt;m_nValue);
        else
            printf(&amp;quot;right child is null.\n&amp;quot;);
    }
    else
    {
        printf(&amp;quot;this node is null.\n&amp;quot;);
    }

    printf(&amp;quot;\n&amp;quot;);
}

void PrintTree(BinaryTreeNode* pRoot)
{
    PrintTreeNode(pRoot);

    if(pRoot != NULL)
    {
        if(pRoot-&amp;gt;m_pLeft != NULL)
            PrintTree(pRoot-&amp;gt;m_pLeft);

        if(pRoot-&amp;gt;m_pRight != NULL)
            PrintTree(pRoot-&amp;gt;m_pRight);
    }
}
void DestroyTree(BinaryTreeNode* pRoot)
{
    if(pRoot != NULL)
    {
        BinaryTreeNode* pLeft = pRoot-&amp;gt;m_pLeft;
        BinaryTreeNode* pRight = pRoot-&amp;gt;m_pRight;

        delete pRoot;
        pRoot = NULL;

        DestroyTree(pLeft);
        DestroyTree(pRight);
    }
}
//学习大牛的测试写法
// ==================== Test Code ====================
void Test(char* testName, BinaryTreeNode* pRoot, bool expected)
{
    if(testName != NULL)
        printf(&amp;quot;%s begins: &amp;quot;, testName);

    if(isSymmetrical(pRoot) == expected)
        printf(&amp;quot;Passed.\n&amp;quot;);
    else
        printf(&amp;quot;FAILED.\n&amp;quot;);
}

//            8
//        6      6
//       5 7    7 5
void Test1()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode8, pNode61, pNode62);
    ConnectTreeNodes(pNode61, pNode51, pNode71);
    ConnectTreeNodes(pNode62, pNode72, pNode52);

    Test(&amp;quot;Test1&amp;quot;, pNode8, true);

    DestroyTree(pNode8);
}

//            8
//        6      9
//       5 7    7 5
void Test2()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode8, pNode61, pNode9);
    ConnectTreeNodes(pNode61, pNode51, pNode71);
    ConnectTreeNodes(pNode9, pNode72, pNode52);

    Test(&amp;quot;Test2&amp;quot;, pNode8, false);

    DestroyTree(pNode8);
}

//            8
//        6      6
//       5 7    7
void Test3()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);

    ConnectTreeNodes(pNode8, pNode61, pNode62);
    ConnectTreeNodes(pNode61, pNode51, pNode71);
    ConnectTreeNodes(pNode62, pNode72, NULL);

    Test(&amp;quot;Test3&amp;quot;, pNode8, false);

    DestroyTree(pNode8);
}

//               5
//              / \
//             3   3
//            /     \
//           4       4
//          /         \
//         2           2
//        /             \
//       1               1
void Test4()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode31, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, pNode21, NULL);
    ConnectTreeNodes(pNode42, NULL, pNode22);
    ConnectTreeNodes(pNode21, pNode11, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode12);

    Test(&amp;quot;Test4&amp;quot;, pNode5, true);

    DestroyTree(pNode5);
}


//               5
//              / \
//             3   3
//            /     \
//           4       4
//          /         \
//         6           2
//        /             \
//       1               1
void Test5()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode31, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, pNode6, NULL);
    ConnectTreeNodes(pNode42, NULL, pNode22);
    ConnectTreeNodes(pNode6, pNode11, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode12);

    Test(&amp;quot;Test5&amp;quot;, pNode5, false);

    DestroyTree(pNode5);
}

//               5
//              / \
//             3   3
//            /     \
//           4       4
//          /         \
//         2           2
//                      \
//                       1
void Test6()
{
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);
    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);

    ConnectTreeNodes(pNode5, pNode31, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, pNode21, NULL);
    ConnectTreeNodes(pNode42, NULL, pNode22);
    ConnectTreeNodes(pNode21, NULL, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode12);

    Test(&amp;quot;Test6&amp;quot;, pNode5, false);

    DestroyTree(pNode5);
}

// Only one node
void Test7()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);
    Test(&amp;quot;Test7&amp;quot;, pNode1, true);

    DestroyTree(pNode1);
}

// No nodes
void Test8()
{
    Test(&amp;quot;Test8&amp;quot;, NULL, true);
}

// All nodes have the same value
//               5
//              / \
//             5   5
//            /     \
//           5       5
//          /         \
//         5           5
void Test9()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, pNode21, pNode22);
    ConnectTreeNodes(pNode21, pNode31, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, NULL, pNode42);
    ConnectTreeNodes(pNode41, NULL, NULL);
    ConnectTreeNodes(pNode42, NULL, NULL);

    Test(&amp;quot;Test9&amp;quot;, pNode1, true);

    DestroyTree(pNode1);
}

// All nodes have the same value
//               5
//              / \
//             5   5
//            /     \
//           5       5
//          /       /
//         5       5
void Test10()
{
    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);

    ConnectTreeNodes(pNode1, pNode21, pNode22);
    ConnectTreeNodes(pNode21, pNode31, NULL);
    ConnectTreeNodes(pNode22, NULL, pNode32);
    ConnectTreeNodes(pNode31, pNode41, NULL);
    ConnectTreeNodes(pNode32, pNode42, NULL);
    ConnectTreeNodes(pNode41, NULL, NULL);
    ConnectTreeNodes(pNode42, NULL, NULL);

    Test(&amp;quot;Test10&amp;quot;, pNode1, false);

    DestroyTree(pNode1);
}
int main()
{
    Test1();
    Test2();
    Test3();
    Test4();
    Test5();
    Test6();
    Test7();
    Test8();
    Test9();
    Test10();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//判断一棵二叉树是不是对称的 //充要条件：如果二叉树是对称的，那么它的前序遍历序列和这颗二叉树的对称二叉树的前序遍历序列是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的下一个节点</title>
    <link href="http://wxjttxs.github.io/2016/05/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/22/二叉树的下一个节点/</id>
    <published>2016-05-22T06:29:50.000Z</published>
    <updated>2016-05-22T13:57:03.991Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找出二叉树中序遍历的下一个节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
struct BinaryTreeNode
{
    int                    m_nValue;
    BinaryTreeNode*        m_pLeft;
    BinaryTreeNode*        m_pRight;
    BinaryTreeNode*        m_pParent;
};

BinaryTreeNode* CreateBinaryTreeNode(int value)
{
    BinaryTreeNode* pNode = new BinaryTreeNode();
    pNode-&amp;gt;m_nValue = value;
    pNode-&amp;gt;m_pLeft = NULL;
    pNode-&amp;gt;m_pRight = NULL;
    pNode-&amp;gt;m_pParent = NULL;

    return pNode;
}

void ConnectTreeNodes(BinaryTreeNode* pParent, BinaryTreeNode* pLeft, BinaryTreeNode* pRight)
{
    if(pParent != NULL)
    {
        pParent-&amp;gt;m_pLeft = pLeft;
        pParent-&amp;gt;m_pRight = pRight;

        if(pLeft != NULL)
            pLeft-&amp;gt;m_pParent = pParent;
        if(pRight != NULL)
            pRight-&amp;gt;m_pParent = pParent;
    }
}

void PrintTreeNode(BinaryTreeNode* pNode)
{
    if(pNode != NULL)
    {
        printf(&amp;quot;value of this node is: %d\n&amp;quot;, pNode-&amp;gt;m_nValue);

        if(pNode-&amp;gt;m_pLeft != NULL)
            printf(&amp;quot;value of its left child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pLeft-&amp;gt;m_nValue);
        else
            printf(&amp;quot;left child is null.\n&amp;quot;);

        if(pNode-&amp;gt;m_pRight != NULL)
            printf(&amp;quot;value of its right child is: %d.\n&amp;quot;, pNode-&amp;gt;m_pRight-&amp;gt;m_nValue);
        else
            printf(&amp;quot;right child is null.\n&amp;quot;);
    }
    else
    {
        printf(&amp;quot;this node is null.\n&amp;quot;);
    }

    printf(&amp;quot;\n&amp;quot;);
}

void PrintTree(BinaryTreeNode* pRoot)
{
    PrintTreeNode(pRoot);

    if(pRoot != NULL)
    {
        if(pRoot-&amp;gt;m_pLeft != NULL)
            PrintTree(pRoot-&amp;gt;m_pLeft);

        if(pRoot-&amp;gt;m_pRight != NULL)
            PrintTree(pRoot-&amp;gt;m_pRight);
    }
}
BinaryTreeNode* GetNext(BinaryTreeNode* pNode){
    if(pNode==NULL)
        return NULL;
    BinaryTreeNode* pNext=NULL;
    if(pNode-&amp;gt;m_pRight!=NULL){//一个节点的右子树存在，那么它的下一个节点就是右子树的最左子节点
        BinaryTreeNode* pRight=pNode-&amp;gt;m_pRight;
        while(pRight-&amp;gt;m_pLeft!=NULL)
            pRight=pRight-&amp;gt;m_pLeft;

        pNext=pRight;

    }
    else if(pNode-&amp;gt;m_pParent!=NULL){//等价于下面的功能
        BinaryTreeNode* pCurrent=pNode;
        BinaryTreeNode* pParent=pNode-&amp;gt;m_pParent;
        while(pParent!=NULL &amp;amp;&amp;amp; pCurrent==pParent-&amp;gt;m_pRight){
            pCurrent=pParent;
            pParent=pParent-&amp;gt;m_pParent;
        }
        pNext=pParent;
    }
//    BinaryTreeNode* pParent=pNode-&amp;gt;m_pParent;
//    if(pNode-&amp;gt;m_pRight==NULL &amp;amp;&amp;amp; pParent-&amp;gt;m_pLeft==pNode){//这个节点没有右子树，并且是其父节点的左节点，那么它的下一个节点是其父节点，
//        pNext=pParent;
//    }
//    else if(pNode-&amp;gt;m_pRight==NULL &amp;amp;&amp;amp; pParent-&amp;gt;m_pRight==pNode){//这个节点没有右子树，且是父节点的右子节点，比较复杂
//找到第一个该节点的祖先节点是目标节点的左子节点，这个目标节点就是它的下一个节点
//         BinaryTreeNode* pCurrent=pNode;
//        BinaryTreeNode* pParent=pNode-&amp;gt;m_pParent;
//        while( pCurrent==pParent-&amp;gt;m_pRight){
//            pCurrent=pParent;
//            pParent=pParent-&amp;gt;m_pParent;
//        }
//        pNext=pParent;
//    }
    return pNext;
}

int main()
{
    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);
    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);
    BinaryTreeNode* pNode10 = CreateBinaryTreeNode(10);
    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);
    BinaryTreeNode* pNode7 = CreateBinaryTreeNode(7);
    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);
    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(11);

    ConnectTreeNodes(pNode8, pNode6, pNode10);
    ConnectTreeNodes(pNode6, pNode5, pNode7);
    ConnectTreeNodes(pNode10, pNode9, pNode11);

    BinaryTreeNode* p=GetNext(pNode10);


    cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找出二叉树中序遍历的下一个节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
struct
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>删除链表中重复的节点</title>
    <link href="http://wxjttxs.github.io/2016/05/21/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/21/删除链表中重复的节点/</id>
    <published>2016-05-21T14:39:33.000Z</published>
    <updated>2016-05-21T14:40:06.728Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//删除排序链表中重复的节点 //注意如果头结点是重复的，那么删除节点之后防止链表散掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;iostream&amp;gt;
    #include&amp;lt;stdio.h&amp;gt;
    #include&amp;lt;stdlib.h&amp;gt;
    using namespace std;
    //构建链表，显示链表
    struct ListNode
    {
        int       m_nValue;
        ListNode* m_pNext;
    };

    ListNode* CreateListNode(int value);
    void ConnectListNodes(ListNode* pCurrent, ListNode* pNext);
    void PrintListNode(ListNode* pNode);
    void PrintList(ListNode* pHead);
    void DestroyList(ListNode* pHead);
    void AddToTail(ListNode** pHead, int value);

    ListNode* CreateListNode(int value)
    {
        ListNode* pNode = new ListNode();
        pNode-&amp;gt;m_nValue = value;
        pNode-&amp;gt;m_pNext = NULL;

        return pNode;
    }

    void ConnectListNodes(ListNode* pCurrent, ListNode* pNext)
    {
        if(pCurrent == NULL)
        {
            printf(&amp;quot;Error to connect two nodes.\n&amp;quot;);
            exit(1);
        }

        pCurrent-&amp;gt;m_pNext = pNext;
    }

    void PrintListNode(ListNode* pNode)
    {
        if(pNode == NULL)
        {
            printf(&amp;quot;The node is NULL\n&amp;quot;);
        }
        else
        {
            printf(&amp;quot;The key in node is %d.\n&amp;quot;, pNode-&amp;gt;m_nValue);
        }
    }

    void PrintList(ListNode* pHead)
    {
        printf(&amp;quot;PrintList starts.\n&amp;quot;);

        ListNode* pNode = pHead;
        while(pNode != NULL)
        {
            printf(&amp;quot;%d\t&amp;quot;, pNode-&amp;gt;m_nValue);
            pNode = pNode-&amp;gt;m_pNext;
        }

        printf(&amp;quot;\nPrintList ends.\n&amp;quot;);
    }

    void DestroyList(ListNode* pHead)
    {
        ListNode* pNode = pHead;
        while(pNode != NULL)
        {
            pHead = pHead-&amp;gt;m_pNext;
            delete pNode;
            pNode = pHead;
        }
    }

    void AddToTail(ListNode** pHead, int value)
    {
        ListNode* pNew = new ListNode();
        pNew-&amp;gt;m_nValue = value;
        pNew-&amp;gt;m_pNext = NULL;

        if(*pHead == NULL)
        {
            *pHead = pNew;
        }
        else
        {
            ListNode* pNode = *pHead;
            while(pNode-&amp;gt;m_pNext != NULL)
                pNode = pNode-&amp;gt;m_pNext;

            pNode-&amp;gt;m_pNext = pNew;
        }
    }
//删除重复节点
void deleteDuplication(ListNode** pHead){//头结点也有可能被删除**
    if(pHead==NULL || *pHead==NULL)
        return;
    ListNode* pPreNode=NULL;
    ListNode* pNode=*pHead;
    while(pNode!=NULL){
        ListNode* pNext=pNode-&amp;gt;m_pNext;
        bool needDeleted=false;

        if(pNext!=NULL &amp;amp;&amp;amp; pNext-&amp;gt;m_nValue==pNode-&amp;gt;m_nValue)//重复
            needDeleted=true;

        if(!needDeleted){
            pPreNode=pNode;
            pNode=pNode-&amp;gt;m_pNext;//继续往后找有没有重复的
        }
        else{
            int value=pNode-&amp;gt;m_nValue;
            ListNode* pToBeDel=pNode;

            while(pToBeDel!=NULL &amp;amp;&amp;amp; pToBeDel-&amp;gt;m_nValue==value){
                pNext=pToBeDel-&amp;gt;m_pNext;

                delete pToBeDel;
                pToBeDel=NULL;

                pToBeDel=pNext;
            }
            if(pPreNode==NULL)//头结点重复了
                *pHead=pNext;
            else
                pPreNode-&amp;gt;m_pNext=pNext;
            pNode=pNext;//继续下一个判断
        }
    }

}
int main()
{
//构建链表

    ListNode* pNode1 = CreateListNode(1);
    ListNode* pNode2 = CreateListNode(2);
    ListNode* pNode3 = CreateListNode(3);
    ListNode* pNode4 = CreateListNode(3);
    ListNode* pNode5 = CreateListNode(5);
    ListNode* pNode6 = CreateListNode(6);

    ConnectListNodes(pNode1, pNode2);
    ConnectListNodes(pNode2, pNode3);
    ConnectListNodes(pNode3, pNode4);
    ConnectListNodes(pNode4, pNode5);
    ConnectListNodes(pNode5, pNode6);

    ListNode* pHead=pNode1;
    deleteDuplication(&amp;amp;pHead);
    PrintList(pHead);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//删除排序链表中重复的节点 //注意如果头结点是重复的，那么删除节点之后防止链表散掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;iostream&amp;gt;
    #include&amp;lt;stdio.h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到带有环的链表的入口</title>
    <link href="http://wxjttxs.github.io/2016/05/21/%E6%89%BE%E5%88%B0%E5%B8%A6%E6%9C%89%E7%8E%AF%E7%9A%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3/"/>
    <id>http://wxjttxs.github.io/2016/05/21/找到带有环的链表的入口/</id>
    <published>2016-05-21T13:39:36.000Z</published>
    <updated>2016-05-21T14:16:37.794Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到链表中环的入口节点 //如果环有n个节点，那么指针p1先向前走n步，然后p1,p2一起往前走，直到相遇,相遇的节点就是入口节点&lt;br&gt;//接下来求环的节点个数：用快慢指针，如果相遇，必存在环，然后记下这个位置，再向前一边移动一边计数，当再次回到这个节点，就求出这个huan的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
using namespace std;
//构建链表，显示链表
struct ListNode
{
    int       m_nValue;
    ListNode* m_pNext;
};

ListNode* CreateListNode(int value);
void ConnectListNodes(ListNode* pCurrent, ListNode* pNext);
void PrintListNode(ListNode* pNode);
void PrintList(ListNode* pHead);
void DestroyList(ListNode* pHead);
void AddToTail(ListNode** pHead, int value);

ListNode* CreateListNode(int value)
{
    ListNode* pNode = new ListNode();
    pNode-&amp;gt;m_nValue = value;
    pNode-&amp;gt;m_pNext = NULL;

    return pNode;
}

void ConnectListNodes(ListNode* pCurrent, ListNode* pNext)
{
    if(pCurrent == NULL)
    {
        printf(&amp;quot;Error to connect two nodes.\n&amp;quot;);
        exit(1);
    }

    pCurrent-&amp;gt;m_pNext = pNext;
}

void PrintListNode(ListNode* pNode)
{
    if(pNode == NULL)
    {
        printf(&amp;quot;The node is NULL\n&amp;quot;);
    }
    else
    {
        printf(&amp;quot;The key in node is %d.\n&amp;quot;, pNode-&amp;gt;m_nValue);
    }
}

void PrintList(ListNode* pHead)
{
    printf(&amp;quot;PrintList starts.\n&amp;quot;);

    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        printf(&amp;quot;%d\t&amp;quot;, pNode-&amp;gt;m_nValue);
        pNode = pNode-&amp;gt;m_pNext;
    }

    printf(&amp;quot;\nPrintList ends.\n&amp;quot;);
}

void DestroyList(ListNode* pHead)
{
    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        pHead = pHead-&amp;gt;m_pNext;
        delete pNode;
        pNode = pHead;
    }
}

void AddToTail(ListNode** pHead, int value)
{
    ListNode* pNew = new ListNode();
    pNew-&amp;gt;m_nValue = value;
    pNew-&amp;gt;m_pNext = NULL;

    if(*pHead == NULL)
    {
        *pHead = pNew;
    }
    else
    {
        ListNode* pNode = *pHead;
        while(pNode-&amp;gt;m_pNext != NULL)
            pNode = pNode-&amp;gt;m_pNext;

        pNode-&amp;gt;m_pNext = pNew;
    }
}
//找到快慢指针相遇的节点
ListNode* MeetingNode(ListNode* pHead){
    if(pHead==NULL)
        return NULL;
    ListNode* pSlow=pHead-&amp;gt;m_pNext;
    if(pSlow==NULL)//就那一个节点，没有环
        return NULL;

    ListNode* pFast=pSlow-&amp;gt;m_pNext;//
    while(pFast!=NULL &amp;amp;&amp;amp; pSlow!=NULL)
    {
        if(pFast==pSlow)
            return pFast;

        pSlow=pSlow-&amp;gt;m_pNext;//一次一步
        pFast=pFast-&amp;gt;m_pNext;
        if(pFast!=NULL)
            pFast=pFast-&amp;gt;m_pNext;//一次两步
    }
    return  NULL;//不存在环
}

int number(ListNode* pHead){
     ListNode* meetingNode=MeetingNode(pHead);
    if(meetingNode==NULL)
        return NULL;

    //得到环的节点数目
    int nodeOfLoop=1;
    ListNode* pNode1=meetingNode;//环中的一个节点
    while(pNode1-&amp;gt;m_pNext!=meetingNode){
        pNode1=pNode1-&amp;gt;m_pNext;
        ++nodeOfLoop;
    }
    return nodeOfLoop;

}
ListNode* EntryNodeOfLoop(ListNode* pHead){
    int nodeOfLoop=number(pHead);

    //找环的入口
    ListNode* pNode1=pHead;
    for(int i=0;i&amp;lt;nodeOfLoop;i++){
        pNode1=pNode1-&amp;gt;m_pNext;//先走环的长度
    }

    //一起移动两个指针
    ListNode* pNode2=pHead;
    while(pNode1!=pNode2){
        pNode1=pNode1-&amp;gt;m_pNext;
        pNode2=pNode2-&amp;gt;m_pNext;
    }
    return pNode1;
}
int main()
{
    //构建有环的链表
    ListNode* pNode1 = CreateListNode(1);
    ListNode* pNode2 = CreateListNode(2);
    ListNode* pNode3 = CreateListNode(3);
    ListNode* pNode4 = CreateListNode(4);
    ListNode* pNode5 = CreateListNode(5);
    ListNode* pNode6 = CreateListNode(6);

    ConnectListNodes(pNode1, pNode2);
    ConnectListNodes(pNode2, pNode3);
    ConnectListNodes(pNode3, pNode4);
    ConnectListNodes(pNode4, pNode5);
    ConnectListNodes(pNode5, pNode6);
    ConnectListNodes(pNode6, pNode3);

    ListNode* first=EntryNodeOfLoop(pNode1);
    cout&amp;lt;&amp;lt;first-&amp;gt;m_nValue;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到链表中环的入口节点 //如果环有n个节点，那么指针p1先向前走n步，然后p1,p2一起往前走，直到相遇,相遇的节点就是入口节点&lt;br&gt;//接下来求环的节点个数：用快慢指针，如果相遇，必存在环，然后记下这个位置，再向前一边移动一边计数，当再次
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="http://wxjttxs.github.io/2016/05/16/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/16/第一个只出现一次的字符/</id>
    <published>2016-05-16T13:09:33.000Z</published>
    <updated>2016-05-16T13:13:12.596Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//找到字符流中第一个只出现一次的字符&lt;br&gt;//构建哈希表，用字符的ASCII码做下标，数值就是该字符在字符流中的位置，如果出现多次，那么这个数值就改成一个负值-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;limits&amp;gt;
using namespace std;

class CharStatistics{
public:
    CharStatistics():index(0)//下标初始值0
    {
        for(int i=0;i&amp;lt;256;i++)
            occurence[i]=-1;//初始化哈希表
    }
    void Insert(char ch){
        if(occurence[ch]==-1)
            occurence[ch]=index;
        else if(occurence[ch]&amp;gt;=0)
            occurence[ch]=-2;//不止出现一次
        index++;
    }
    char FirstAppearingOnce(){
        char ch=&amp;apos;\0&amp;apos;;
        int minIndex=numeric_limits&amp;lt;int&amp;gt;::max();//int可以表示的最大值

        for(int i=0;i&amp;lt;256;i++){
            if(occurence[i]&amp;gt;=0 &amp;amp;&amp;amp; occurence[i]&amp;lt;minIndex){//第一个只出现一次
                 minIndex=occurence[i];
                 ch=(char)i;

            }

        }
        return ch;
    }
private:
    //occurence[i]:A character with ASCII value i;
    //occurence[i]=-1: the character has not been found;
    //occurence[i]=-2: the character has been found with multiple times
    //occurence[i]&amp;gt;=0: the character has been found once
    int occurence[256];//ASCII码有 256 个,一个字节8位
    int index;
};
int main()
{
    CharStatistics test;
    test.Insert(&amp;apos;g&amp;apos;);
    cout&amp;lt;&amp;lt;test.FirstAppearingOnce();
    cout&amp;lt;&amp;lt;endl;
    test.Insert(&amp;apos;o&amp;apos;);
    test.Insert(&amp;apos;o&amp;apos;);
    test.Insert(&amp;apos;g&amp;apos;);
    test.Insert(&amp;apos;l&amp;apos;);
    test.Insert(&amp;apos;e&amp;apos;);
     cout&amp;lt;&amp;lt;test.FirstAppearingOnce();
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//找到字符流中第一个只出现一次的字符&lt;br&gt;//构建哈希表，用字符的ASCII码做下标，数值就是该字符在字符流中的位置，如果出现多次，那么这个数值就改成一个负值-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串与给定模式是否匹配</title>
    <link href="http://wxjttxs.github.io/2016/05/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BB%99%E5%AE%9A%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D/"/>
    <id>http://wxjttxs.github.io/2016/05/15/字符串与给定模式是否匹配/</id>
    <published>2016-05-15T06:59:13.000Z</published>
    <updated>2016-05-15T07:00:33.980Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;//判斷字符串與模式是否匹配 //.表示匹配任意字符； *表示它前面的字符出現的次數（包含0次）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

bool matchCore(char* str,char* pattern);
bool match(char* str,char* pattern){
    if(str==NULL|| pattern==NULL)
        return false;
    return matchCore(str,pattern);
}
bool matchCore(char* str, char* pattern){
    if(*str==&amp;apos;\0&amp;apos; &amp;amp;&amp;amp; *pattern==&amp;apos;\0&amp;apos;)
        return true;
    if(*str!=&amp;apos;\0&amp;apos; &amp;amp;&amp;amp; *pattern==&amp;apos;\0&amp;apos;)
        return false;
    if(*(pattern+1)==&amp;apos;*&amp;apos;){
        if(*pattern==*str ||(*pattern ==&amp;apos;.&amp;apos; &amp;amp;&amp;amp; *str!=&amp;apos;\0&amp;apos;))
            return matchCore(str+1,pattern+2) //比較下一個狀態   *前數字出現1次
            || matchCore(str+1,pattern) //停留在當前狀態   &amp;gt;=2
            || matchCore(str,pattern+2);//忽略*  0
        else//忽略*
            return matchCore(str,pattern+2);
    }
    if(*str==*pattern || (*pattern ==&amp;apos;.&amp;apos; &amp;amp;&amp;amp; *str !=&amp;apos;\0&amp;apos;))//.表示任意一個字符，肯定匹配
        return matchCore(str+1,pattern+1);

    return false;
}
int main()
{
    cout &amp;lt;&amp;lt;match(&amp;quot;aaa&amp;quot;,&amp;quot;ab*a&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;//判斷字符串與模式是否匹配 //.表示匹配任意字符； *表示它前面的字符出現的次數（包含0次）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到数组中所有重复的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/15/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/15/找到数组中所有重复的数字/</id>
    <published>2016-05-15T03:21:26.000Z</published>
    <updated>2016-05-15T03:22:00.704Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;找到數組中任意一個重複的數字，或者所有重複元素 那如果是所有重複的呢？動態數組 數組長度n,數組中的元素在0~n-1之間
&lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;iterator&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//**********************方法一排序*******************************
//時間複雜度是O(nlgn)
int part(int a[],int low,int high){//划分成左右子数组，找到中间位置
 int temp=a[high];//最后一个元素作为中间元素
 int i=low-1;//i是慢速下标
 for(int j=low;j&amp;lt;high;j++){//挨个检查元素，比中间值小的在放在它的左边，大的放在右边
    if(a[j]&amp;lt;=temp){
        i++;
        swap(a[i],a[j]);
    }
 }
 swap(a[i+1],a[high]);
 return i+1;//找到第一个比中间值大的元素，返回它的位置,这就是中间元素所在位置
}
void QuickSort(int a[],int low, int high){
    if(low&amp;lt;high){
        int mid=part(a,low,high);
        QuickSort(a,low,mid-1);
        QuickSort(a,mid+1,high);
    }
}
void duplicate1(int *a,int length){
    bool flag=true;

    if(a==NULL || length&amp;lt;=0){
        flag=false;
        return ;
    }
    QuickSort(a,0,length-1);

    int i=0;
    int j=1;
    vector&amp;lt;int&amp;gt; findData;

    while(j&amp;lt;length){//畫個示意圖很容易理解 0 1 1 2 2 3 4 5

        while(a[i]!=a[j] &amp;amp;&amp;amp; j&amp;lt;length){//注意這個j&amp;lt;length問題，最後一步如果沒有這個判斷，那麼i,j就會指向同一個值，就會出現重複壓入數組的情況
            i=j;
            j++;
        }
        if(a[i]==a[j]){
            findData.push_back(a[i]);
        }
        while(a[i]==a[j])
              j++;

    }
//這個實現找到任一個重複，vector數組找到所有重複數組
//    int findData=0;
//
//    for(int i=0;i&amp;lt;length-1;i++){
//        if(a[i]==a[i+1]){
//            findData=a[i];
//            break;
//        }
//    }

    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;
}
//*********************方法二哈希表******************************
//時間複雜度是O(n),需要額外的空間O(n)
void duplicate2(int *a, int length){

    int hashtable[length]={0};
    for(int i=0;i&amp;lt;length;i++){
            hashtable[a[i]]++;
    }
    vector&amp;lt;int&amp;gt; findData;
    for(int i=0;i&amp;lt;length;i++){
        if(hashtable[a[i]]&amp;gt;1)//需要去重
        {
            findData.push_back(a[i]);
        }

    }
    //重複過程
    vector&amp;lt;int&amp;gt;::iterator iter=findData.begin();
    iter=unique(findData.begin(),findData.end());//只能刪除相鄰的重複元素
    findData.erase(iter,findData.end());

    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;


}
//**********************方法三交換*******************************
/*
O(n)時間找到數組中重複的數字，並且不需要額外分配空間，空間複雜度為O(1)
*/
//如果下標i與在所在的數值不一致，那就交換以數值為下標的數值，前提是這兩個數值不一致，如果不同的下標同一個數字，那就說明找到重複的。
void duplicate3(int *a,int length){
    bool flag=false;
    if(a==NULL ||length&amp;lt;=0){
        return ;
    }
    for(int i=0;i&amp;lt;length;i++){
        if(a[i]&amp;lt;0 || a[i]&amp;gt;length-1)
            return ;
    }

    vector&amp;lt;int&amp;gt; findData;
    for(int i=0;i&amp;lt;length;i++){
        while(a[i]!=i){
            if(a[i]==a[a[i]]){
                    vector&amp;lt;int&amp;gt;::iterator it=find(findData.begin(),findData.end(),a[i]);
                    if(it!=findData.end())//數組中沒有這個元素再放進去，有的話進行下一輪判斷
                        break;
                    findData.push_back(a[i]);
                    flag=true;
                    break;
            }
            //否則就交換以這個數值為下標的數字
            else{
                int temp=a[i];
                a[i]=a[temp];
                a[temp]=temp;
            }
        }
    }


    for(vector&amp;lt;int&amp;gt;::const_iterator it = findData.begin(); it !=findData.end(); ++it)
        cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

    cout&amp;lt;&amp;lt;endl;
}
int main()
{
    int a[]={0,0,1,2,2,3,4,4,5,6};
   // duplicate1(a,8);
   //duplicate2(a,10);

    duplicate3(a,10);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;找到數組中任意一個重複的數字，或者所有重複元素 那如果是所有重複的呢？動態數組 數組長度n,數組中的元素在0~n-1之間
&lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在二叉树中找到两个节点的最低公共祖先</title>
    <link href="http://wxjttxs.github.io/2016/05/14/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://wxjttxs.github.io/2016/05/14/在二叉树中找到两个节点的最低公共祖先/</id>
    <published>2016-05-14T12:27:09.000Z</published>
    <updated>2016-05-14T12:38:57.532Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;   /*在二叉樹中找到給定兩個節點的最低公共祖先 lowest common ancestor LCA&lt;br&gt;我們做一個規定：如果a是b的祖先，那麼他倆的LCA是a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;list&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;

struct Node
{
    struct Node *left, *right;
    int key;
};

Node* newNode(int key)
{
    Node *temp = new Node;
    temp-&amp;gt;key = key;
    temp-&amp;gt;left = temp-&amp;gt;right = NULL;
    return temp;
}
//************************方法一遞歸************************

/* 只用一次遍历解决LCA
學號二叉樹，用好遞歸
從root開始遍歷，如果n1,n2有一個與root匹配，那麼root就是LCA。如果都不匹配，遞歸左右子樹，如果
有一個在左子樹，一個在右子樹，那麼root是LCA。如果兩個數都在左子樹，則說明LCA在左子樹，否則在右子樹
*/

// 返回n1和n2的 LCA的指针
// 假设n1和n2都出现在树中
struct Node *findLCA1(struct Node* root, int n1, int n2)
{
    if (root == NULL) return NULL;

    // 只要n1 或 n2 的任一个匹配即可
    //  (注意：如果 一个节点是另一个祖先，则返回的是祖先节点。因为递归是要返回到祖先的 )
    if (root-&amp;gt;key == n1 || root-&amp;gt;key == n2)
        return root;
    // 分别在左右子树查找
    Node *left_lca  = findLCA1(root-&amp;gt;left, n1, n2);
    Node *right_lca = findLCA1(root-&amp;gt;right, n1, n2);
    // 如果都返回非空指针 Non-NULL, 则说明两个节点分别出现了在两个子树中，则当前节点肯定为LCA
    if (left_lca &amp;amp;&amp;amp; right_lca)  return root;
    // 如果一个为空，在说明LCA在另一个子树
    return (left_lca != NULL)? left_lca: right_lca;
}

//************************方法二找到路徑，求路徑的最後一個公共節點****************
//找到給定節點的路徑
bool GetNodePath(Node* pRoot,int key, list&amp;lt;Node*&amp;gt;&amp;amp;path){
    if(pRoot==NULL)
        return false;
    path.push_back(pRoot);//關鍵在於存放節點與判斷的順序
    if(pRoot-&amp;gt;key==key)
        return true;


    //左右子樹是否找到，找到的話，當前節點就在路徑中
    bool found=(GetNodePath(pRoot-&amp;gt;left,key,path) ||GetNodePath(pRoot-&amp;gt;right,key,path));
    if(!found)//沒有找到就彈出
         path.pop_back();
    return found;

}
//查看路徑上的節點
void PrintPath(list&amp;lt;Node*&amp;gt;&amp;amp;path){
    Node* pLast=NULL;
    list&amp;lt;Node*&amp;gt;::const_iterator iter1=path.begin();
    while(iter1!=path.end()){

        pLast=*iter1;
        cout&amp;lt;&amp;lt;pLast-&amp;gt;key&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        iter1++;
    }
    cout&amp;lt;&amp;lt;endl;
}
//得到兩條路上的最後一個公共節點
Node* GetLastCommonNode(const list&amp;lt;Node*&amp;gt;&amp;amp; path1,const list&amp;lt;Node*&amp;gt;&amp;amp; path2){
    list&amp;lt;Node*&amp;gt;::const_iterator iter1=path1.begin();
    list&amp;lt;Node*&amp;gt;::const_iterator iter2=path2.begin();
    Node* pLast=NULL;

    while(iter1!=path1.end() &amp;amp;&amp;amp; iter2!=path2.end()){
        if(*iter1==*iter2)
            pLast=*iter1;
        iter1++;
        iter2++;
    }
    return pLast;
}
//找到兩個指點節點的最低公共祖先（根節點的祖先是他自己）
Node* findLCA2(Node* pRoot, int key1,int key2){
    list&amp;lt;Node*&amp;gt; path1;
    list&amp;lt;Node*&amp;gt; path2;
    if(pRoot==NULL )//輸入無效，找不到
    {

        return NULL;
    }

    if(GetNodePath(pRoot,key1,path1) &amp;amp;&amp;amp;  GetNodePath(pRoot,key2,path2))
            return GetLastCommonNode(path1,path2);


}

//测试
int main()
{
    // 构造上面图中的树
    Node * root = newNode(1);
    root-&amp;gt;left = newNode(2);
    root-&amp;gt;right = newNode(3);
    root-&amp;gt;left-&amp;gt;left = newNode(4);
    root-&amp;gt;left-&amp;gt;right = newNode(5);
    root-&amp;gt;right-&amp;gt;left = newNode(6);
    root-&amp;gt;right-&amp;gt;right = newNode(7);
//    cout &amp;lt;&amp;lt; &amp;quot;LCA(4, 5) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 4, 5)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(4, 6) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 4, 6)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(3, 4) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 3, 4)-&amp;gt;key;
//    cout &amp;lt;&amp;lt; &amp;quot;\nLCA(2, 4) = &amp;quot; &amp;lt;&amp;lt; findLCA1(root, 2, 4)-&amp;gt;key;

  // cout&amp;lt;&amp;lt;endl;


    Node* p1=NULL;Node* p2=NULL;

    p1= findLCA1(root,6,7);
    p2= findLCA2(root,6,7);
    cout&amp;lt;&amp;lt;&amp;quot;last node1:&amp;quot;&amp;lt;&amp;lt;p1-&amp;gt;key&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;last node2:&amp;quot;&amp;lt;&amp;lt;p2-&amp;gt;key&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;   /*在二叉樹中找到給定兩個節點的最低公共祖先 lowest common ancestor LCA&lt;br&gt;我們做一個規定：如果a是b的祖先，那麼他倆的LCA是a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#
    
    </summary>
    
    
  </entry>
  
</feed>
