<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happy happy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxjttxs.github.io/"/>
  <updated>2016-05-08T14:41:33.443Z</updated>
  <id>http://wxjttxs.github.io/</id>
  
  <author>
    <name>王晓静</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>是不是平衡树</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/05/08/是不是平衡树/</id>
    <published>2016-05-08T14:40:57.000Z</published>
    <updated>2016-05-08T14:41:33.443Z</updated>
    
    <content type="html">&lt;p&gt;//平衡二叉树的概念：左右子树的深度相差不超过1&lt;br&gt;//判断一棵二叉树是不是平衡二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//构建二叉树
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
//*****************方法一****************************
////二叉树的深度
//    int TreeDepth(BinaryTreeNode* pRoot){
//        if(!pRoot)
//            return 0;
//    //    if(!pRoot-&amp;gt;m_pLeft &amp;amp;&amp;amp; !pRoot-&amp;gt;m_pRight)//不需要
//    //        return 1;
//
//        //else{
//            int nLeft=TreeDepth(pRoot-&amp;gt;m_pLeft);
//            int nRight=TreeDepth(pRoot-&amp;gt;m_pRight);
//            return (nLeft&amp;gt;nRight)?(nLeft+1):(nRight+1);
//      //  }
//
//    }
//bool IsBalanced(BinaryTreeNode* pRoot){
//    if(pRoot==NULL)
//        return true;
//    int left=TreeDepth(pRoot-&amp;gt;m_pLeft);
//    int right=TreeDepth(pRoot-&amp;gt;m_pRight);
//    int diff= left-right;
//    if(diff&amp;gt;1 ||diff&amp;lt;-1)
//        return false;
//    return IsBalanced(pRoot-&amp;gt;m_pLeft)&amp;amp;&amp;amp;IsBalanced(pRoot-&amp;gt;m_pRight);
//}
//***********************方法二***********************88
//每个节点遍历一遍，就能判断二叉树是不是平衡的；采用后序遍历,遍历一个节点的时候，它的左右子树已经遍历过了。
//在遍历节点的时候记录 它的深度，就能一边遍历，一边判断每个节点是不是平衡的
bool IsBalancedCore(BinaryTreeNode* pRoot, int* pDepth){
    if(pRoot==NULL){
        *pDepth=0;
        return true;
    }
    int left,right;
    if(IsBalancedCore(pRoot-&amp;gt;m_pLeft,&amp;amp;left)&amp;amp;&amp;amp; IsBalancedCore(pRoot-&amp;gt;m_pRight,&amp;amp;right)){
        int diff=left-right;
        if(diff&amp;lt;=1 &amp;amp;&amp;amp; diff&amp;gt;=-1){
            *pDepth=1+(left&amp;gt;right?left:right);
            return true;
        }
    }
    return false;
}
bool IsBalanced(BinaryTreeNode* pRoot){
    int depth=0;
    return IsBalancedCore(pRoot,&amp;amp;depth);
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    cout&amp;lt;&amp;lt;IsBalanced(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//平衡二叉树的概念：左右子树的深度相差不超过1&lt;br&gt;//判断一棵二叉树是不是平衡二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的深度</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/08/二叉树的深度/</id>
    <published>2016-05-08T13:40:22.000Z</published>
    <updated>2016-05-08T13:41:04.539Z</updated>
    
    <content type="html">&lt;p&gt;//查找二叉树的深度，也就是从根节点到叶子节点所有路径中，最长路径的节点数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
//构建二叉树
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
//二叉树的深度：如果树只有一个节点，那么树的深度就是1；如果没有右子树，
//那么就等于左子树的深度+1；没有左子树的情况类似；如果左右子树都存在，那么就等于两个子树路径较大的那个+1
int TreeDepth(BinaryTreeNode* pRoot){
    if(!pRoot)
        return 0;
//    if(!pRoot-&amp;gt;m_pLeft &amp;amp;&amp;amp; !pRoot-&amp;gt;m_pRight)//不需要
//        return 1;

    //else{
        int nLeft=TreeDepth(pRoot-&amp;gt;m_pLeft);
        int nRight=TreeDepth(pRoot-&amp;gt;m_pRight);
        return (nLeft&amp;gt;nRight)?(nLeft+1):(nRight+1);
  //  }

}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    cout&amp;lt;&amp;lt;TreeDepth(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//查找二叉树的深度，也就是从根节点到叶子节点所有路径中，最长路径的节点数目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct BinaryTreeNode{
    int m_nV
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>指定数字在排序数组中出现的次数</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/08/指定数字在排序数组中出现的次数/</id>
    <published>2016-05-08T13:05:56.000Z</published>
    <updated>2016-05-08T13:06:20.332Z</updated>
    
    <content type="html">&lt;p&gt;//得到已经排序的数组中指定数字k出现的次数&lt;br&gt;//已经排好序，所以想到用二分查找算法；&lt;br&gt;//重复次数=最后一次出现的位置-第一次出现的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int GetFirstK(int *data,int length,int k, int start,int endd){
    if(start&amp;gt;endd)
        return -1;
    int mid=(start+endd)/2;//一分为二
    int midData=data[mid];
    if(midData==k){//中间恰好等于k，那么第一个k的位置要么就是这个中间；要么位于前半段数组
        if((data[mid-1]!=k &amp;amp;&amp;amp; mid&amp;gt;0) || mid==0)
            return mid;
        else
            endd=mid-1;
    }
    else if(midData&amp;gt;k)
        endd=mid-1;
    else
        start=mid+1;
    return GetFirstK(data,length,k,start,endd);
}
int GetLastK(int *data,int length,int k,int start, int endd){
    if(data==NULL||start&amp;gt;endd)
        return -1;
    int mid=(start+endd)/2;//一分为二
    int midData=data[mid];
    if(midData==k){//中间恰好等于k，那么最后一个k的位置要么就是这个中间；要么位于后半段数组
        if((data[mid+1]!=k &amp;amp;&amp;amp; mid+1&amp;lt;length) || mid+1==length){
            return mid;
        }
        else
            start=mid+1;
    }
    else if(midData&amp;lt;k){
        start =mid+1;
    }
    else
        endd=mid-1;
    return GetLastK(data,length,k,start,endd);

}
int GetKNumbers(int *data,int length,int k){
    if(!data || length&amp;lt;=0)
        return -1;
    int number=0;
    int first=GetFirstK(data,length,k,0,length-1);
    int endd=GetLastK(data,length,k,0,length-1);
    if(first&amp;gt;-1 &amp;amp;&amp;amp; endd&amp;gt;-1)
        number= endd-first+1;
    return number;
}
int main()
{
    int data[]={1,2,3,3,3,3,4,5};
    cout&amp;lt;&amp;lt;GetKNumbers(data,8,1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//得到已经排序的数组中指定数字k出现的次数&lt;br&gt;//已经排好序，所以想到用二分查找算法；&lt;br&gt;//重复次数=最后一次出现的位置-第一次出现的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>两个链表的第一个公共节点</title>
    <link href="http://wxjttxs.github.io/2016/05/08/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/08/两个链表的第一个公共节点/</id>
    <published>2016-05-08T07:06:14.000Z</published>
    <updated>2016-05-08T07:06:54.040Z</updated>
    
    <content type="html">&lt;p&gt;//得到两个链表第一个公共节点并返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}

unsigned int GetListLength(ListNode* pHead);

int FindFirstCommonNode( ListNode *pHead1, ListNode *pHead2)
{
    // 得到两个链表的长度
    unsigned int nLength1 = GetListLength(pHead1);
    unsigned int nLength2 = GetListLength(pHead2);
    int nLengthDif = nLength1 - nLength2;

    ListNode* pListHeadLong = pHead1;
    ListNode* pListHeadShort = pHead2;
    if(nLength2 &amp;gt; nLength1)
    {
        pListHeadLong = pHead2;
        pListHeadShort = pHead1;
        nLengthDif = nLength2 - nLength1;
    }

    // 先在长链表上走几步，再同时在两个链表上遍历
    for(int i = 0; i &amp;lt; nLengthDif; ++ i)
        pListHeadLong = pListHeadLong-&amp;gt;m_pNext;

    while((pListHeadLong != NULL) &amp;amp;&amp;amp;
        (pListHeadShort != NULL) &amp;amp;&amp;amp;
        (pListHeadLong-&amp;gt;m_nValue != pListHeadShort-&amp;gt;m_nValue))
    {
        pListHeadLong = pListHeadLong-&amp;gt;m_pNext;
        pListHeadShort = pListHeadShort-&amp;gt;m_pNext;
    }
    if(!pListHeadLong &amp;amp;&amp;amp; !pListHeadShort)//没有公共节点

        return 0;
    if(pListHeadLong-&amp;gt;m_nValue == pListHeadShort-&amp;gt;m_nValue){
        ListNode* pFisrtCommonNode = pListHeadLong;// 得到第一个公共结点
        return pFisrtCommonNode-&amp;gt;m_nValue;
    }


}

unsigned int GetListLength(ListNode* pHead)
{
    unsigned int nLength = 0;
    ListNode* pNode = pHead;
    while(pNode != NULL)
    {
        ++ nLength;
        pNode = pNode-&amp;gt;m_pNext;
    }

    return nLength;
}

int main()
{
    List l1=NULL;
    Insert(l1,7);
    Insert(l1,6);
    Insert(l1,3);
    Insert(l1,2);
    Insert(l1,1);
    Print(l1);


    List l2=NULL;
    Insert(l2,7);
    Insert(l2,7);
    Insert(l2,5);
    Insert(l2,4);
    Print(l2);
    int tmp=FindFirstCommonNode(l1,l2);
    cout&amp;lt;&amp;lt;tmp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//得到两个链表第一个公共节点并返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef struct ListNode{
    int
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>逆序对</title>
    <link href="http://wxjttxs.github.io/2016/05/07/post%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://wxjttxs.github.io/2016/05/07/post逆序对/</id>
    <published>2016-05-07T09:00:04.000Z</published>
    <updated>2016-05-08T11:56:14.493Z</updated>
    
    <content type="html">&lt;p&gt;//一个数组中的元素构成的逆序对数目&lt;br&gt;//分治法，递归，类似于堆排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int InversePairsCore(int* data, int* cpy,int start, int endd){
    if(start==endd){
        cpy[start]=data[start];
        return 0;
    }
    int half_len=(endd-start)/2;
    int left=InversePairsCore(cpy,data,start,start+half_len);//子数组内部构成的逆序对,有两步操作：1是统计逆序对数目；2是排序（方便计算子数组间的逆序数数目）
    int right=InversePairsCore(cpy,data,start+half_len+1,endd);//注意前两个参数的顺序。第一个参数代表的是排好序的数组。

    int i=start+half_len;//子数组之间的逆序对,子数组是有序的
    int j=endd;
    int cpyIndex=endd;
    int countt=0;
    while(i&amp;gt;=start &amp;amp;&amp;amp; j&amp;gt;=start+half_len+1){
         if(data[i]&amp;gt;data[j]){
            cpy[cpyIndex--]=data[i--];//从右往左，从大往小放进辅助数组中
            countt+=j-start-half_len;//j代表的右边子数组中大的那个数字,所以它之前的数字均能与左边子数组构成逆序对
         }
         else{
            cpy[cpyIndex--]=data[j--];
         }
    }
    for(;i&amp;gt;=start;i--){//j到头了，终止退出循环
        cpy[cpyIndex--]=data[i];
    }
    for(;j&amp;gt;=start+half_len+1;j--)
        cpy[cpyIndex--]=data[j];
    return left+right+countt;
}
int InversePairs(int *data,int length){
    if(data==NULL||length&amp;lt;=0)
        return 0;
    int *cpy=new int [length];//辅助数组
    for(int i=0;i&amp;lt;length;i++){
        cpy[i]=data[i];
    }
    int countt=InversePairsCore(data,cpy,0,length-1);
    delete[] cpy;
    return countt;
}
int main()
{
    int a[]={7,5,6,4};
    cout &amp;lt;&amp;lt; InversePairs(a,4)&amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//一个数组中的元素构成的逆序对数目&lt;br&gt;//分治法，递归，类似于堆排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
int InversePairsCore(int* data, int*
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="http://wxjttxs.github.io/2016/05/07/post%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://wxjttxs.github.io/2016/05/07/post第一个只出现一次的字符/</id>
    <published>2016-05-07T07:45:45.000Z</published>
    <updated>2016-05-07T09:00:45.903Z</updated>
    
    <content type="html">&lt;p&gt;//考察哈希表；字符串&lt;br&gt;//第一个只出现一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
char FirstNotReaptingChar(char* pString){
    if(!pString)
        return &amp;apos;\0&amp;apos;;
    const int tableSize=256;
    unsigned int hashTable[tableSize];
    for(int i=0;i&amp;lt;tableSize;i++)
        hashTable[i]=0;
    char* pHashKey=pString;//第一遍统计各个字符出现的次数，字符作为下标
    while(*pHashKey!=&amp;apos;\0&amp;apos;)
        hashTable[*(pHashKey++)]++;
    pHashKey=pString;//第二遍，从头开始找第一次只出现一遍的字符。
    while(*pHashKey!=&amp;apos;\0&amp;apos;){
        if(hashTable[*pHashKey]==1)
            return *pHashKey;
        pHashKey++;
    }
    return &amp;apos;\0&amp;apos;;

}
int main()
{
    cout &amp;lt;&amp;lt;FirstNotReaptingChar(&amp;quot;aaaccdeff&amp;quot;)&amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//考察哈希表；字符串&lt;br&gt;//第一个只出现一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
char FirstNotReaptingChar(char* pString){
    if
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组排成最小的数</title>
    <link href="http://wxjttxs.github.io/2016/05/06/%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/06/数组排成最小的数/</id>
    <published>2016-05-06T08:17:20.000Z</published>
    <updated>2016-05-06T08:26:51.458Z</updated>
    
    <content type="html">&lt;p&gt;//把数组中数字拼接起来，并打印最小的和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

// int型整数用十进制表示最多只有10位
const int g_MaxNumberLength=10;
char* g_StrCombine1=new char[g_MaxNumberLength*2+1];
char* g_StrCombine2=new char[g_MaxNumberLength*2+1];
// 如果[strNumber1][strNumber2] &amp;gt; [strNumber2][strNumber1], 返回值大于0
// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0
// 如果[strNumber1][strNumber2] &amp;lt; [strNumber2][strNumber1], 返回值小于0
int compare(const void* strNumber1,const void* strNumber2){//比较mn   VS nm
    strcpy(g_StrCombine1,*(const char**)strNumber1);
    strcat(g_StrCombine1,*(const char**)strNumber2);

    strcpy(g_StrCombine2,*(const char**)strNumber2);
    strcat(g_StrCombine2,*(const char**)strNumber1);
    return strcmp(g_StrCombine1,g_StrCombine2);
}
void PrintMinNumber(int *numbers,int length){
    if(numbers==NULL||length&amp;lt;0)
        return ;
    char** strNumbers=(char**)(new int[length]);
    for(int i=0;i&amp;lt;length;i++){
        strNumbers[i]=new char[g_MaxNumberLength+1];
        sprintf(strNumbers[i],&amp;quot;%d&amp;quot;,numbers[i]);
        //数值转换为字符串，比如numbers存储的是{3,32,321}，那么//strNumber存储的是{&amp;quot;3&amp;quot;,&amp;quot;32&amp;quot;,&amp;quot;321&amp;quot;}
    }
    qsort(strNumbers,length,sizeof(char*),compare);//对字符串数组进行排序，由小到大
    for(int i=0;i&amp;lt;length;i++)
        printf(&amp;quot;%s&amp;quot;,strNumbers[i]);
    printf(&amp;quot;\n&amp;quot;);
    for(int i=0;i&amp;lt;length;i++)
        delete[] strNumbers[i];
    delete[] strNumbers;
}
int main()
{
    int a[]={3,32,321};
    PrintMinNumber(a,3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//把数组中数字拼接起来，并打印最小的和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找到第n个ugly number</title>
    <link href="http://wxjttxs.github.io/2016/05/06/%E6%89%BE%E5%88%B0%E7%AC%ACn%E4%B8%AAugly-number/"/>
    <id>http://wxjttxs.github.io/2016/05/06/找到第n个ugly-number/</id>
    <published>2016-05-06T08:15:23.000Z</published>
    <updated>2016-05-07T03:53:28.348Z</updated>
    
    <content type="html">&lt;p&gt;//因子只包含2,3,5的数叫做丑数,&lt;br&gt;//找到第n个丑数，1是第一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//***********************第一种方法***********************
//bool IsUglyNumber(int n){
//    while(n%2==0)
//        n/=2;
//    while(n%3==0)
//        n/=3;
//    while(n%5==0)
//        n/=5;
//    return (n==1)?true:false;
//}
//int GetUglyNumber(int index){
//    if(index&amp;lt;0)
//        return 0;
//    int number=0;
//    int uglyFound=0;
//    while(uglyFound&amp;lt;index){
//        ++number;
//        if(IsUglyNumber(number))
//            ++uglyFound;
//    }
//    return number;
//
//}
//**********************第二种方法***********************
//保存已经排好序的丑数
int Min(int n1,int n2,int n3){
    int mint=(n1&amp;lt;n2)?n1:n2;
    mint=(mint&amp;lt;n3)?mint:n3;
    return mint;
}
int GetUglyNumber(int index){
    if(index&amp;lt;0)
        return 0;
    int *pUglyNumbers=new int[index];
    pUglyNumbers[0]=1;//保存已经排好序的丑数
    int nextUglyIndex=1;//第i个丑数的位置
    int *pMultiplu2=pUglyNumbers;
    int *pMultiplu3=pUglyNumbers;
    int *pMultiplu5=pUglyNumbers;
    while(nextUglyIndex&amp;lt;index){
        int mintt=Min(*pMultiplu2*2,*pMultiplu3*3,*pMultiplu5*5);//取比当前最大丑数大的最小值
        pUglyNumbers[nextUglyIndex]=mintt;
        while(*pMultiplu2*2&amp;lt;=pUglyNumbers[nextUglyIndex])
            ++pMultiplu2;//这个位置之前的数乘2都比当前丑数的最大值要小;退出时候均比当前最大丑数大的最小值
        while(*pMultiplu3*3&amp;lt;=pUglyNumbers[nextUglyIndex])
            ++pMultiplu3;
        while(*pMultiplu5*5&amp;lt;=pUglyNumbers[nextUglyIndex])
            ++pMultiplu5;
        ++nextUglyIndex;

    }
    int ugly=pUglyNumbers[nextUglyIndex-1];
    delete[] pUglyNumbers;
    return ugly;

}
int main()
{
    cout &amp;lt;&amp;lt;GetUglyNumber(4) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//因子只包含2,3,5的数叫做丑数,&lt;br&gt;//找到第n个丑数，1是第一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//***********************第一种方法*****
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从1到N整数中1出现的次数</title>
    <link href="http://wxjttxs.github.io/2016/05/03/%E4%BB%8E1%E5%88%B0N%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/05/03/从1到N整数中1出现的次数/</id>
    <published>2016-05-03T11:31:40.000Z</published>
    <updated>2016-05-03T11:32:41.043Z</updated>
    
    <content type="html">&lt;p&gt;//给定数字N，计算从1~N中各个数字位上包含1的个位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//方法1，暴力穷举,一个数需要o(logn),一共需要n*O(logn)
int NumberOf1(unsigned int n){
    int number=0;
    while(n){//从个位往高位计算给定的数字n包含的数字1的个数
        if(n%10==1)
            number++;

        n=n/10;
    }
    return  number;
}
int NumberOf1Between1AndN(unsigned int n){
    int number=0;
    for(int i=1;i&amp;lt;=n;i++)
        number+=NumberOf1(i);
    return number;
}
//方法二，递归
//数字转换为 字符串更方便//递归一次去掉一位，所以时间复杂度编程O(logn)
int PowerBase10(unsigned int n){
    int result=1;
    for(unsigned int i=0;i&amp;lt;n;i++)
        result*=10;
    return result;
}
int NumberOf1(const char* strN){
    if(!strN||*strN&amp;lt;&amp;apos;0&amp;apos;||*strN&amp;gt;&amp;apos;9&amp;apos;||*strN==&amp;apos;\0&amp;apos;)
        return 0;
    int first=*strN-&amp;apos;0&amp;apos;;
    unsigned int length=static_cast&amp;lt;unsigned int&amp;gt;(strlen(strN));
    if(length==1&amp;amp;&amp;amp;first==0)
        return 0;
    if(length==1&amp;amp;&amp;amp; first&amp;gt;0)
        return 1;
    //假设strN=&amp;quot;21345&amp;quot;
    //numberFirstDigit是数字10000~19999的第一个位中的数目
    int numFirstDigit=0;
    if(first&amp;gt;1)
        numFirstDigit=PowerBase10(length-1);
    else if(first==1)
        numFirstDigit=atoi(strN+1)+1;
    //numberOtherDigits是1346~21346除第一位之外的数位中的数目
    int numOtherDigits=first*(length-1)*PowerBase10(length-2);
    //numRecursive是1~1345中的数目
    int numRecursive=NumberOf1(strN+1);
    return numFirstDigit+numOtherDigits+numRecursive;
}

int NumberOf1Between1AndN(int n){
    if(n&amp;lt;=0)
        return 0;
    char strN[50];
    sprintf(strN,&amp;quot;%d&amp;quot;,n);
    return NumberOf1(strN);
}

int main()
{
    cout&amp;lt;&amp;lt;NumberOf1Between1AndN(21345);
    //cout&amp;lt;&amp;lt;PowerBase10(2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//给定数字N，计算从1~N中各个数字位上包含1的个位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;cstring
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>子数组最大和</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://wxjttxs.github.io/2016/05/02/子数组最大和/</id>
    <published>2016-05-02T14:54:25.000Z</published>
    <updated>2016-05-02T14:56:39.653Z</updated>
    
    <content type="html">&lt;p&gt;//数组的最大子数组的和并返回&lt;br&gt;//动态规划分f(i)=pData[i] i=0 or f(i-1)&amp;lt;=0;&lt;br&gt;//f(i)=f(i-1)+pData[i]  i!=0 and f(i-)&amp;gt;0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
bool g_InvalidInput=false;//标记结果0到底是无效输入还是 最大和是0
int FindGreatestSumOfSubArray(int* pData,int nLength){
    if(pData==NULL||nLength&amp;lt;=0){
        g_InvalidInput=true;
        return 0;
    }
    g_InvalidInput=false;
    int nCurSum=0;
    int nGreatestSum=0x80000000;
    for(int i=0;i&amp;lt;nLength;i++){
        if(nCurSum&amp;lt;=0)
            nCurSum=pData[i];
        else
            nCurSum+=pData[i];
        if(nCurSum&amp;gt;nGreatestSum)
            nGreatestSum=nCurSum;
    }


return nGreatestSum;
}

int main()
{
    int a[]={1,-2,3,10,-4,7,2,-5};
    cout&amp;lt;&amp;lt;FindGreatestSumOfSubArray(a,8);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//数组的最大子数组的和并返回&lt;br&gt;//动态规划分f(i)=pData[i] i=0 or f(i-1)&amp;lt;=0;&lt;br&gt;//f(i)=f(i-1)+pData[i]  i!=0 and f(i-)&amp;gt;0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最小的K个数</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E2%80%9C%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%E2%80%9C/"/>
    <id>http://wxjttxs.github.io/2016/05/02/“最小的K个数“/</id>
    <published>2016-05-02T14:24:15.000Z</published>
    <updated>2016-05-02T14:25:53.110Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;vector&amp;gt;

using namespace std;
//0(n)时间找到最小的K个数，而且这K个数是排好序的，但是会修改原始数组
//借鉴快排的划分

//int Partition(int *a, int start ,int ent){
//    if(a==NULL||start&amp;lt;0||ent&amp;lt;0)
//        throw new exception();
//    int temp=a[ent];//最后一个值作为基准
//    int i=start-1;
//    for(int j=start;j&amp;lt;ent;j++){
//        if(a[j]&amp;lt;=temp){
//            i++;
//            swap(a[i],a[j]);
//        }
//    }
//    swap(a[i+1],a[ent]);
//    return i+1;
//}
//void GetLeastNumber(int *input,int n,int k){
//   // int output[k]={0};
//    if(input==NULL||n&amp;lt;=0||k&amp;lt;=0||k&amp;gt;n)
//        return;
//    int start=0;
//    int endt=n-1;
//    int index=Partition(input,start,endt);
//    while(index!=k-1){
//        if(index&amp;lt;k-1){
//            start=index+1;
//           index=Partition(input,start,endt);
//        }
//        else{
//            endt=index-1;
//            index=Partition(input,start,endt);
//        }
//    }
//    for(int i=0;i&amp;lt;=index;i++){
//
//        cout&amp;lt;&amp;lt;input[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
//    }
//    cout&amp;lt;&amp;lt;endl;
//
//}
//int main()
//{
//    int a[]={4,5,1,6,2,7,3,8};
//
//    GetLeastNumber(a,8,6);
//    return 0;
//}

//****************方法二********************************
//上面的时间很快，但是会改变原始数据
//所以用一个k大的容器 来装k个最小值，容器没有满那就直接插入。如果满了，那就做三件事：1.找到容器中最大值；2.删除最大值；3.插入新的数据
//找到最大值，最快的是最大堆，基于红黑树结构实现的set and multiset
typedef multiset&amp;lt;int,greater&amp;lt;int&amp;gt; &amp;gt; intSet;//greater作用实现降序排列
typedef multiset&amp;lt;int ,greater&amp;lt;int&amp;gt; &amp;gt;::iterator setItertor;
void GetLeastNumbers(const vector&amp;lt;int&amp;gt;&amp;amp; data, intSet&amp;amp; leastNumber,int k){
    leastNumber.clear();
    if(k&amp;lt;1||data.size()&amp;lt;k)
        return;
    vector&amp;lt;int&amp;gt;::const_iterator iter=data.begin();
    for(;iter!=data.end();++iter){

        if(leastNumber.size()&amp;lt;k)
            leastNumber.insert(*iter);
        else{
            setItertor iterGreatest=leastNumber.begin();
            if(*iter&amp;lt;*(leastNumber.begin())){
                leastNumber.erase(iterGreatest);
                leastNumber.insert(*iter);
            }
        }
    }
}
int main(){
    int a[8]={4,5,1,6,2,7,3,8};

    vector&amp;lt;int&amp;gt; data(a,a+8);
    intSet leastNumber;
    GetLeastNumbers(data,leastNumber,8);
    cout&amp;lt;&amp;lt;&amp;quot;the actual output numbers are:&amp;quot;&amp;lt;&amp;lt;endl;
    for(setItertor iter=leastNumber.begin();iter!=leastNumber.end();iter++)
        cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;vector&amp;gt;

using namespace std;
//0(n)时间找到最小
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E2%80%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97hexo-new-post-%E2%80%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wxjttxs.github.io/2016/05/02/“数组中出现次数超过一半的数字hexo-new-post-“数组中出现次数超过一半的数字/</id>
    <published>2016-05-02T12:31:42.000Z</published>
    <updated>2016-05-02T12:32:25.888Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//是不是有效输入
bool IsValidMatrix(int * matrix,int length){
    if(matrix==NULL||length&amp;lt;=0)
        return false;
    return  true;
}
//如果出现次数最多的也不能达到数组长度的一半怎么办呢
bool IsMoreThanHalf(int* matrix,int length,int number){//number 是数组中出现次数最大的那个数
    int countt=0;
    for(int i=0;i&amp;lt;length;i++){
        if(matrix[i]==number)
            countt++;
    }
    if(countt*2&amp;lt;length)
        return false;
    return true;
}
int MoreThanHalfNum(int *matrix,int length){
    if(IsValidMatrix(matrix,length)){
        int MaxNumber=matrix[0];
        int times=1;
        for(int i=1;i&amp;lt;length;i++){//此后的数字相同的加1，不同的减1，直到times变成0，从下一个数字开始重头开始这个过程。
            if(times==0){
                MaxNumber=matrix[i];//重新开始  1,2,2
                times=1;
            }
           else if(MaxNumber==matrix[i])
                times++;
            else{

                times--;
            }
        }
        if(IsMoreThanHalf(matrix,length,MaxNumber)){

            return MaxNumber;
        }


        else
            cout&amp;lt;&amp;lt;&amp;quot;无效&amp;quot;;
    }

}
int main()
{
    int a[]={1};
    cout&amp;lt;&amp;lt;MoreThanHalfNum(a,1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
//是不是有效输入
bool IsValidMatrix(int * matrix,int length){
    if(matrix==NULL||lengt
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串全排列(去重)以及全组合（2^n-1）</title>
    <link href="http://wxjttxs.github.io/2016/05/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/05/02/字符串全排列/</id>
    <published>2016-05-02T07:26:54.000Z</published>
    <updated>2016-05-02T11:43:51.677Z</updated>
    
    <content type="html">&lt;p&gt;//实现字符串每个字符 的全排列,并求取全排列的个数&lt;br&gt;//分为三部分：1.首先，求取所有可能出现在第一个位置的字符；&lt;br&gt;//2.其次，把第一个字符和其后面的字符一一交换；&lt;br&gt;//3.接着，固定第一个字符，求后面所有字符的排列。重复步骤2&lt;/p&gt;
&lt;p&gt;   //全排列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
//  调试开关
#define __tmain main

#ifdef __tmain

#define debug cout

#else

#define debug 0 &amp;amp;&amp;amp; cout

#endif // __tmain
class Solution{
protected:
    vector&amp;lt;string&amp;gt; m_res;//字符数组，存储排好序的字符串
public:
    void Permutation(string str){
        int countt=0;
        m_res.clear();
        if(str.empty())
            return ;

        Perm(str,0);

        sort(m_res.begin(),m_res.end());
        //删除容器中重复 元素
        vector&amp;lt;string&amp;gt;::iterator new_end;
        new_end=unique(m_res.begin(),m_res.end());//把重复元素放在容器末尾
        //assert(m_res.size()==N);
        m_res.erase(new_end,m_res.end());//真正删除重复元素
        //输出容器中元素
        vector&amp;lt;string&amp;gt;::iterator iter=m_res.begin();
        for(;iter!=m_res.end();iter++)
        {
            countt++;
            cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;endl;
        }
        cout&amp;lt;&amp;lt;endl;
        cout&amp;lt;&amp;lt;countt&amp;lt;&amp;lt;endl;
       // return m_res;

    }

    void Perm(string str,int Begin){//str要排序的字符串，Begin代表排序部分的第一个字符的位置
        if(str[Begin]==&amp;apos;\0&amp;apos;){//全部已经排好序
           // debug&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl;
            m_res.push_back(str);
        }
        for(int i=Begin;str[i]!=&amp;apos;\0&amp;apos;;i++){
            if(i==Begin||str[i]!=str[Begin]){//排除重复
                swap(str[i],str[Begin]);//排序部分第一个位置的字符全部找到
                Perm(str,Begin+1);//递归排序之后的字符
                swap(str[i],str[Begin]);

            }
        }
    }
};
int __tmain( )
{
    Solution solu;
    solu.Permutation(&amp;quot;abb&amp;quot;);

    return 0;
}


//********************************************************************
//组合。从n个字符中挑选m个字符放到组合当中。有两个方案：第一个字符放到组合当中，剩下的m-1个字符从n-1个字符中挑选，
//另一种方案：第一个字符不放到组合当中，那么从剩下的n-1中挑选m-1个字符放到组合当中
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
#include&amp;lt;assert.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;

void Combination(char *string ,int number,vector&amp;lt;char&amp;gt; &amp;amp;result);

void Combination(char *string)
{
    assert(string != NULL);
    vector&amp;lt;char&amp;gt; result;
    int i , length = strlen(string);
    for(i = 1 ; i &amp;lt;= length ; ++i)
        Combination(string , i ,result);
}

void Combination(char *string ,int number , vector&amp;lt;char&amp;gt; &amp;amp;result)
{
    assert(string != NULL);
    if(number == 0)
    {
        static int num = 1;
        printf(&amp;quot;第%d个组合\t&amp;quot;,num++);

        vector&amp;lt;char&amp;gt;::iterator iter = result.begin();
        for( ; iter != result.end() ; ++iter)
            printf(&amp;quot;%c&amp;quot;,*iter);
        printf(&amp;quot;\n&amp;quot;);
        return ;
    }
    if(*string == &amp;apos;\0&amp;apos;)
        return ;
    result.push_back(*string);
    Combination(string + 1 , number - 1 , result);
    result.pop_back();
    Combination(string + 1 , number , result);
}

int main(void)
{
    char str[] = &amp;quot;abc&amp;quot;;
    Combination(str);
    return 0;
}


//******************************************************************
//组合，位运算，没有解决重复问题,组合中出现这个字符，那么字符所在位置为1，否则为0.a:100,b:010...
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
void Combination(string str){
    int countt=0;
    if(str.empty())
        return;
    int len=str.size();
    for(int i=1;i&amp;lt;(1&amp;lt;&amp;lt;len);i++){//从0~2^n-1，中可能出现的情况
        for(int j=0;j&amp;lt;len;j++){
            if(i&amp;amp;(1&amp;lt;&amp;lt;j)){//这个位置上有数
                cout&amp;lt;&amp;lt;str[j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;

            }
        }
        countt++;
        cout&amp;lt;&amp;lt;endl;

    }
    cout&amp;lt;&amp;lt;countt;
}
int main(){
    Combination(&amp;quot;abc&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   //&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;**&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;br&gt;   //八皇后问题。不同行，不同列，不同斜角线。&lt;/p&gt;
&lt;p&gt;#include&lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;
&lt;p&gt;#include&lt;stdio.h&gt;&lt;br&gt;using namespace std;&lt;br&gt;int count_number=0;&lt;br&gt;bool isDiagnal(int ColumnIndex[],int length){&lt;br&gt;    for(int i=0;i&amp;lt;length;i++){&lt;br&gt;        for(int j=i+1;j&amp;lt;length;j++){&lt;br&gt;            if(i-j==ColumnIndex[i]-ColumnIndex[j] || j-i==ColumnIndex[i]-ColumnIndex[j])//对角关系&lt;br&gt;                return false;&lt;br&gt;        }&lt;/stdio.h&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
return true;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;void Print(int ColumnIndex[],int length){&lt;br&gt;    cout&amp;lt;&amp;lt;count_number&amp;lt;&amp;lt;”:”;&lt;br&gt;    for(int  i=0;i&amp;lt;length;i++){&lt;br&gt;        cout&amp;lt;&amp;lt;ColumnIndex[i]&amp;lt;&amp;lt;” “;//输出列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
cout&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void Permutation(int ColumnIndex[],int length,int index){&lt;br&gt;    if(index==length){//index代表排列好的列&lt;br&gt;        if(isDiagnal(ColumnIndex,length)){//状态合法，没有斜对角关系&lt;br&gt;            count_number++;//一次符合要求的状态&lt;br&gt;            Print(ColumnIndex,length);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    else{&lt;br&gt;        for(int i=index;i&amp;lt;length;i++){&lt;br&gt;            swap(ColumnIndex[index],ColumnIndex[i]);//第一个位置可能的情况&lt;br&gt;            Permutation(ColumnIndex,length,index+1);//递归后面的部分分成第一个元素以及剩下的元素&lt;br&gt;            swap(ColumnIndex[index],ColumnIndex[i]);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;void EightQueen(){&lt;br&gt;    const int length=8;&lt;br&gt;    int ColumnIndex[length];&lt;br&gt;    for(int i=0;i&amp;lt;length;i++){&lt;br&gt;        ColumnIndex[i]=i;//下标表示行，值代表列&lt;br&gt;    }&lt;br&gt;    Permutation(ColumnIndex,length,0);&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;int main(void)&lt;br&gt;{&lt;br&gt;    EightQueen();&lt;br&gt;    return 0;&lt;br&gt;}&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//实现字符串每个字符 的全排列,并求取全排列的个数&lt;br&gt;//分为三部分：1.首先，求取所有可能出现在第一个位置的字符；&lt;br&gt;//2.其次，把第一个字符和其后面的字符一一交换；&lt;br&gt;//3.接着，固定第一个字符，求后面所有字符的排列。重复步骤2&lt;/p&gt;
&lt;p&gt;   /
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BST转换双向链表</title>
    <link href="http://wxjttxs.github.io/2016/05/02/BST%E8%BD%AC%E6%8D%A2%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://wxjttxs.github.io/2016/05/02/BST转换双向链表/</id>
    <published>2016-05-02T02:48:02.000Z</published>
    <updated>2016-05-02T07:28:46.433Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//实现二叉搜索树到双向链表的转换
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot){
    if(!pTreeRoot)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; que;
    que.push(pTreeRoot);
    while(que.size()){
        BinaryTreeNode* pNode=que.front();//指向队列的第一个元素，要被弹出的元素
        que.pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft)//打印节点的左右子节点
            que.push(pNode-&amp;gt;m_pLeft);
        if(pNode-&amp;gt;m_pRight)
            que.push(pNode-&amp;gt;m_pRight);
    }
}
void Print(BinaryTreeNode*  &amp;amp;pHead){
    if(pHead==NULL)
        return ;
    BinaryTreeNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pRight;
    }
    cout&amp;lt;&amp;lt;endl;
}
BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void CovertNode(BinaryTreeNode* pNode,BinaryTreeNode** pLastNodeInList){
    if(pNode==NULL)
        return;
    BinaryTreeNode* pCurrent=pNode;
    if(pCurrent-&amp;gt;m_pLeft!=NULL)//转换左子树为排序的双向链表
        CovertNode(pCurrent-&amp;gt;m_pLeft,pLastNodeInList);
    pCurrent-&amp;gt;m_pLeft=*pLastNodeInList;//pCurrent指向根节点
    if(*pLastNodeInList!=NULL)
        (*pLastNodeInList)-&amp;gt;m_pRight=pCurrent;//连接上根节点
    *pLastNodeInList=pCurrent;//当前双向链表的最后一个几点就是根节点
    if(pCurrent-&amp;gt;m_pRight!=NULL)
        CovertNode(pCurrent-&amp;gt;m_pRight,pLastNodeInList);

}
BinaryTreeNode* Covert(BinaryTreeNode* pRootOfTree){
    BinaryTreeNode* pLastNodeInList=NULL;//双向链表为 空
    CovertNode(pRootOfTree,&amp;amp;pLastNodeInList);
    //pLastNodeInList指向双向链表的最后
    //我们需要返回最后结点
    BinaryTreeNode* pHeadOfList=pLastNodeInList;
    while(pHeadOfList!=NULL &amp;amp;&amp;amp; pHeadOfList-&amp;gt;m_pLeft!=NULL)//最后找到双向链表的头结点
        pHeadOfList=pHeadOfList-&amp;gt;m_pLeft;
    return pHeadOfList;
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,6,4,8,14,12,16};
    int inorder[]={4,6,8,10,12,14,16};
    Btree= Contrust(preorder,inorder,7);
    PrintFromTopToBottom(Btree);
    cout&amp;lt;&amp;lt;endl;

    BinaryTreeNode* L=Covert(Btree);

    Print(L);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//实现二叉搜索树到双向链表的转换
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复制复杂链表</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8/"/>
    <id>http://wxjttxs.github.io/2016/04/30/复制复杂链表/</id>
    <published>2016-04-30T14:54:35.000Z</published>
    <updated>2016-04-30T14:55:44.459Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//复制复杂链表
#include &amp;lt;iostream&amp;gt;

using namespace std;
struct ComplexListNode{
    int m_nValue;
    ComplexListNode* m_pNext;
    ComplexListNode* m_pSibling;
};
void Insert(ComplexListNode* &amp;amp;pHead,int data){
    ComplexListNode* pNode=new ComplexListNode();
    pNode-&amp;gt;m_nValue=data;
    pNode-&amp;gt;m_pNext=NULL;
    pNode-&amp;gt;m_pSibling=NULL;
    if(pHead==NULL)
        pHead=pNode;
    else{
        pNode-&amp;gt;m_pNext=pHead;
        pHead=pNode;
    }
}
void Print(ComplexListNode* &amp;amp;pHead){
    if(pHead==NULL)
        return;
    ComplexListNode* pNode=pHead;
    while(pNode){
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        pNode=pNode-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
//第一步复制各个节点，并形成链表
void CloneNodes(ComplexListNode* pHead){
    ComplexListNode *pNode=pHead;
    while(pNode!=NULL){
        ComplexListNode* pCloned=new ComplexListNode();
        pCloned-&amp;gt;m_nValue=pNode-&amp;gt;m_nValue;
        pCloned-&amp;gt;m_pNext=pNode-&amp;gt;m_pNext;
        pCloned-&amp;gt;m_pSibling=NULL;
        pNode-&amp;gt;m_pNext=pCloned;//插入Cloned节点
        pNode=pCloned-&amp;gt;m_pNext;   //依次往后挪
    }
}
//复制原来节点m_pSibling指针的指向情况
void ConnectSiblingNodes(ComplexListNode* pHead){
    ComplexListNode* pNode=pHead;
    while(pNode!=NULL){
        ComplexListNode* pCloned=pNode-&amp;gt;m_pNext;
        if(pNode-&amp;gt;m_pSibling!=NULL)
                pCloned-&amp;gt;m_pSibling=pNode-&amp;gt;m_pSibling-&amp;gt;m_pNext;
        pNode=pCloned-&amp;gt;m_pNext;
    }
}
//按照奇偶位置拆分原始链表和复制链表
ComplexListNode* ReconnectNodes(ComplexListNode* pHead){
    ComplexListNode* pNode=pHead;
    ComplexListNode* pClonedHead=NULL;
    ComplexListNode* pClonedNode=NULL;
    if(pNode!=NULL){
        pClonedHead=pClonedNode=pNode-&amp;gt;m_pNext;
        pNode-&amp;gt;m_pNext=pClonedNode-&amp;gt;m_pNext;
        pNode=pNode-&amp;gt;m_pNext;
        while(pNode!=NULL){
            pClonedNode-&amp;gt;m_pNext=pNode-&amp;gt;m_pNext;
            pClonedNode=pClonedNode-&amp;gt;m_pNext;
            pNode-&amp;gt;m_pNext=pClonedNode-&amp;gt;m_pNext;
            pNode=pNode-&amp;gt;m_pNext;

        }
        return pClonedHead;
    }
}
ComplexListNode* Clone(ComplexListNode* pHead){
    CloneNodes(pHead);
    ConnectSiblingNodes(pHead);
    return ReconnectNodes(pHead);
}
int main()
{
    ComplexListNode* l=NULL;
    ComplexListNode* c=NULL;
    Insert(l,1);
    Insert(l,2);
    Insert(l,3);
    Insert(l,4);
    Insert(l,5);
    Print(l);

    c=Clone(l);
    Print(c);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//复制复杂链表
#include &amp;lt;iostream&amp;gt;

using namespace std;
struct ComplexListNode{
    int m_nValue;
    ComplexListNode* m_pNext;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树中和为给定值的路径</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://wxjttxs.github.io/2016/04/30/二叉树中和为给定值的路径/</id>
    <published>2016-04-30T13:27:40.000Z</published>
    <updated>2016-04-30T13:28:24.945Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//给定二叉树和一个值，找到二叉树中和等于这个值的路径
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void FindAllPath(BinaryTreeNode* pRoot,int expectedSum,vector&amp;lt;int&amp;gt;&amp;amp; path,int currentSum){
    currentSum+=pRoot-&amp;gt;m_nValue;
    path.push_back(pRoot-&amp;gt;m_nValue);
    bool isLeaf=(pRoot-&amp;gt;m_pLeft==NULL)&amp;amp;&amp;amp;(pRoot-&amp;gt;m_pRight==NULL);
    //叶子节点，并且路径上的节点的和等于期望的和
    if(currentSum==expectedSum &amp;amp;&amp;amp; isLeaf){
        cout&amp;lt;&amp;lt;&amp;quot;the path is found:&amp;quot;;
        vector&amp;lt;int&amp;gt;::iterator iter=path.begin();
        for(;iter!=path.end();iter++)
            cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        cout&amp;lt;&amp;lt;endl;
    }
    //不是叶子节点，那就继续遍历左右子树
    if(pRoot-&amp;gt;m_pLeft)
        FindAllPath(pRoot-&amp;gt;m_pLeft,expectedSum,path,currentSum);
    if(pRoot-&amp;gt;m_pRight)
        FindAllPath(pRoot-&amp;gt;m_pRight,expectedSum,path,currentSum);
    //是叶子节点，但是路径的和并不等于期望的和,那就回退
    path.pop_back();
}
void FindPath(BinaryTreeNode* pRoot,int expectedSum){
    if(pRoot==NULL)
        return;
    vector&amp;lt;int&amp;gt; path;
    int currentSum=0;
    FindAllPath(pRoot,expectedSum,path,currentSum);
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    FindPath(Btree,22);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//给定二叉树和一个值，找到二叉树中和等于这个值的路径
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
struct Bi
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>后序序列可以构成BST？</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8F%AF%E4%BB%A5%E6%9E%84%E6%88%90BST%EF%BC%9F/"/>
    <id>http://wxjttxs.github.io/2016/04/30/后序序列可以构成BST？/</id>
    <published>2016-04-30T12:35:43.000Z</published>
    <updated>2016-04-30T12:36:25.367Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//判断一个后序序列是不是二叉搜索树的后序遍历序列
//二叉搜索树的左子树＜根节点；右子树大于根节点
#include &amp;lt;iostream&amp;gt;

using namespace std;
bool SequenceIsBST(int *sequence, int length){
    if(sequence==NULL || length&amp;lt;=0)
        return false;
    int root=sequence[length-1];
    int i=0;
    for(;i&amp;lt;length-1;i++)
    {
        if(sequence[i]&amp;gt;root)
            break;
    }
    int j=i;
    for(;j&amp;lt;length-1;j++){
        if(sequence[j]&amp;lt;root)
            return false;
    }
    //上面的过程找到了左右子树
    bool left=true;//左子树是BST吗？
    if(i&amp;gt;0)//左子树存在
        left=SequenceIsBST(sequence,i);
    bool right=true;
    if(i&amp;lt;length-1)//存在右子树
        right=SequenceIsBST(sequence+i,j);
    return (left&amp;amp;&amp;amp;right);
}
int main()
{
    int a[]={5,7,6,9,11,10,8};
    cout&amp;lt;&amp;lt;SequenceIsBST(a,7);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//判断一个后序序列是不是二叉搜索树的后序遍历序列
//二叉搜索树的左子树＜根节点；右子树大于根节点
#include &amp;lt;iostream&amp;gt;

using namespace std;
bool SequenceIsBST(int *sequen
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按层打印二叉树(广度优先遍历)</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/04/30/按层打印二叉树/</id>
    <published>2016-04-30T11:51:36.000Z</published>
    <updated>2016-04-30T11:54:24.189Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树,然后按层打印每个节点,队列
#include  &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;exception&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot){
    if(!pTreeRoot)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; que;
    que.push(pTreeRoot);
    while(que.size()){
        BinaryTreeNode* pNode=que.front();//指向队列的第一个元素，要被弹出的元素
        que.pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft)//打印节点的左右子节点
            que.push(pNode-&amp;gt;m_pLeft);
        if(pNode-&amp;gt;m_pRight)
            que.push(pNode-&amp;gt;m_pRight);
    }
}
int main(){
    BinaryTreeNode* Btree;
    int preorder[]={8,6,5,7,10,9,11};
    int inorder[]={5,6,7,8,9,10,11};
    Btree= Contrust(preorder,inorder,7);
    PrintFromTopToBottom(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树,然后按层打印每个节点,队列
#include  &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;exception&amp;gt;
using namespace std;
stru
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>弹入序列 VS 弹出序列</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%BC%B9%E5%85%A5%E5%BA%8F%E5%88%97-VS-%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/04/30/弹入序列-VS-弹出序列/</id>
    <published>2016-04-30T07:26:15.000Z</published>
    <updated>2016-04-30T11:26:19.827Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//给定输入序列，判断给定的输出序列是不是真的
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

 bool IsPopOrder(const int* pPush, const int* pPop, int length){
    bool flag=false;
    if(pPush !=NULL  &amp;amp;&amp;amp; pPop!=NULL &amp;amp;&amp;amp; length&amp;gt;0){
        stack&amp;lt;int&amp;gt; stackData;//存取输入数据的栈,辅助栈
        const int* pNextPush=pPush;
        const int* pNextPop=pPop;
        while(pNextPop-pPop&amp;lt; length){
            while(stackData.empty()|| stackData.top()!=*pNextPop){//辅助栈的元素不等于
                if(pNextPush-pPush==length)
                    break;
                stackData.push(*pNextPush);
                pNextPush++;
            }
            if(stackData.top()!=*pNextPop)//找到最后也没有在 输入栈的栈顶元素找到输出栈的下一个元素,说明输出序列与输入不匹配
                break;
            stackData.pop();//找到匹配的元素
            pNextPop++;
        }
        if(stackData.empty() &amp;amp;&amp;amp; (pNextPop-pPop)==length)
            flag=true;

    }
    return flag;
 }
int main()
{
    const int push[]={1,2,3,4,5};
    const int pop[]={4,5,3,2,1};
    cout&amp;lt;&amp;lt;IsPopOrder(push,pop,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//给定输入序列，判断给定的输出序列是不是真的
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

 bool IsPopOrder(const int* pPush, 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>O(1)找到栈的最小值</title>
    <link href="http://wxjttxs.github.io/2016/04/30/O-1-%E6%89%BE%E5%88%B0%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://wxjttxs.github.io/2016/04/30/O-1-找到栈的最小值/</id>
    <published>2016-04-30T07:14:19.000Z</published>
    <updated>2016-04-30T07:14:58.735Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//O(1)时间找到栈中最小元素
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
template &amp;lt;typename T&amp;gt; class StackWithMin{
public:
    StackWithMin(void){};
    ~StackWithMin(void) {};
    void push(const T&amp;amp; value);
    void pop();
   const T minV();
private:
    stack&amp;lt;T&amp;gt; m_data;//原始的数据栈
    stack&amp;lt;T&amp;gt; m_min;//存放每次 压入栈的最小值
};
template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::push(const T&amp;amp;value){
    m_data.push(value);
    if(m_min.size()==0||value&amp;lt;m_min.top()){//辅助栈为空或者栈顶元素比新新输入的元素大，那么就把这个元素送入辅助栈
        m_min.push(value);
    }
    else
        m_min.push(m_min.top());//比如m_data 有的是3,4 ,那么m_min就会相应的是 3 3
}
template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::pop(){
    assert(m_data.size()&amp;gt;0 &amp;amp;&amp;amp; m_min.size()&amp;gt;0);
    m_data.pop();
    m_min.pop();
}
template &amp;lt;typename T&amp;gt;const T StackWithMin&amp;lt;T&amp;gt;::minV(){
    assert(m_data.size()&amp;gt;0&amp;amp;&amp;amp; m_min.size()&amp;gt;0);
    return m_min.top();
}
int main()
{
    StackWithMin&amp;lt;int&amp;gt; s;
    s.push(3);
    s.push(4);
    s.push(2);
    s.push(1);
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.pop();
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.pop();
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.push(0);
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//O(1)时间找到栈中最小元素
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
template &amp;lt;typen
    
    </summary>
    
    
  </entry>
  
</feed>
