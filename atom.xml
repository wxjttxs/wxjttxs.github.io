<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happy happy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxjttxs.github.io/"/>
  <updated>2016-04-30T13:28:24.945Z</updated>
  <id>http://wxjttxs.github.io/</id>
  
  <author>
    <name>王晓静</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树中和为给定值的路径</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://wxjttxs.github.io/2016/04/30/二叉树中和为给定值的路径/</id>
    <published>2016-04-30T13:27:40.000Z</published>
    <updated>2016-04-30T13:28:24.945Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//给定二叉树和一个值，找到二叉树中和等于这个值的路径
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void FindAllPath(BinaryTreeNode* pRoot,int expectedSum,vector&amp;lt;int&amp;gt;&amp;amp; path,int currentSum){
    currentSum+=pRoot-&amp;gt;m_nValue;
    path.push_back(pRoot-&amp;gt;m_nValue);
    bool isLeaf=(pRoot-&amp;gt;m_pLeft==NULL)&amp;amp;&amp;amp;(pRoot-&amp;gt;m_pRight==NULL);
    //叶子节点，并且路径上的节点的和等于期望的和
    if(currentSum==expectedSum &amp;amp;&amp;amp; isLeaf){
        cout&amp;lt;&amp;lt;&amp;quot;the path is found:&amp;quot;;
        vector&amp;lt;int&amp;gt;::iterator iter=path.begin();
        for(;iter!=path.end();iter++)
            cout&amp;lt;&amp;lt;*iter&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        cout&amp;lt;&amp;lt;endl;
    }
    //不是叶子节点，那就继续遍历左右子树
    if(pRoot-&amp;gt;m_pLeft)
        FindAllPath(pRoot-&amp;gt;m_pLeft,expectedSum,path,currentSum);
    if(pRoot-&amp;gt;m_pRight)
        FindAllPath(pRoot-&amp;gt;m_pRight,expectedSum,path,currentSum);
    //是叶子节点，但是路径的和并不等于期望的和,那就回退
    path.pop_back();
}
void FindPath(BinaryTreeNode* pRoot,int expectedSum){
    if(pRoot==NULL)
        return;
    vector&amp;lt;int&amp;gt; path;
    int currentSum=0;
    FindAllPath(pRoot,expectedSum,path,currentSum);
}
int main()
{
    BinaryTreeNode* Btree;
    int preorder[]={10,5,4,7,12};
    int inorder[]={4,5,7,10,12};
    Btree= Contrust(preorder,inorder,5);
    FindPath(Btree,22);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//给定二叉树和一个值，找到二叉树中和等于这个值的路径
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
struct Bi
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>后序序列可以构成BST？</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8F%AF%E4%BB%A5%E6%9E%84%E6%88%90BST%EF%BC%9F/"/>
    <id>http://wxjttxs.github.io/2016/04/30/后序序列可以构成BST？/</id>
    <published>2016-04-30T12:35:43.000Z</published>
    <updated>2016-04-30T12:36:25.367Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//判断一个后序序列是不是二叉搜索树的后序遍历序列
//二叉搜索树的左子树＜根节点；右子树大于根节点
#include &amp;lt;iostream&amp;gt;

using namespace std;
bool SequenceIsBST(int *sequence, int length){
    if(sequence==NULL || length&amp;lt;=0)
        return false;
    int root=sequence[length-1];
    int i=0;
    for(;i&amp;lt;length-1;i++)
    {
        if(sequence[i]&amp;gt;root)
            break;
    }
    int j=i;
    for(;j&amp;lt;length-1;j++){
        if(sequence[j]&amp;lt;root)
            return false;
    }
    //上面的过程找到了左右子树
    bool left=true;//左子树是BST吗？
    if(i&amp;gt;0)//左子树存在
        left=SequenceIsBST(sequence,i);
    bool right=true;
    if(i&amp;lt;length-1)//存在右子树
        right=SequenceIsBST(sequence+i,j);
    return (left&amp;amp;&amp;amp;right);
}
int main()
{
    int a[]={5,7,6,9,11,10,8};
    cout&amp;lt;&amp;lt;SequenceIsBST(a,7);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//判断一个后序序列是不是二叉搜索树的后序遍历序列
//二叉搜索树的左子树＜根节点；右子树大于根节点
#include &amp;lt;iostream&amp;gt;

using namespace std;
bool SequenceIsBST(int *sequen
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按层打印二叉树(广度优先遍历)</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/04/30/按层打印二叉树/</id>
    <published>2016-04-30T11:51:36.000Z</published>
    <updated>2016-04-30T11:54:24.189Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树,然后按层打印每个节点,队列
#include  &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;exception&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot){
    if(!pTreeRoot)
        return;
    queue&amp;lt;BinaryTreeNode*&amp;gt; que;
    que.push(pTreeRoot);
    while(que.size()){
        BinaryTreeNode* pNode=que.front();//指向队列的第一个元素，要被弹出的元素
        que.pop();
        cout&amp;lt;&amp;lt;pNode-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        if(pNode-&amp;gt;m_pLeft)//打印节点的左右子节点
            que.push(pNode-&amp;gt;m_pLeft);
        if(pNode-&amp;gt;m_pRight)
            que.push(pNode-&amp;gt;m_pRight);
    }
}
int main(){
    BinaryTreeNode* Btree;
    int preorder[]={8,6,5,7,10,9,11};
    int inorder[]={5,6,7,8,9,10,11};
    Btree= Contrust(preorder,inorder,7);
    PrintFromTopToBottom(Btree);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树,然后按层打印每个节点,队列
#include  &amp;lt;iostream&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;exception&amp;gt;
using namespace std;
stru
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>弹入序列 VS 弹出序列</title>
    <link href="http://wxjttxs.github.io/2016/04/30/%E5%BC%B9%E5%85%A5%E5%BA%8F%E5%88%97-VS-%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/04/30/弹入序列-VS-弹出序列/</id>
    <published>2016-04-30T07:26:15.000Z</published>
    <updated>2016-04-30T11:26:19.827Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//给定输入序列，判断给定的输出序列是不是真的
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

 bool IsPopOrder(const int* pPush, const int* pPop, int length){
    bool flag=false;
    if(pPush !=NULL  &amp;amp;&amp;amp; pPop!=NULL &amp;amp;&amp;amp; length&amp;gt;0){
        stack&amp;lt;int&amp;gt; stackData;//存取输入数据的栈,辅助栈
        const int* pNextPush=pPush;
        const int* pNextPop=pPop;
        while(pNextPop-pPop&amp;lt; length){
            while(stackData.empty()|| stackData.top()!=*pNextPop){//辅助栈的元素不等于
                if(pNextPush-pPush==length)
                    break;
                stackData.push(*pNextPush);
                pNextPush++;
            }
            if(stackData.top()!=*pNextPop)//找到最后也没有在 输入栈的栈顶元素找到输出栈的下一个元素,说明输出序列与输入不匹配
                break;
            stackData.pop();//找到匹配的元素
            pNextPop++;
        }
        if(stackData.empty() &amp;amp;&amp;amp; (pNextPop-pPop)==length)
            flag=true;

    }
    return flag;
 }
int main()
{
    const int push[]={1,2,3,4,5};
    const int pop[]={4,5,3,2,1};
    cout&amp;lt;&amp;lt;IsPopOrder(push,pop,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//给定输入序列，判断给定的输出序列是不是真的
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

 bool IsPopOrder(const int* pPush, 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>O(1)找到栈的最小值</title>
    <link href="http://wxjttxs.github.io/2016/04/30/O-1-%E6%89%BE%E5%88%B0%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://wxjttxs.github.io/2016/04/30/O-1-找到栈的最小值/</id>
    <published>2016-04-30T07:14:19.000Z</published>
    <updated>2016-04-30T07:14:58.735Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//O(1)时间找到栈中最小元素
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
template &amp;lt;typename T&amp;gt; class StackWithMin{
public:
    StackWithMin(void){};
    ~StackWithMin(void) {};
    void push(const T&amp;amp; value);
    void pop();
   const T minV();
private:
    stack&amp;lt;T&amp;gt; m_data;//原始的数据栈
    stack&amp;lt;T&amp;gt; m_min;//存放每次 压入栈的最小值
};
template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::push(const T&amp;amp;value){
    m_data.push(value);
    if(m_min.size()==0||value&amp;lt;m_min.top()){//辅助栈为空或者栈顶元素比新新输入的元素大，那么就把这个元素送入辅助栈
        m_min.push(value);
    }
    else
        m_min.push(m_min.top());//比如m_data 有的是3,4 ,那么m_min就会相应的是 3 3
}
template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::pop(){
    assert(m_data.size()&amp;gt;0 &amp;amp;&amp;amp; m_min.size()&amp;gt;0);
    m_data.pop();
    m_min.pop();
}
template &amp;lt;typename T&amp;gt;const T StackWithMin&amp;lt;T&amp;gt;::minV(){
    assert(m_data.size()&amp;gt;0&amp;amp;&amp;amp; m_min.size()&amp;gt;0);
    return m_min.top();
}
int main()
{
    StackWithMin&amp;lt;int&amp;gt; s;
    s.push(3);
    s.push(4);
    s.push(2);
    s.push(1);
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.pop();
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.pop();
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    s.push(0);
    cout&amp;lt;&amp;lt;s.minV();
    cout&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//O(1)时间找到栈中最小元素
#include &amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;assert.h&amp;gt;
using namespace std;
template &amp;lt;typen
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>今日头条</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    <id>http://wxjttxs.github.io/2016/04/27/今日头条/</id>
    <published>2016-04-27T13:28:24.000Z</published>
    <updated>2016-04-27T13:28:25.006Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>合并链表</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://wxjttxs.github.io/2016/04/27/合并链表/</id>
    <published>2016-04-27T06:59:54.000Z</published>
    <updated>2016-04-27T07:11:15.350Z</updated>
    
    <content type="html">&lt;p&gt;//原来有序的两个链表合并之后依然有序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
List Merge(List&amp;amp; L1, List&amp;amp; L2){
    ListNode* p1=L1;
    ListNode* p2=L2;
    ListNode* pMergeHead=NULL;
    if(L1==NULL)
        return L2;
    else if(L2==NULL)
        return L1;
    if((p1-&amp;gt;m_nValue) &amp;gt; (p2-&amp;gt;m_nValue)){
        pMergeHead=p1;
        pMergeHead-&amp;gt;m_pNext=Merge(p1-&amp;gt;m_pNext,p2);
    }
    else{
        pMergeHead=p2;
        pMergeHead-&amp;gt;m_pNext=Merge(p1,p2-&amp;gt;m_pNext);
    }
    return pMergeHead;
}
int main()
{

    List L=NULL;
    List S=NULL;
    Insert(L,1);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    Insert(S,2);
    Insert(S,3);
    Insert(S,4);
    Insert(S,5);
    Print(S);
    List tt=Merge(L,S);
    ListNode* p=tt;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;//还记得typedef struct and struct的区别吗？
下面的结果也是正确的  理解为ListNode *=List；
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
};//必须是一个链表


void Insert(ListNode* &amp;amp;pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(ListNode* &amp;amp;pHead){//ListNode* 链表，&amp;amp;pHead不会改变头结点
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
//ListNode* FindKthTotail(ListNode* pHead, int k){
//    if(pHead==NULL||k&amp;lt;=0)//非法输入
//        return NULL;
//    ListNode* p1=pHead, *p2=pHead;
//
//    for(int i=0;i&amp;lt;k-1;i++){
//        if(p1-&amp;gt;m_pNext!=NULL){
//            p1=p1-&amp;gt;m_pNext;//第一个指针走k-1步
//        }
//        else
//            return NULL;//长度不够k个节点
//     }
//
//
//    while(p1-&amp;gt;m_pNext!=NULL){
//            p2=p2-&amp;gt;m_pNext;
//            p1=p1-&amp;gt;m_pNext;
//    }
//    return p2;
//}
//ListNode *ReverseList(List &amp;amp;L){
//    ListNode* pNode=L;
//    List ReverseHead=NULL;
//    ListNode* pPre=NULL;//前一个节点
//    while(pNode!=NULL){
//        ListNode* pNext=pNode-&amp;gt;m_pNext;//保存后一个节点，不至于反转时候丢失
//
//        if(pNext==NULL)
//            ReverseHead=pNode;//就一个节点
//        pNode-&amp;gt;m_pNext=pPre;//实现反转
//        pPre=pNode;
//        pNode=pNext;//继续下一对节点的反转
//    }
//    return ReverseHead;
//}
ListNode  *Merge(ListNode  *L1, ListNode  *L2){
    ListNode* p1=L1;
    ListNode* p2=L2;
    ListNode* pMergeHead=NULL;
    if(L1==NULL)
        return L2;
    else if(L2==NULL)
        return L1;
    if((p1-&amp;gt;m_nValue) &amp;gt; (p2-&amp;gt;m_nValue)){
        pMergeHead=p1;
        pMergeHead-&amp;gt;m_pNext=Merge(p1-&amp;gt;m_pNext,p2);
    }
    else{
        pMergeHead=p2;
        pMergeHead-&amp;gt;m_pNext=Merge(p1,p2-&amp;gt;m_pNext);
    }
    return pMergeHead;
}
int main()
{

    ListNode  *L=NULL;
    ListNode  *S=NULL;
    Insert(L,1);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    Insert(S,2);
    Insert(S,3);
    Insert(S,4);
    Insert(S,5);
    Print(S);
    ListNode* p=Merge(L,S);
   // ListNode* p=tt;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//原来有序的两个链表合并之后依然有序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNod
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表反转</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <id>http://wxjttxs.github.io/2016/04/27/链表反转/</id>
    <published>2016-04-27T03:29:09.000Z</published>
    <updated>2016-04-27T03:30:13.730Z</updated>
    
    <content type="html">&lt;p&gt;//反转链表注意别断链&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
ListNode *ReverseList(List &amp;amp;L){
    ListNode* pNode=L;
    List ReverseHead=NULL;
    ListNode* pPre=NULL;//前一个节点
    while(pNode!=NULL){
        ListNode* pNext=pNode-&amp;gt;m_pNext;//保存后一个节点，不至于反转时候丢失

        if(pNext==NULL)
            ReverseHead=pNode;//就一个节点
        pNode-&amp;gt;m_pNext=pPre;//实现反转
        pPre=pNode;
        pNode=pNext;//继续下一对节点的反转
    }
    return ReverseHead;
}
int main()
{
    ListNode *p;
    List L=NULL;
    Insert(L,5);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    p=ReverseList(L);
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//反转链表注意别断链&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNe
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查找倒数第k个节点</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E6%9F%A5%E6%89%BE%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/04/27/查找倒数第k个节点/</id>
    <published>2016-04-27T02:51:00.000Z</published>
    <updated>2016-04-27T02:53:20.655Z</updated>
    
    <content type="html">&lt;p&gt;在O(1)时间实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}ListNode, *List;//必须是一个链表


void Insert(List&amp;amp; pHead,int data){
    ListNode* p=new ListNode;
    p-&amp;gt;m_nValue=data;
    p-&amp;gt;m_pNext=NULL;
    if(pHead==NULL)
        pHead=p;
    else{
        p-&amp;gt;m_pNext=pHead;
        pHead=p;
    }

}
void Print(List&amp;amp; pHead){
    if(pHead==NULL)
        return ;
    ListNode* p=pHead;
    while(p){
        cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        p=p-&amp;gt;m_pNext;
    }
    cout&amp;lt;&amp;lt;endl;
}
ListNode* FindKthTotail(ListNode* pHead, int k){
    if(pHead==NULL||k&amp;lt;=0)//非法输入
        return NULL;
    ListNode* p1=pHead, *p2=pHead;

    for(int i=0;i&amp;lt;k-1;i++){
        if(p1-&amp;gt;m_pNext!=NULL){
            p1=p1-&amp;gt;m_pNext;//第一个指针走k-1步
        }
        else
            return NULL;//长度不够k个节点
     }


    while(p1-&amp;gt;m_pNext!=NULL){
            p2=p2-&amp;gt;m_pNext;
            p1=p1-&amp;gt;m_pNext;
    }
    return p2;
}
int main()
{
    ListNode *p;
    ListNode* L=NULL;
    Insert(L,1);
    Insert(L,2);
    Insert(L,3);
    Insert(L,4);
    Print(L);
    p=FindKthTotail(L,4);
    cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在O(1)时间实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct ListNode{
    int m_nValue;
    ListNode* m_pNext
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>特定要求的排序：奇数移动到偶数前面</title>
    <link href="http://wxjttxs.github.io/2016/04/27/%E7%89%B9%E5%AE%9A%E8%A6%81%E6%B1%82%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%A5%87%E6%95%B0%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://wxjttxs.github.io/2016/04/27/特定要求的排序：奇数移动到偶数前面/</id>
    <published>2016-04-27T02:07:30.000Z</published>
    <updated>2016-04-27T02:09:29.838Z</updated>
    
    <content type="html">&lt;p&gt;//偶数移动到奇数后面,定义两个指针&lt;br&gt;//这个要求也可以改成别的，比如正数移到负数前面，只需要重写isodd()即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

bool isodd(int n){
    return n&amp;amp;0x01;
}
void ReorderOddEven(int *m,int length){
    if(m==NULL||length&amp;lt;=0)
        return;
    int *pBegin=m;
    int *pEnd=m+length-1;
    while(pBegin&amp;lt;pEnd){
        //向后移动pBegin直到指向偶数
        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; isodd(*pBegin))
            pBegin++;
        //向前移动EnD,直到指向奇数
        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; !isodd(*pEnd))
            pEnd--;
        if(pBegin&amp;lt;pEnd){
            swap(*pBegin,*pEnd);
        }
    }
    for(int i=0;i&amp;lt;length;i++)
        cout&amp;lt;&amp;lt;m[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
}

int main()
{
    int a[]={1,3,5,2,4};
    ReorderOddEven(a,5);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;//偶数移动到奇数后面,定义两个指针&lt;br&gt;//这个要求也可以改成别的，比如正数移到负数前面，只需要重写isodd()即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

bool isodd(i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>O(1)删除指定节点</title>
    <link href="http://wxjttxs.github.io/2016/04/26/O-1-%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9/"/>
    <id>http://wxjttxs.github.io/2016/04/26/O-1-删除指定节点/</id>
    <published>2016-04-26T15:21:25.000Z</published>
    <updated>2016-04-27T01:16:28.222Z</updated>
    
    <content type="html">&lt;p&gt;引入对typedef struct and struct 的结构的比较。&lt;a href=&quot;http://wenku.baidu.com/view/484d1f0b52ea551810a6875c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度文库&lt;/a&gt;&lt;br&gt;在C 和C++中有三种定义结构的方法&lt;br&gt;1.//这种方法可以在C and C++中定义一个S1结构体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct{

   }S1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.//只能在C++使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct S2{
   };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.//这种方法并没有定义结构体，而是定义了一个S3的结构变量，编译器会为S3分配内存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct{
  }S3;
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct Node&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int m_nValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;Node,*List;//必须添加typedef&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void InsertNode(List&amp;amp; L,int data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* p=new Node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;m_nValue=data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(NULL==L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&amp;#123;//采用头插法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p-&amp;gt;m_pNext=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void DeleteNode(List&amp;amp; L, Node* pToBeDeleted)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* p=new Node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(!L||!pToBeDeleted)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(pToBeDeleted==L)&amp;#123;//删除头结点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L=L-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delete pToBeDeleted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pToBeDeleted=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(pToBeDeleted-&amp;gt;m_pNext==NULL)&amp;#123;//尾节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(p-&amp;gt;m_pNext!=pToBeDeleted)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                p=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p-&amp;gt;m_pNext=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            delete pToBeDeleted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pToBeDeleted=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&amp;#123;//中间节点,用后一个数据直接覆盖前一个数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           p=pToBeDeleted-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           pToBeDeleted-&amp;gt;m_nValue=p-&amp;gt;m_nValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           pToBeDeleted-&amp;gt;m_pNext=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           delete p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           p=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void PrintNode(List&amp;amp; L)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(NULL==L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node* p=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cout&amp;lt;&amp;lt;p-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List L=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InsertNode(L,4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PrintNode(L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;&amp;quot;输入删除节点：&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cin&amp;gt;&amp;gt;data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p=L;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(p-&amp;gt;m_nValue!=data&amp;amp;&amp;amp; p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p=p-&amp;gt;m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DeleteNode(L,p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PrintNode(L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cin&amp;gt;&amp;gt;data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;引入对typedef struct and struct 的结构的比较。&lt;a href=&quot;http://wenku.baidu.com/view/484d1f0b52ea551810a6875c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度文库&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>post打印1~n的最大</title>
    <link href="http://wxjttxs.github.io/2016/04/22/post%E6%89%93%E5%8D%B01-n%E7%9A%84%E6%9C%80%E5%A4%A7/"/>
    <id>http://wxjttxs.github.io/2016/04/22/post打印1-n的最大/</id>
    <published>2016-04-22T01:28:32.000Z</published>
    <updated>2016-04-22T02:15:59.958Z</updated>
    
    <content type="html">&lt;p&gt;##字符串表示大树问题&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;string&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//判断什么到达最大的n位数是重中之重,第一位进1时候一定达到最大位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//bool Increment(char* number)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    int n=strlen(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    bool isOverflow=false;//最低位是否进位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    int nTakeOver=0;//每一位上的进位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    for(int i=n-1;i&amp;gt;=0;i--)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        int ithNum=number[i]-&amp;apos;0&amp;apos;+nTakeOver;//第i位上的数字,这个地方是“-”，由字符转换成数字是“-”，而由数字转换成字符是“+”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(i==n-1)//最高位那么就加1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            ithNum++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(ithNum&amp;gt;=10)&amp;#123;//第i位有进位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                if(i==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    isOverflow=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    ithNum-=10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    nTakeOver=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                    number[i]=&amp;apos;0&amp;apos;+ithNum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            number[i]=&amp;apos;0&amp;apos;+ithNum;//没有进位，还没到最大&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return isOverflow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//void PrintNumber(char* number)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    bool isBegin0=true;//从第一个不是0开头的数字开始打印&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    int n=strlen(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    for(int i=0;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(isBegin0 &amp;amp;&amp;amp; number[i]!=&amp;apos;0&amp;apos;)//不是以0开头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            isBegin0=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(!isBegin0)//开头不是0就输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            cout&amp;lt;&amp;lt;number[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//void Print1ToMaxofNdigits(int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    if(n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    char* number=new char[n+1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    memset(number,&amp;apos;0&amp;apos;,n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    number[n]=&amp;apos;\0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    while(!Increment(number))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        PrintNumber(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    delete []number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    Print1ToMaxofNdigits(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void PrintNumber(char* number)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool isBegin0=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int n=strlen(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(isBegin0&amp;amp;&amp;amp;number[i]!=&amp;apos;0&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isBegin0=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(!isBegin0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cout&amp;lt;&amp;lt;number[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void Print1ToMaxofNdigitsRecursively(char* number,int n, int index)&amp;#123;//把每一位都值成0~9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(index==n-1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PrintNumber(number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number[index+1]=i+&amp;apos;0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Print1ToMaxofNdigitsRecursively(number,n,index+1);//递归打印下一位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void Print1ToMaxofNdigits(int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char* number=new char(n+1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    number[n]=&amp;apos;\0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number[0]=i+&amp;apos;0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Print1ToMaxofNdigitsRecursively(number,n,0);//从第一位开始打印&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Print1ToMaxofNdigits(-1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##字符串表示大树问题&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>post错误处理方式</title>
    <link href="http://wxjttxs.github.io/2016/04/21/post%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://wxjttxs.github.io/2016/04/21/post错误处理方式/</id>
    <published>2016-04-21T14:22:15.000Z</published>
    <updated>2016-04-21T14:22:29.992Z</updated>
    
    <content type="html">&lt;p&gt;##三种处理错误异常的方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回值     优:和系统API一致;     
          缺：不能方便的使用结算结果;
全局变量   优：能够方便的使用结算结果;   
          缺：用户可能会检查全局变量;                                                                         
异常      优：可以为不同的出错原因定义不同异常类型，逻辑清晰明了；     
          缺：有些语言（C）不支持异常，抛出异常可能对性能有负面影响
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##实现阶乘陷阱多多&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//以为pow(x,n)很简单，但是好多陷阱,比如指数为负，底数为0，所以需要错误处理(全局变量)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//基本而且完整的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool flag_error=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//double PowerUnsignedExp(double base,unsigned int exp)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    double result=1.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    if(exp==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    for(int i=0;i&amp;lt;exp;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        result*=base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//下面联系一下效率更高的一种。首先 x^n=x^(n/2)*x^(n/2)(n为偶数)；n为奇数（x^n=x^((n-1)/2)*...*x）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double PowerUnsignedExp(double base,unsigned int exp)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(exp==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double result=PowerUnsignedExp(base,exp&amp;gt;&amp;gt;1);//右移一位除以2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result*=result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(exp&amp;amp;0x1==1)//这个数为奇数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result*=base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool equalt(double a,double b)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((a-b&amp;lt;0.0000001)&amp;amp;&amp;amp;(b-a)&amp;lt;0.0000001)?1:0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double Power(double base, int exponent)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flag_error=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(equalt(base,0.0))&amp;#123;//底数W为0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flag_error=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 0;//因为底数为0造成的返回结果为0，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned int absExp=(exponent&amp;lt;0)?(-exponent):exponent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double result=PowerUnsignedExp(base,absExp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(exponent&amp;lt;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result=1.0/result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt;Power(10,3) &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##三种处理错误异常的方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回值     优:和系统API一致;     
          缺：不能方便的使用结算结果;
全局变量   优：能够方便的使用结算结果;   
          缺：用户可能会检查全局变量;         
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>旋转升序的最小值</title>
    <link href="http://wxjttxs.github.io/2016/04/21/%E6%97%8B%E8%BD%AC%E5%8D%87%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://wxjttxs.github.io/2016/04/21/旋转升序的最小值/</id>
    <published>2016-04-21T13:01:26.000Z</published>
    <updated>2016-04-21T13:09:18.524Z</updated>
    
    <content type="html">&lt;p&gt;//找出旋转有sheng序数组的最小值&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int inorder(int *a,int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(a==NULL||n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       throw exception();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int temp=a[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=1;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(a[i]&amp;lt;temp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp=a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int Minelement(int *a,int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int start=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int endt=n-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int mid=start;//如果这个数字就是有序的 1 2 3 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(a==NULL||n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(a[start]&amp;gt;=a[endt])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(start==endt-1)&amp;#123;//找到最小值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mid=endt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid=(start+endt)/2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(a[endt]==a[start]&amp;amp;&amp;amp;a[mid]==a[start])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              return inorder(a,n);//这里 必须再添加一个一个return，要不然就不会执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(a[mid]&amp;lt;=a[endt])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            endt=mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else if(a[mid]&amp;gt;=a[start])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            start=mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a[mid];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //测试用例：本身有序&amp;#123;1,2,3,4,5,6&amp;#125;，a[mid]=a[start]=a[endt];还有正常情况下的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a[6]=&amp;#123;0,1,1,1,1,1&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;Minelement(a,6)&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//找出旋转有sheng序数组的最小值&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序给定人数的年龄o(n)</title>
    <link href="http://wxjttxs.github.io/2016/04/21/%E6%8E%92%E5%BA%8F%E7%BB%99%E5%AE%9A%E4%BA%BA%E6%95%B0%E7%9A%84%E5%B9%B4%E9%BE%84o-n/"/>
    <id>http://wxjttxs.github.io/2016/04/21/排序给定人数的年龄o-n/</id>
    <published>2016-04-21T13:01:26.000Z</published>
    <updated>2016-04-21T13:04:03.523Z</updated>
    
    <content type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//实现上万个人的年龄的排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void ageSort(int *a,int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(a==NULL||n&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    const  int Maxage=99;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int countAge[Maxage+1];//0~99,一共100个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;Maxage+1;i++)&amp;#123;//每种年龄出现的次数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countAge[i]=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int age=a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(age&amp;lt;0||age&amp;gt;Maxage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;//输入不合法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countAge[age]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int index=0;//排好序的下标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for(int i=0;i&amp;lt;Maxage;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     for(int j=0;j&amp;lt;countAge[i];j++)&amp;#123;//,来控制每个年龄出现的次数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[index++]=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a[9]=&amp;#123;3,4,5,6,7,5,4,3,2&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ageSort(a,9);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;9;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>斐波那契你会了吗</title>
    <link href="http://wxjttxs.github.io/2016/04/21/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97/"/>
    <id>http://wxjttxs.github.io/2016/04/21/斐波那契你会了吗/</id>
    <published>2016-04-21T12:59:18.000Z</published>
    <updated>2016-04-21T13:02:09.045Z</updated>
    
    <content type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//斐波那契 O(n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using  namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int Fn(int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int f0=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int f1=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int fn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=2;i&amp;lt;=n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fn=f0+f1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f0=f1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f1=fn;//不断的基于前者结果修正&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return fn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;Fn(4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数字中有多少个1</title>
    <link href="http://wxjttxs.github.io/2016/04/21/1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://wxjttxs.github.io/2016/04/21/1的个数/</id>
    <published>2016-04-21T12:55:36.000Z</published>
    <updated>2016-04-21T12:57:41.248Z</updated>
    
    <content type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//这种算法的效率是o(n),也就是n多大，就进行多少次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//int Numberof1(int n)&amp;#123;//最好不要修改n,因为如果是负数，那么有可能会出现死循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    int countt=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    unsigned int flag=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    while(flag)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if(n &amp;amp; flag)//这个数与1,2,4，8相与&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            countt++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        flag=flag&amp;lt;&amp;lt;1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return countt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//下面这种可以提交速度到o(1的个数)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int Numberof1(int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int countt=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        countt++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n=n&amp;amp;(n-1);//这步操作可以消掉最右边的一位1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return countt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int temp=Numberof1(13);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; temp&amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表和队列</title>
    <link href="http://wxjttxs.github.io/2016/04/20/%E9%93%BE%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://wxjttxs.github.io/2016/04/20/链表和队列/</id>
    <published>2016-04-20T03:12:09.000Z</published>
    <updated>2016-04-20T08:01:54.583Z</updated>
    
    <content type="html">&lt;p&gt;关于模板类的详细说明，&lt;a href=&quot;http://feihu.me/blog/2014/the-origin-and-usage-of-typename/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* run this program using the console pauser or add your own getch, system(&amp;quot;pause&amp;quot;) or input loop */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template&amp;lt;typename T&amp;gt; class CQueue&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		CQueue(void)&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		~CQueue(void)&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		void appendTail(const  T&amp;amp; node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 T deleteHead();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		void output();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;T&amp;gt; stack1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;T&amp;gt; stack2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//插入元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template &amp;lt;typename T&amp;gt; void CQueue&amp;lt;T&amp;gt;::appendTail(const T&amp;amp; node)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack1.push(node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//删除元素并返回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template &amp;lt;typename T&amp;gt; T CQueue&amp;lt;T&amp;gt;::deleteHead()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(stack2.size()&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(stack1.size()&amp;gt;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack2.push(stack1.top());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(stack2.size()==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 0;//throw  exception();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    T head=stack2.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack2.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template&amp;lt;typename T&amp;gt;void CQueue&amp;lt;T&amp;gt;::output()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(stack1.size()&amp;gt;0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		T temp=stack1.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		cout&amp;lt;&amp;lt;temp&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char** argv) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CQueue&amp;lt;int&amp;gt; queu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    queu.appendTail(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    queu.appendTail(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    queu.appendTail(3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    queu.appendTail(4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //queu.output();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int len=4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(len&amp;gt;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;queu.deleteHead()&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        --len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来，实现两个队列完成栈的作用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template &amp;lt;typename T&amp;gt;class CStack&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CStack(void)&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~CStack(void)&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void addhead(const T&amp;amp; node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    T delethead();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    queue&amp;lt;T&amp;gt; queue1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    queue&amp;lt;T&amp;gt; queue2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template &amp;lt;typename T&amp;gt; void CStack&amp;lt;T&amp;gt;::addhead(const T&amp;amp; element)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(queue1.size()&amp;gt;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        queue1.push(element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else if(queue2.size()&amp;gt;0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        queue2.push(element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        queue1.push(element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//删除的实现更好理解一点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//画个图，会很直观&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;template &amp;lt;typename T&amp;gt; T CStack&amp;lt;T&amp;gt;::delethead()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(queue2.size()==0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(queue1.size()&amp;gt;1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            queue2.push(queue1.front());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            queue1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        T&amp;amp; head=queue1.front();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        queue1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(queue2.size()&amp;gt;1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            queue1.push(queue2.front());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            queue2.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        T&amp;amp; head=queue2.front();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        queue2.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CStack&amp;lt;char&amp;gt; s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.addhead(&amp;apos;a&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.addhead(&amp;apos;b&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.addhead(&amp;apos;c&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;s.delethead()&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.addhead(&amp;apos;f&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;s.delethead()&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;关于模板类的详细说明，&lt;a href=&quot;http://feihu.me/blog/2014/the-origin-and-usage-of-typename/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>构建二叉树</title>
    <link href="http://wxjttxs.github.io/2016/04/20/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wxjttxs.github.io/2016/04/20/构建二叉树/</id>
    <published>2016-04-20T01:44:51.000Z</published>
    <updated>2016-04-29T03:46:55.167Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树，进一步的，判断一棵树是不是另一棵树的子树
#include  &amp;lt;iostream&amp;gt;\
#include&amp;lt;exception&amp;gt;
using namespace std;
struct BinaryTreeNode{
    int m_nValue;
    BinaryTreeNode* m_pLeft;
    BinaryTreeNode* m_pRight;
};

BinaryTreeNode* ContrustCore(int* startpreorder,int* endpreorder,int* startinorder,int* endinorder){
    //根据先序确定第一个数值确定根节点
   //BinaryTreeNode *root;
    int rootValue=startpreorder[0];
    BinaryTreeNode* root=new BinaryTreeNode();//为链表申请空间
    root-&amp;gt;m_nValue=rootValue;
    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;
    if(startpreorder==endpreorder){
        if(startinorder==endinorder &amp;amp;&amp;amp; *startpreorder==*endpreorder)//z只有一个根节点
            return root;
        else
            throw std::exception();
    }
    //在中序找到根节点所在位置
    int*rootinoder=startinorder;
     while(rootinoder&amp;lt;=endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)
        rootinoder++;
     if(rootinoder==endinorder &amp;amp;&amp;amp; *rootinoder!=rootValue)//在中序中没有找到根节点
         throw exception();
     int leftLength=rootinoder-startinorder;
     int* leftPreorderEnd=startpreorder+leftLength;
     if(leftLength&amp;gt;0)//左子树的长度,构建左子树
     {
         root-&amp;gt;m_pLeft=ContrustCore(startpreorder+1,leftPreorderEnd,startinorder,rootinoder-1);
     }
    if(leftLength&amp;lt;endpreorder-startpreorder)//存在右子树
        root-&amp;gt;m_pRight=ContrustCore(leftPreorderEnd+1,endpreorder,rootinoder+1,endinorder);
    return root;
}
BinaryTreeNode* Contrust(int* preorder,int* inorder,int length){
        if(preorder==NULL||inorder==NULL||length&amp;lt;=0)
            return NULL;
        return ContrustCore(preorder,preorder+length-1,inorder,inorder+length-1);
}
void postorder(BinaryTreeNode* Btree){//后序遍历输出书的各个节点 
    if(Btree!=NULL){
        postorder(Btree-&amp;gt;m_pLeft);
        postorder(Btree-&amp;gt;m_pRight);
        cout&amp;lt;&amp;lt;Btree-&amp;gt;m_nValue&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
}
//*************************************************
//判断根节点开始相同的树1是不是包含树2
bool DoesTree1haveTree2(BinaryTreeNode* pRoot1,BinaryTreeNode* pRoot2){//完全匹配
    if(pRoot2==NULL)
        return true;
    if(pRoot1==NULL)
        return false;
    if(pRoot1-&amp;gt;m_nValue!=pRoot2-&amp;gt;m_nValue)
        return false;
    return DoesTree1haveTree2(pRoot1-&amp;gt;m_pLeft,pRoot2-&amp;gt;m_pLeft)&amp;amp;&amp;amp;DoesTree1haveTree2(pRoot1-&amp;gt;m_pRight,pRoot2-&amp;gt;m_pRight);
}
//判断树1是不是包含树2，不一定从根节点开始
bool HasSubtree(BinaryTreeNode* pRoot1,BinaryTreeNode* pRoot2){
    bool result=false;
    if(pRoot1!=NULL &amp;amp;&amp;amp; pRoot2!=NULL){
        if(pRoot1-&amp;gt;m_nValue==pRoot2-&amp;gt;m_nValue)
            result=DoesTree1haveTree2(pRoot1,pRoot2);
        if(!result)
            result=HasSubtree(pRoot1-&amp;gt;m_pLeft,pRoot2);
        if(!result)
            result=HasSubtree(pRoot1-&amp;gt;m_pRight,pRoot2);

    }
     return result;
}

//****************************************************
//求一棵二叉树的镜像
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;void MirrorBinaryTree(BinaryTreeNode&lt;em&gt; pNode){&lt;br&gt;    if(pNode==NULL)&lt;br&gt;        return;&lt;br&gt;    if(pNode-&amp;gt;m_pLeft==NULL &amp;amp;&amp;amp; pNode-&amp;gt;m_pRight==NULL)//叶子节点，没有左右子树&lt;br&gt;        return;&lt;br&gt;    BinaryTreeNode&lt;/em&gt; temp= pNode-&amp;gt;m_pLeft;//交换非叶子节点&lt;br&gt;    pNode-&amp;gt;m_pLeft=pNode-&amp;gt;m_pRight;&lt;br&gt;    pNode-&amp;gt;m_pRight=temp;&lt;br&gt;    if(pNode-&amp;gt;m_pLeft)&lt;br&gt;        MirrorBinaryTree(pNode-&amp;gt;m_pLeft);//递归交换非叶子节点的左右子树&lt;br&gt;    if(pNode-&amp;gt;m_pRight)&lt;br&gt;        MirrorBinaryTree(pNode-&amp;gt;m_pRight);&lt;/p&gt;
&lt;p&gt;}&lt;br&gt;    int main(){&lt;br&gt;            BinaryTreeNode&lt;em&gt; Btree1,&lt;/em&gt;Btree2;&lt;br&gt;            int preorder1[]={10,8,9,2,4,7,7};&lt;br&gt;            int inorder1[]={9,8,4,2,7,10,7};&lt;br&gt;            int preorder2[]={8,9,2};&lt;br&gt;            int inorder2[]={9,8,2};&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        Btree1= Contrust(preorder1,inorder1,7);
        Btree2= Contrust(preorder2,inorder2,3);
        postorder(Btree1);
        cout&amp;lt;&amp;lt;endl;
    //    postorder(Btree2);
    //    cout&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;result:&amp;quot;;
    //    cout&amp;lt;&amp;lt;HasSubtree(Btree2,Btree1);
        MirrorBinaryTree(Btree1);
        postorder(Btree1);
        return 0;

}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;//根据先序和中序构建二叉树，进一步的，判断一棵树是不是另一棵树的子树
#include  &amp;lt;iostream&amp;gt;\
#include&amp;lt;exception&amp;gt;
using namespace std;
struct BinaryTreeN
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于链表必须知道的事</title>
    <link href="http://wxjttxs.github.io/2016/04/18/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://wxjttxs.github.io/2016/04/18/关于链表必须知道的事/</id>
    <published>2016-04-18T14:53:18.000Z</published>
    <updated>2016-04-19T14:02:17.722Z</updated>
    
    <content type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; //C++形式的链表的插入,遍历输出，链表倒序等操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//节点类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Node&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int data;//节点有数据，还有指向下一个指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node(int _data)&amp;#123;//显式构造函数，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            data=_data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            next=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class LinkList&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LinkList()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head=NULL;//显示构造函数，每次对新声明的链表类进行初始化，即表示创建一个新的“空”链表，只头指针，并且头指针值为NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void Insert(Node *node,int position);//成员函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void Output();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void Delete(int position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void Revers();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node *head;//设置为类的私有成员，只有通过类的成员函数才能访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void LinkList::Insert(Node *node,int position)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(head==NULL)&amp;#123;//链表为空，头节点指向这个插入节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head=node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(position==0)&amp;#123;//插入的节点作为新的头节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        node-&amp;gt;next=head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head=node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node *current_node=head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i=0;//从头开始遍历插入的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for( ;current_node!=NULL&amp;amp;&amp;amp;i&amp;lt;position-1;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current_node=current_node-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(i==position-1)&amp;#123;//找到插入位置的前一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        node-&amp;gt;next=current_node-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current_node-&amp;gt;next=node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void LinkList::Output()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(head==NULL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node* current_node=head;//从头开始遍历&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(current_node!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cout&amp;lt;&amp;lt;current_node-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            current_node=current_node-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void LinkList::Delete(int position)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(head==NULL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node *current=head;//从头遍历&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(position==0)&amp;#123;//s删掉头节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head=head-&amp;gt;next;//下一个节点作为头指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delete current;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i=0;//记录遍历过的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(current-&amp;gt;next!=NULL &amp;amp;&amp;amp; i&amp;lt;position-1)&amp;#123;//找到删除位置的前一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current=current-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(i==position-1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node* delete_node=current-&amp;gt;next;//current代表的是删除位置的前一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current-&amp;gt;next=current-&amp;gt;next-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delete delete_node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void LinkList::Revers()&amp;#123;//既然可以用栈，就可以改写成递归,但是链表是私有的所以不能改成递归&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack&amp;lt;Node*&amp;gt; nodes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node* current=head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(current!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nodes.push(current);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current=current-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(!nodes.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current=nodes.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;current-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nodes.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(void)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LinkList link;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node* node=new Node(i);//为每个节点开辟一个空间,并赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        link.Insert(node,i);//插入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    link.Output();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    link.Delete(3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    link.Output();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    link.Revers();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
    
    </summary>
    
    
  </entry>
  
</feed>
